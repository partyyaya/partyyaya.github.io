(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["webpackNote"],{"46d1":function(n,r,e){},"58b8":function(n,r,e){},"61bb":function(n,r,e){"use strict";e.r(r);var t=e("7a23");function o(n,r,e,o,a,s){var i=Object(t["y"])("Loading");return Object(t["r"])(),Object(t["d"])(t["a"],null,[o.displayLoading?(Object(t["r"])(),Object(t["d"])(i,{key:0,class:{"content--hide":!o.showLoading,"content--show":o.showLoading}},null,8,["class"])):Object(t["e"])("",!0),o.displayContent?(Object(t["r"])(),Object(t["d"])("div",{key:1,class:{"markdown-content":!0,"content--hide":!o.showContent,"content--show":o.showContent}},[Object(t["h"])("div",{class:"markdown-body",innerHTML:o.htmlContent},null,8,["innerHTML"])],2)):Object(t["e"])("",!0)],64)}var a=e("1da1"),s=(e("96cf"),e("ed08")),i=e("df69"),l=e("d4cd"),c=e.n(l),p=e("2338"),d=e("1487"),u=e.n(d),m=e("3a5e"),h="## Webpack 筆記\r\n<a id=\"user-content-top\"></a>\r\n\r\n### 目錄\r\n<details open>\r\n<summary style=\"cursor: pointer;\">&nbsp;目錄清單 </summary>\r\n\r\n- [Webpack 介紹](#user-content-introduce)\r\n- [學前知識：Module](#user-content-module)\r\n- [Webpack 基礎配置](#user-content-install)\r\n- [entry 與 output](#user-content-entry-output)\r\n- [Loader](#user-content-loader)\r\n  - [Loader 圖片配置](#user-content-loader-image)\r\n  - [Loader 樣式與字體配置](#user-content-loader-css-font)\r\n- [Plugins](#user-content-plugins)\r\n- [SourceMap](#user-content-sourcemap)\r\n- [WebpackDevServer 與 熱模塊更新](#user-content-devserver)\r\n- [Babel](#user-content-babel)\r\n- [Esbuild-loader](#user-content-esbuild-loader)\r\n- [Tree Shaking](#user-content-tree-shaking)\r\n- [開發與打包設定](#user-content-setting)\r\n- [Code Splitting](#user-content-code-splitting)\r\n- [Caching 緩存](#user-content-caching)\r\n- [Shimming](#user-content-shimming)\r\n- [Env 環境變數](#user-content-env)\r\n- [製作 Library](#user-content-library)\r\n- [ESLint 配置](#user-content-eslint)\r\n- [性能優化](#user-content-optimization)\r\n- [多頁面配置](#user-content-multiple-page)\r\n- [參考連結](#user-content-link)\r\n\r\n</details>\r\n\r\n<hr id=\"user-content-introduce\" style=\"height: 4px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Webpack 介紹</a>\r\n- [官網](https://webpack.js.org/)\r\n```txt\r\nwebpack 是靜態模塊打包器\r\nwebpack 處理時會將所有模塊打包成一或多個文件\r\n```\r\n\r\n<hr id=\"user-content-module\" style=\"height: 4px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Module</a>\r\n- 用途與定義\r\n  - 局部作用域的代碼塊\r\n  - 模塊主要解決問題分析\r\n    - 將功能切分模塊化\r\n    - 消除全局變量\r\n    - 模塊加載的順序\r\n- 使用 ```script``` 加載方式\r\n  ```html\r\n  <script src=\"./your.js\" type=\"module\"><\/script>\r\n  ```\r\n- 導出與導入\r\n  - 導出與導入可分開存在\r\n  - 被導入的 ```module``` 都會先執行一次\r\n    - 重複導入多次也只會執行一次\r\n  - 使用方式\r\n  ```js\r\n  /* \r\n  1. 使用 export default 導出導入\r\n  一個 module 只能有一個 export default\r\n  使用 export default 導出則導入時可以隨意命名\r\n  */\r\n  // 導出\r\n  export default { test:'test' };\r\n  // 導入\r\n  import m from './module.js'\r\n\r\n  /* \r\n  2. 一般導出導入\r\n  非 export default 不能随意命名\r\n  使用一般導出必須命名否則導入無法呼叫\r\n  */\r\n  // 導出\r\n  export const age = 18;\r\n  // 導入\r\n  import { age } from './module.js';\r\n\r\n  /*\r\n  3. 複數導出導入\r\n  導入時不用按照順序但要同名\r\n  */\r\n  // 導出\r\n  function fn() {}\r\n  class className {}\r\n  const age = 18;\r\n  export { fn, className, age };\r\n  // 導入\r\n  import {age, fn, className} from './module.js'\r\n\r\n  /*\r\n  4. 導出導入使用別名\r\n  */\r\n  // 導出\r\n  export { fn as func, className, age };\r\n  // 導入\r\n  import { func, age, className as Person } from './module.js';\r\n\r\n  /*\r\n  5. 整體導入\r\n  */\r\n  // 導出\r\n  function fn() {}\r\n  class className {}\r\n  const age = 18;\r\n  export { fn, className };\r\n  export default age;\r\n  // 導入\r\n  import * as test from './module.js'\r\n  // export default 可藉由 test.default 取得\r\n  console.log(test.default.age)\r\n  // 一般導出取值方式\r\n  console.log(test.className)\r\n\r\n  /*\r\n  6. 同時導入\r\n  export default 必須在最前面就導入\r\n  */\r\n  // 導出\r\n  function fn() {}\r\n  class className {}\r\n  const age = 18;\r\n  export { fn, className };\r\n  export default age;\r\n  // 導入\r\n  import age, { func, className } from './module.js';\r\n\r\n  /*\r\n  7. 導入與導出的複合寫法\r\n  若用複合寫法導出的無法在當前模塊使用\r\n  */\r\n  // 導出\r\n  const age = 18;\r\n  export { age };\r\n  // 導入\r\n  export { age } from './module.js';\r\n  // 等於(但無法在當前模塊使用)\r\n  import { age } from './module.js';\r\n  export { age };\r\n  ```\r\n- 注意事項\r\n  - 模塊內的 ```this``` 為 ```undefined``` 不為 ```window```\r\n  - ```import``` 語句只能在最頂層，執行時其他代碼都未執行\r\n  - 若要在代碼執行時導入則使用 ```import()```\r\n    ```js\r\n    if (PC) {\r\n      let pcModule = await import('pc.js');\r\n      // 取得 export default\r\n      console.log(pcModule.default)\r\n    } else if (Mobile) {\r\n      import('mobile.js').then((result)=>{\r\n        // 取得 export default\r\n        console.log(result.default)\r\n      }).catch();\r\n    }\r\n    ```\r\n\r\n<hr id=\"user-content-install\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >基礎配置</a>\r\n- 安装 ```webpack```\r\n  - ```webpack-cli``` 使命令行執行 ```webpack``` 的工具\r\n  - ```-D``` 代表 ```--save-dev```\r\n  ```txt\r\n  安裝最新版本: npm install webpack webpack-cli -D\r\n  安裝指定版本: npm install webpack@版本號 webpack-cli@版本號 -D\r\n  觀看安裝資訊: npm info webpack\r\n  ```\r\n- 配置 ```webpack```\r\n  - 創建 ```webpack.config.js``` 檔案\r\n    ```javascript\r\n    const path = require('path');\r\n    module.exports = {\r\n      // mode 默認為 production\r\n      // development 代表編譯不混淆不壓縮(默認混淆並壓縮)\r\n      mode: 'development',\r\n      // entry: 代表需要編譯的檔案路徑\r\n      entry: './src/index.js',\r\n      // output: 輸出路徑(建立dist資料夾並新增編譯完成的文件 bundle.js)\r\n      output: {\r\n        /*\r\n          __dirname 代表 webpack.config.js 所在路徑\r\n          path 不寫也會默認打包於dist目錄\r\n          path 必須為絕對路徑\r\n        */\r\n        path: path.resolve(__dirname, 'dist'),\r\n        filename: 'bundle.js'\r\n      }\r\n    };\r\n    ```\r\n  - 在 ```package.json``` 添加配置\r\n    - 添加 ``` \"private\": true``` 不發佈到 ```npm``` 倉庫 \r\n    - 在 ``` scripts``` 添加 ```webpack``` 的命令\r\n      - 使用 ```scripts``` 可簡化執行語句 \r\n      ```txt\r\n      webpack 默認設定執行文件: webpack.config.js \r\n      若要改其他名字則可用 --config\r\n      以下兩句指令相等\r\n      \"webpack\": \"webpack --config webpack.config.js\" \r\n      \"webpack\": \"webpack\" \r\n      ```\r\n- 編譯執行：```npm run webpack```\r\n\r\n<hr id=\"user-content-entry-output\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >entry 與 output</a>\r\n- entry 為入口，output 為出口\r\n  ```js\r\n  // entry\r\n  // 單入口(默認入口名為 main)\r\n  entry: './src/index.js',\r\n  // 多入口\r\n  entry: {\r\n    main: './src/index.js',\r\n    search: './src/search.js'\r\n  },\r\n  // output\r\n  // 若只有單入口\r\n  output: {\r\n    path: path.resolve(__dirname, 'dist'),\r\n    filename: 'bundle.js'\r\n  }\r\n  /*\r\n    若有多入口\r\n    [name] 會比對取得入口的名字\r\n    比如在 entry 定義 search 入口，則會輸出 search.js\r\n  */\r\n  output: {\r\n    // 若要放在伺服器上，可用 publicPath 加上網址前綴\r\n    publicPath: 'http://yourDomain',\r\n    path: path.resolve(__dirname, 'dist'),\r\n    filename: '[name].js'\r\n  }\r\n  ```\r\n<hr id=\"user-content-loader\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Loader</a>\r\n- 官網：[loader](https://webpack.js.org/loaders/)\r\n- 目的：```loader``` 能讓 ```webpack``` 處理非 JS 文件的模塊\r\n- ```loader``` 處理順序為從下到上、從右到左\r\n- 於 ```webpack.config.js``` 以下位置配置\r\n  ```js\r\n  module: {\r\n      rules: [\r\n        {\r\n          test: /\\.css$/,\r\n          // loaders 配置位置\r\n          use: []\r\n        },\r\n      ]\r\n    },\r\n  ```\r\n- ```Asset Modules``` 功能使用\r\n  - [官網介紹](https://webpack.js.org/guides/asset-modules/)\r\n  - ```asset``` 對應 ```url-loader```\r\n  - ```asset/inline``` 對應 ```url-loader```，像是注入在檔案裡面，類似內部連結\r\n  - ```asset/resource``` 對應 ```file-loader```，用途偏向搬移檔案並外部連結到該檔案\r\n  - ```asset/source``` 對應 ```raw-loader```\r\n\r\n<hr id=\"user-content-loader-image\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Loader 圖片配置</a>\r\n- 安裝依賴\r\n  ```txt\r\n  npm install html-loader image-webpack-loader -D\r\n  ```\r\n- 在 ```webpack.config.js``` 配置\r\n  ```js\r\n  {\r\n    test: /\\.(html)$/,\r\n    // 使用 html-loader 轉換 html 文件內圖片連結\r\n    loader: 'html-loader',\r\n    options: {\r\n      sources: {\r\n        list: [\r\n          // 檢測 html 標籤是否使用特定屬性並替換正確圖片路徑\r\n          {\r\n            tag: \"option\",\r\n            attribute: 'title',\r\n            type: 'src',\r\n          },\r\n          {\r\n            tag: \"img\",\r\n            attribute: \"src\",\r\n            type: \"src\",\r\n          },\r\n        ]\r\n      }\r\n    }\r\n  },\r\n  {\r\n    // 入口檢測符合規則的檔名\r\n    test: /\\.(png|jpe?g|gif|svg)$/,\r\n    // url-loader 於 webpack5 棄用，改用以下配置\r\n    type: 'asset/resource',\r\n    generator: {\r\n      /*\r\n        [name]:使用原檔案名\r\n        [hash]:該次打包的哈希值\r\n        [contenthash]:圖片內容的哈希值\r\n        [ext]:使用原副檔名(前面會自動加上\".\")\r\n      */\r\n      filename: `[name].[contenthash][ext]`\r\n    },\r\n    // 若需使用多個 loader 則使用 use 數組\r\n    use: [{\r\n      // 使用指定的 loader\r\n      // 使用 image-webpack-loader 將圖片壓縮\r\n      loader: 'image-webpack-loader',\r\n      options: {\r\n        // 只在 production 環境啟用圖片壓縮\r\n        disable: mode === 'production' ? false : true,\r\n        // 輸出至指定目錄下\r\n\t\t\t\t// outputPath: 'images/',\r\n        mozjpeg: {\r\n          progressive: true,\r\n          quality: 75,\r\n        },\r\n        optipng: {\r\n          enabled: false, // 表示不啟用這一個圖片優化器\r\n        },\r\n        pngquant: {\r\n          quality: [0.65, 0.9],\r\n          speed: 4,\r\n        },\r\n        gifsicle: {\r\n          interlaced: false,\r\n        },\r\n        webp: {\r\n          quality: 75, // 配置選項表示啟用 WebP 優化器\r\n        },\r\n      },\r\n    }]\r\n  }\r\n  ```\r\n- 最後在指定的 ```js``` 文件引入即可\r\n  ```js\r\n  import './avatar.jpg';\r\n  ```\r\n\r\n<hr id=\"user-content-loader-css-font\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Loader 樣式與字體配置</a>\r\n- 以下有兩種方式安裝與 ```webpack.config.js``` 配置\r\n  - 第一種將整合的 ```css``` 內容加入 ```head style``` 標籤內\r\n    - 安裝第三方依賴\r\n      ```txt\r\n      npm install style-loader css-loader \\\r\n      sass-loader node-sass \\\r\n      postcss-loader autoprefixer -D\r\n      ```\r\n    - ```webpack.config.js``` 配置\r\n      ```js\r\n      {\r\n        /*\r\n          loader 處理順序為從下到上、從右到左\r\n          style-loader 將整合的 css 內容加入 head style 標籤內\r\n          css-loader 將多個css檔案的關係整合成一個css檔案\r\n          sass-loader 需要安裝 sass-loader 與 node-sass\r\n          postcss-loader 需要配置 postcss.config.js 文件\r\n          autoprefixer 自動加上廠商前綴如:webkit\r\n        */\r\n        \r\n        test: /\\.scss$/,\r\n        use: [\r\n          'style-loader', \r\n          // loader 若要增加配置則用對象方法\r\n          {\r\n            loader: 'css-loader',\r\n            options: {\r\n              // 代表在使用前必須先跑兩個loader(sass-loader、postcss-loader)\r\n              importLoaders: 2,\r\n              // 樣式模塊化，使每個頁面樣式不會互相影響\r\n              modules: true\r\n            }\r\n          }, \r\n          'sass-loader',\r\n          'postcss-loader'\r\n        ]\r\n      }\r\n      ```\r\n  - 第二種將 ```css``` 內容檔案壓縮\r\n    - 安裝第三方依賴\r\n      ```txt\r\n      npm install css-loader \\\r\n      sass-loader node-sass \\\r\n      postcss-loader autoprefixer \\\r\n      mini-css-extract-plugin \\\r\n      css-minimizer-webpack-plugin -D\r\n      ```\r\n    - ```webpack.config.js``` 配置\r\n      ```js\r\n      const MiniCssExtractPlugin = require('mini-css-extract-plugin');\r\n      const CssMinimizerPlugin = require(\"css-minimizer-webpack-plugin\");\r\n      module: {\r\n          rules: [\r\n          {\r\n            /*\r\n              loader 處理順序為從下到上、從右到左\r\n              css-loader 將多個css檔案的關係整合成一個css檔案\r\n              sass-loader 需要安裝 sass-loader 與 node-sass\r\n              postcss-loader 需要配置 postcss.config.js 文件\r\n              autoprefixer 自動加上廠商前綴如:webkit\r\n            */\r\n            test: /\\.scss$/,\r\n            use: [\r\n              MiniCssExtractPlugin.loader, \r\n              // loader 若要增加配置則用對象方法\r\n              {\r\n                loader: 'css-loader',\r\n                options: {\r\n                  // 代表在使用前必須先跑兩個loader(sass-loader、postcss-loader)\r\n                  importLoaders: 2,\r\n                  // 樣式模塊化，使每個頁面樣式不會互相影響\r\n                  modules: true\r\n                }\r\n              },\r\n              'sass-loader',\r\n              'postcss-loader'\r\n            ]\r\n          }\r\n        ]\r\n      },\r\n      optimization: {\r\n        minimizer: [\r\n          // 將 css 檔案進行壓縮\r\n          new CssMinimizerPlugin()\r\n        ],\r\n      },\r\n      plugins: [\r\n        new MiniCssExtractPlugin({\r\n          filename: `[name].[${useHash}].css`,\r\n          chunkFilename: `[name].[${useHash}].chunk.css`\r\n        }),\r\n      ]\r\n      ```\r\n- 字體文件配置\r\n  - 將 ```eot、svg、ttf、woff``` 字體文件加入指定資料夾\r\n  - ```webpack.config.js``` 配置\r\n    ```js\r\n    {\r\n      test: /\\.(eot|ttf|svg)$/,\r\n      type: 'asset/resource',\r\n    },\r\n    ```\r\n  - ```index.scss``` 配置(檔名自行替換)\r\n    ```scss\r\n    @font-face {\r\n      font-family: \"iconfont\";\r\n      src: url('./font/iconfont.eot?t=1543245201565'); /* IE9*/\r\n      src: url('./font/iconfont.eot?t=1543245201565#iefix') format('embedded-opentype'), /* IE6-IE8 */\r\n      url('data:application/x-font-woff;charset=utf-8;base64,data') format('woff'),\r\n      url('./font/iconfont.ttf?t=1543245201565') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+*/\r\n      url('./font/iconfont.svg?t=1543245201565#iconfont') format('svg'); /* iOS 4.1- */\r\n    }\r\n\r\n    .iconfont {\r\n      font-family:\"iconfont\" !important;\r\n      font-size:16px;\r\n      font-style:normal;\r\n      -webkit-font-smoothing: antialiased;\r\n      -moz-osx-font-smoothing: grayscale;\r\n    }\r\n\r\n    .icon-changjingguanli:before { content: \"\\eb61\"; }\r\n\r\n    .icon-fenxiangfangshi:before { content: \"\\eb62\"; }\r\n    ```\r\n- ```postcss-loader``` 需要創建 ```postcss.config.js``` 文件\r\n  ```js\r\n  module.exports = {\r\n    plugins: [\r\n      require('autoprefixer')\r\n    ]\r\n  }\r\n  ```\r\n- 最後在指定的 ```js``` 文件引入即可\r\n  ```js\r\n  import './index.scss';\r\n  ```\r\n\r\n<hr id=\"user-content-plugins\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Plugins</a>\r\n- 使 ```webpack``` 可以執行更廣泛的任務\r\n- 於 ```webpack.config.js``` 以下位置配置\r\n  ```js\r\n  plugins:[\r\n\t  // plugins\r\n  ],\r\n  ```\r\n- 以 ```html-webpack-plugin``` 與 ```clean-webpack-plugin``` 為範例\r\n  - 安裝依賴\r\n    ```txt\r\n    npm install html-webpack-plugin clean-webpack-plugin -D\r\n    ```\r\n  - ```webpack.config.js``` 配置\r\n    ```js\r\n    const HtmlWebpackPlugin = require('html-webpack-plugin');\r\n    const { CleanWebpackPlugin } = require('clean-webpack-plugin');\r\n    plugins: [\r\n      // 設定增加需要顯示的頁面\r\n      new HtmlWebpackPlugin({\r\n        // 原資料檔案\r\n        template: './src/index.html',\r\n        // 輸出檔案名\r\n        filename: 'index.html',\r\n        // 設定需要的資源(entry)\r\n        chunks: ['main'],\r\n        minify: {\r\n          // 删除 html 中的註釋\r\n          removeComments: true,\r\n          // 删除 html 中的空格\r\n          collapseWhitespace: true,\r\n          // 删除 html 標籤的雙引號\r\n          removeAttributeQuotes: true,\r\n          // 將 html 文件內的 css 壓縮\r\n          minifyCSS: true,\r\n          // 將 html 文件內的 js 壓縮\r\n          minifyJS: true\r\n        }\r\n      }),\r\n      // 刪除原本打包檔案再重新打包\r\n      new CleanWebpackPlugin({\r\n        cleanAfterEveryBuildPatterns: ['dist']\r\n      })\r\n    ],\r\n    ```\r\n<hr id=\"user-content-sourcemap\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >SourceMap</a>\r\n- [官網介紹](https://webpack.js.org/configuration/devtool/)\r\n- 用途：在打包後的檔案中找出原檔案的映射錯誤位置\r\n- 常用配置\r\n  - ```mode: development```：```devtool: 'cheap-module-eval-source-map'```\r\n  - ```mode: production```：```devtool: 'cheap-module-source-map'```\r\n- 說明\r\n  - ```source-map```：用來生成 ```.map``` 文件對應位置\r\n  - ```inline-source-map```：將對應關係寫進 ```.js ```裡面(通常為底部)\r\n  - ```cheap```：指精準到行但不管在第幾個字，只負責觀察業務代碼裡的錯誤\r\n  - ```module```：觀察loader裡面的錯誤\r\n  - ```eval```：將對應關係使用 ```js eval``` 方式打包\r\n- 於 ```webpack.config.js``` 配置\r\n  ```js\r\n  devtool: 'cheap-module-eval-source-map',\r\n  ```\r\n\r\n<hr id=\"user-content-devserver\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >WebpackDevServer 與 熱模塊更新</a>\r\n- [官網 devServer 介紹](https://webpack.js.org/configuration/dev-server/)\r\n- 熱模塊更新介紹\r\n  - [Guides](https://webpack.js.org/guides/hot-module-replacement/)\r\n  - [Api](https://webpack.js.org/guides/hot-module-replacement/)\r\n  - [原理](https://webpack.js.org/concepts/hot-module-replacement/)\r\n- 用途：開發測試用，避免多次手動打包\r\n- 安裝依賴\r\n  ```txt\r\n  npm install webpack-dev-server -D\r\n  ```\r\n- 在 ```webpack.config.js``` 配置\r\n  - [proxy 請求轉發介紹](https://webpack.js.org/configuration/dev-server/#devserverproxy)\r\n\r\n  ```js\r\n  devServer: {\r\n    // 自動打開指定頁面\r\n    open: ['/F2_A.html'],\r\n    // 偵測文件是否修改，並自動 reload\r\n    watchFiles: ['src/**/*'],\r\n    compress: true,\r\n    port: 8699,\r\n    hot: true\r\n    proxy: {\r\n      /*\r\n        當 webpack 使用相對路徑時，藉由proxy可以轉發到特定網址\r\n        如：\r\n          axios.get('/react/api/header.json').then((res) => {\r\n            console.log(res);\r\n          })\r\n      */ \r\n      '/react/api': {\r\n        target: 'https://www.dell-lee.com',\r\n        // 若url為https開頭，則需要設定 false 才能轉發\r\n        secure: false,\r\n        // 若後端給暫時用的url，可以使用該方式暫時取代api路徑\r\n        pathRewrite: {\r\n          'header.json': 'demo.json'\r\n        },\r\n        // 擺脫轉發的server Origin 限制\r\n        changeOrigin: true,\r\n        // 自定義請求頭\r\n        headers: {\r\n          host: 'www.dell-lee.com',\r\n        }\r\n      }\r\n    }\r\n  },\r\n  ```\r\n- 在 ```package.json``` 加上\r\n  ```txt\r\n  \"scripts\": {\r\n    \"start\": \"webpack serve\",\r\n  }\r\n  若有指定檔案設定，可使用 --config 切換至指定檔案設定\r\n  \"scripts\": {\r\n    \"start\": \"webpack serve --config ./build/webpack.dev.js\"\r\n  }\r\n  ```\r\n- 開啟 ```devServer```：```npm run start```\r\n- 若須檢測是否開啟熱更新可在 ```js``` 加入\r\n  ```js\r\n  // 如果啟動熱模塊\r\n  if(module.hot) {\r\n    // 監測該number.js文件是否更動\r\n    module.hot.accept('./number', () => {\r\n      // 若更動則執行以下動作\r\n      // ...\r\n    })\r\n  }\r\n  ```\r\n\r\n<hr id=\"user-content-babel\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Babel</a>\r\n- 介紹\r\n  - 官網：[babel](https://babeljs.io/)\r\n  - 線上編譯：[babel-online](https://babeljs.io/repl)\r\n  ```txt\r\n  Babel 是 JavaScript 的編譯器\r\n  用來將 ES6 的代碼，轉換成 ES6 之前的代碼\r\n\r\n  但對於 ES6 新增的 API，如 Set、Map、Promise 等全局對象\r\n  及一些定義在全局對像上的方法（比如 Object.assign/Array.from）\r\n  都不能直接編譯，需要藉助其它的模塊\r\n  Babel 一般需配合 Webpack 來編譯模塊語法\r\n  ```\r\n- 使用方法\r\n  - [官方安裝說明](https://babeljs.io/setup#installation)\r\n  - 安装 ```Babel```\r\n    - 若是 ```TypeScript``` 專案，則 ```babel-loader``` 替換成 ```typescript-loader```\r\n    ```txt\r\n    npm i babel-loader @babel/core @babel/preset-env -D\r\n    ```\r\n  - 說明\r\n    - ```babel-loader```：Babel 和 webpack 傳輸檔案通道。\r\n    - ```@babel/core```：將es6以上代碼轉換AST再轉換成es5代碼\r\n    - ```@babel/preset-env```：含es6以上轉換es5的規則\r\n  - 文件配置\r\n    - 在 ```webpack.config.js``` 配置\r\n      ```js\r\n      {\r\n        test: /\\.js$/,\r\n        // exclude: 代表該路徑底下的文件不用轉譯\r\n        exclude: /node_modules/, \r\n        loader: 'babel-loader',\r\n      }\r\n      ```\r\n  - 創建 ```.babelrc``` 文件\r\n    - [babel-preset-env](https://babeljs.io/docs/en/babel-preset-env)\r\n    ```js\r\n    {\r\n      \"presets\": [\r\n        \"@babel/preset-env\",\r\n        // 可指定瀏覽器版本，可省略\r\n        { \r\n          targets: {\r\n            \"chrome\": \"58\",\r\n            \"ie\": \"11\"\r\n          },\r\n          useBuiltIns: 'usage'\r\n        }\r\n      ],\r\n    }\r\n    ```\r\n\r\n<hr id=\"user-content-esbuild-loader\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Esbuild-loader</a>\r\n- [官方 Github](https://github.com/privatenumber/esbuild-loader)\r\n- 使用方法\r\n  - 安裝依賴：```npm i esbuild-loader -D```\r\n  - 在 ```webpack.config.js``` 配置\r\n    - [target 說明](https://github.com/privatenumber/esbuild-loader#target)\r\n    ```js\r\n    // Javascript 配置\r\n    {\r\n      test: /\\.js$/,\r\n      loader: 'esbuild-loader',\r\n      options: {\r\n        // 若沒有使用JSX語法則移除\r\n        loader: 'jsx',\r\n        target: 'es2015'\r\n      }\r\n    },\r\n\r\n    // TypeScript 配置\r\n    // 若有 tsconfig.json 文件，loader 會自動進行檢測\r\n    {\r\n      test: /\\.tsx?$/,\r\n      loader: 'esbuild-loader',\r\n      options: {\r\n        loader: 'ts', // tsx\r\n        target: 'es2015',\r\n        // 可指定 TypeScript 設定文件\r\n        // tsconfigRaw: require('./tsconfig.json')\r\n      }\r\n    },\r\n    /*\r\n      依官方說明，若單純只用 js 並無使用其他插件\r\n      則只需加入此段設定即可\r\n    */\r\n    const { ESBuildMinifyPlugin } = require('esbuild-loader')\r\n    optimization: {\r\n      minimizer: [\r\n        new ESBuildMinifyPlugin({\r\n          target: 'es2015'\r\n        })\r\n      ]\r\n    },\r\n    ```\r\n\r\n<hr id=\"user-content-tree-shaking\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Tree Shaking</a>\r\n- 用途：刪除不必要的程式碼，減小打包體積\r\n- 只作用於 ```ESModule``` 語法\r\n- 有分兩種層級：```modules-level```、```statements-level```\r\n- ```modules-level```\r\n  - 作用於整個模塊，若該模塊未被使用則整個模塊會被刪除\r\n  - 要在 ```development``` 使用，須設置 ```optimization.sideEffects = true```，```production``` 默認為 ```true```\r\n  - 另外需在 ```package.json``` 設定 ```sideEffects```\r\n    - 可設定忽略指定文件 ```sideEffects=[\"*.css\"]``` \r\n    - 默認為 ```false``` 代表不用忽略任何文件，若設定 ```true``` 則 ```webpack``` 會自動分析是否有副作用\r\n- ```statements-level```\r\n  - 作用於模塊內語句，若該 ```import/export``` 未被使用則會被刪除\r\n  - 要在 ```development``` 使用，須設置\r\n    - ```optimization.usedExports = true```\r\n    - ```optimization.minimize = true```\r\n    - 以上設置 ```production``` 都默認為 ```true```\r\n\r\n<hr id=\"user-content-setting\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >開發與打包設定</a>\r\n- 用途：無須更改同頁面設定，並提高開發效率\r\n- 設定流程\r\n  - 安裝合併的依賴包：```npm install webpack-merge -D```\r\n  - 創建三個文件，並使用依賴進行合併共用設定\r\n    - 開發用設定：```webpack.dev.js```\r\n      ```js\r\n      const commonConfig = require('./webpack.common.js');\r\n      const { merge } = require('webpack-merge')\r\n\r\n      const devConfig = {\r\n        devServer: {\r\n          // 自動打開指定頁面\r\n          open: ['/your.html'],\r\n          // 偵測文件是否修改，並自動 reload\r\n          watchFiles: ['src/**/*'],\r\n          compress: true,\r\n          port: 8699,\r\n          hot: true\r\n        },\r\n        optimization: {\r\n          usedExports: true,\r\n        },\r\n      }\r\n      // 使用 merge 合併共用設定\r\n      module.exports = merge(commonConfig, devConfig);\r\n      ```\r\n    - 正式打包用設定：```webpack.prod.js```\r\n      - 安裝依賴：```npm i clean-webpack-plugin -D```\r\n      ```js\r\n      const commonConfig = require('./webpack.common.js');\r\n      const { merge } = require('webpack-merge')\r\n      // 重新打包時使用\r\n      const { CleanWebpackPlugin } = require('clean-webpack-plugin');\r\n\r\n      const proConfig = {\r\n        plugins: [\r\n          // 刪除原本打包檔案再重新打包\r\n          new CleanWebpackPlugin({\r\n            cleanAfterEveryBuildPatterns: ['yourPackage']\r\n          })\r\n        ]\r\n      }\r\n\r\n      module.exports = merge(commonConfig, proConfig);\r\n      ```\r\n    - 共同的設定：```webpack.common.js```\r\n  - 設定 ```package.json script```\r\n    ```txt\r\n    \"webpack\": \"webpack --config ./build/webpack.prod.js\",\r\n    \"dev\": \"webpack serve --config ./build/webpack.dev.js\"\r\n    ```\r\n\r\n<hr id=\"user-content-code-splitting\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Code Splitting</a>\r\n- ```Code Splitting(代碼切割)``` 與 ```webpack``` 無直接關係\r\n- 用途：將代碼拆分可以節省下載的流量(只下載更改的部分)\r\n- ```webpack``` 實現代碼切割有兩種方式\r\n  - 同步代碼：只需 ```webpack``` 設定 ```optimization``` 的配置即可\r\n  - 異步代碼：無需任何配置，會自動代碼分割，放置到新的文件中\r\n- ```webpack``` 使用 ``` splitChunks``` 進行配置\r\n  - [官方說明](https://webpack.js.org/plugins/split-chunks-plugin/)\r\n  - 配置範例\r\n    ```js\r\n    optimization: {\r\n      splitChunks: {\r\n        /*\r\n          async：只處理 Lazy Loading 的 chunks，例如 import(xxx) 語法載入的模組，會走到 cacheGroups 查看配置\r\n          initial：只處理同步加載的 chunk，例如 import xxx 語法載入的模組\r\n          all：兼容以上兩種方式，通通進行處理\r\n        */\r\n        chunks: 'all',\r\n        // 若大於30kb才進行代碼分割\r\n        minSize: 30000,\r\n        // 幾乎不用，若超過 50kb 則進行多次拆分(基本上庫都拆分不了)\r\n        maxSize: 50000,\r\n        // 該模組被引用的次數\r\n        minChunks: 1,\r\n        // 若引用發送的request超過5個js 則不再代碼分割\r\n        maxAsyncRequests: 5,\r\n        // 入口文件引用的庫最多分割成 3 個js再多就不再代碼分割\r\n        maxInitialRequests: 3,\r\n        // 文件生成時會出現連接符，如:vendors~main.js\r\n        automaticNameDelimiter: '~',\r\n        // 使用 cacheGroups 下的命名\r\n        name: true,\r\n        // 打包後會察看是否符合條件加入緩存組(cacheGroups)，再依命名打包(vendors.js)\r\n        cacheGroups: {\r\n          // 若打包的庫於 node_modules 底下則都歸類到 vendors = vendors~main.js(後面main.js為入口檔名)\r\n          // priority 優先級(大到小)，cacheGroups會察看各命名的優先級進行打包命名\r\n          vendors: {\r\n            test: /[\\\\/]node_modules[\\\\/]/,\r\n            priority: -10,\r\n            // 若不想取名為 vendors~xxx.js 則可自己命名\r\n            // filename: 'vendors.js',\r\n          },\r\n          // 若不在 vendors 則使用 default 配置\r\n          default: {\r\n            priority: -20,\r\n            // 代表若該庫已被打包，則其他地方在引用相同庫時則直接進行復用不重新打包進去\r\n            reuseExistingChunk: true,\r\n            // 若不想取名為 default~xxx.js 則可自己命名\r\n            filename: 'common.js'\r\n          }\r\n        }\r\n      }\r\n    }, \r\n    ```\r\n- ```webpack``` 異步加載語句範例 ```index.js```\r\n  - ```/* webpackChunkName:\"lodash\" */``` 代表在異步加載個別打包 ```lodash``` 時取名為 ```lodash```\r\n  ```js\r\n  async function getComponent() {\r\n    const { default: _ } = await import(/* webpackChunkName:\"lodash\" */ 'lodash');\r\n    const element = document.createElement('div');\r\n    element.innerHTML = _.join(['ming', '123'], '-');\r\n    return element;\r\n  }\r\n\r\n  // 懶加載即節省加載網路資源，更快的將頁面渲染給使用者\r\n  // chunk 代表打包後的每一個文件都是一個區塊\r\n  document.addEventListener('click', () =>{\r\n    getComponent().then(element => {\r\n      document.body.appendChild(element);\r\n    });\r\n  })\r\n  ```\r\n\r\n<hr id=\"user-content-caching\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Caching 緩存</a>\r\n- 在之前使用 ```Loader``` 加載圖片時使用過，主要為以下幾種\r\n  - ```[hash]```：該次打包的哈希值，無緩存作用\r\n  - ```[contenthash]```：內容的哈希值，可進行內容對比達到緩存作用\r\n  - ```[chunkhash]```：為依賴包的哈希值，可進行內容對比達到緩存作用\r\n  - 可加上 ```:(length)``` 減少哈希值字串長度(預設為20)\r\n    - 如：```[name].[contenthash:8][ext]```\r\n```js\r\n{\r\n  // 入口檢測符合規則的檔名\r\n  test: /\\.(png|jpe?g|gif|svg)$/,\r\n  // url-loader 於 webpack5 棄用，改用以下配置\r\n  type: 'asset/resource',\r\n  generator: {\r\n    /*\r\n      [name]:使用原檔案名\r\n      [hash]:該次打包的哈希值\r\n      [contenthash]:圖片內容的哈希值\r\n      [ext]:使用原副檔名(前面會自動加上\".\")\r\n    */\r\n    filename: `[name].[contenthash][ext]`\r\n  },\r\n}\r\n\r\n// =========================================\r\noptimization: {\r\n  /*\r\n    在舊版本 webpack 可能會出現內容一樣但哈希值也會變化\r\n    原因是 js 與 js 文件之間的關係: manifest \r\n    會包含在各個 js 文件內導致內容與原本有可能隨機不同\r\n    通過 runtimeChunk 將 manifest(文件之間的關係) 額外打包出來避免js內容有差異\r\n  */ \r\n  runtimeChunk: {\r\n    name: 'runtime'\r\n  },\r\n},\r\n```\r\n\r\n<hr id=\"user-content-shimming\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Shimming</a>\r\n- 用途：查看所有文件是否有相符，自動引入相關的依賴包\r\n  ```js\r\n  plugins: [\r\n    new webpack.ProvidePlugin({\r\n      // 當發現文件使用 $ 符號則自動引入 jquery\r\n      $: 'jquery',\r\n      // 當發現文件使用 _join 則引用 lodash 下的 join 方法\r\n      _join: ['lodash', 'join']\r\n    }),\r\n  ],\r\n  ```\r\n- 若要設定模塊 ```this``` 對象指向 ```window```\r\n  - 需要安裝依賴：```npm install imports-loader --save-dev```\r\n  - 並加入以下配置\r\n    ```js\r\n    module: {\r\n      rules: [{ \r\n        test: /\\.js$/, \r\n        exclude: /node_modules/,\r\n        // 若要用多個loader則須用use\r\n        use: [{\r\n          loader: 'babel-loader'\r\n        }, {\r\n          // 若要在 js 文件中 this === window\r\n          // 安裝 npm install imports-loader --save-dev\r\n          // 配置以下\r\n          loader: 'imports-loader?this=>window'\r\n        }]\r\n      }]\r\n    },\r\n    ```\r\n\r\n<hr id=\"user-content-env\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >Env 環境變數</a>\r\n- 通常不建議使用環境變數\r\n- 在 ```package.json``` 與 ```webpack``` 設定加入環境變數判斷\r\n  ```js\r\n  /*\r\n    env 在 package.json 定義\r\n    webpack --env.production --config ./build/webpack.common.js\"\r\n    上面 --env.production 即 production 默認為 true\r\n\r\n    若寫成 --env production \r\n    則下面 (env) 可以直接寫為 (production)\r\n\r\n    若寫成 --env.production=abc \r\n    則下面 if(env && env.production) \r\n    可以改寫為 if(env && env.production === 'abc')\r\n  */\r\n  \r\n  module.exports = (env) => {\r\n    if(env && env.production) {\r\n      return merge(commonConfig, prodConfig);\r\n    }else {\r\n      return merge(commonConfig, devConfig);\r\n    }\r\n  }\r\n  ```\r\n\r\n<hr id=\"user-content-library\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >製作 Library</a>\r\n- 若要使用 ```import``` 方式進行打包需安裝 ```webpack```\r\n  ```npm install webpack webpack-cli --save-dev```\r\n- 並建立 ```webpack.config.js```\r\n  - ```externals```：會進行忽略避免使用者有相同的依賴包\r\n    - ```externals``` [官方說明](https://webpack.js.org/configuration/externals/)\r\n    - ```externals``` 可以是其他的數組或對象\r\n    - 在文件內會依使用者的名字不同取名引用\r\n  ```js\r\n  module.exports = {\r\n    mode: 'production',\r\n    entry: './src/index.js',\r\n    externals: 'lodash',\r\n    output: {\r\n      path: path.resolve(__dirname, 'dist'),\r\n      filename: 'library.js',\r\n      // 如要用script引入方式則需使用此方式掛載到全局變量(window.root)\r\n      library: 'root',\r\n      /*\r\n        umd(Universal Module Definition) \r\n        代表無論使用者用哪種引入方式都通用(除了script引入方式)\r\n\r\n        libraryTarget 也可以變為 this, window, global\r\n        以上三種不常用並且無法使用通用引入方式\r\n      */\r\n      \r\n      libraryTarget: 'umd'\r\n  }\r\n  ```\r\n- 若全部製作完成則可以發佈到 ```npm``` 上\r\n  - 1.先至 ```npm``` 註冊帳號\r\n  - 2.在命令行加入帳號 ```npm adduser```\r\n  - 3.發佈到公用倉庫(若有相同名字會被阻擋) ```npm publish```\r\n\r\n<hr id=\"user-content-eslint\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >ESLint 配置</a>\r\n- [ESLint 官方設定說明](https://eslint.org/docs/user-guide/configuring/)\r\n- 安裝 ```ESLint```：```npm install eslint --save-dev```\r\n- 生成 ```ESLint``` 設定文件(```.eslintrc.js```)：```npx eslint --init ```\r\n- 若要在 ```git commit``` 之前檢測並阻止提交，可使用 ```git hooks```\r\n- 以下有多種使用 ```ESLint``` 檢測程式方式\r\n  - 1.對指定資料夾 ```src``` 進行檢測：```npx eslint src```\r\n  - 2.在 ```vscode``` 安裝 ```ESLint``` 插件，會自動監測不符合的程式碼並自動標示起來(提示會顯示用於哪一規則，可以進行取消)\r\n  - 3.使用 ```eslint-loader``` 檢測\r\n    - 安裝依賴：```npm install eslint-loader --save-dev```\r\n    - 在 ```webpack.config.js``` 分別做以下設定\r\n      ```js\r\n      // devServer\r\n      devServer: {\r\n        overlay: true,\r\n      }\r\n      // rules\r\n      { \r\n        test: /\\.js$/, \r\n        exclude: /node_modules/, \r\n        use: ['babel-loader', 'eslint-loader']\r\n      },\r\n      ```\r\n    - 完成配置後錯誤將顯示在頁面上\r\n\r\n<hr id=\"user-content-optimization\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >性能優化</a>\r\n- 加快打包效率，使上版與開發速度提升\r\n- 以下為多種性能優化方式\r\n  - 1.跟上技術迭代 ```Node、webpack、npm...```\r\n  - 2.運用 ```Loader``` 時盡量排除不需要處理的文件\r\n  - 3.```Plugins``` 盡可能精簡並確保可靠\r\n  - 4.控制包文件大小：```splitChunks、treeshaking...```\r\n  - 5.使用多進程打包：```thread-loader、parallel-webpack、happypack```\r\n  - 6.合理使用 ```sourceMap```\r\n  - 7.結合 ```stats``` 分析打包結果\r\n  - 8.開發環境配置：內存編譯、無用插件去除\r\n  - 9.```resolve``` 合理配置，```Webpack``` 會調用 ```Node``` 底層尋找相符的文件\r\n    - [resolve 官方文檔](https://webpack.js.org/configuration/resolve/)\r\n    - 範例\r\n      ```js\r\n      resolve: {\r\n        // 當引入時沒有加後綴，webpack會自動去尋找以下的後綴文件(左到右)\r\n        extensions: ['.js', '.jsx'],\r\n        // 當引入的是資料夾，沒設定則webpack默認會先抓index開頭的文件(左到右尋找)\r\n        // mainFiles: ['index','child'],\r\n        // alias 可將特定路徑下的文件當作依賴庫使用:import Child from 'child';\r\n        alias: {\r\n          child: path.resolve(__dirname, '../src/a/b/c/child')\r\n        }\r\n      },\r\n      ```\r\n  - 10.避免重複打包 ```node_modules(第三方)``` 依賴庫\r\n    - 1.建立 ```webpack.dll.js```\r\n      ```js\r\n      const path = require('path');\r\n      const webpack = require('webpack');\r\n\r\n      module.exports = {\r\n        mode: 'production',\r\n        entry: {\r\n          vendors: ['lodash'],\r\n          react: ['react', 'react-dom'],\r\n          jquery: ['jquery']\r\n        },\r\n        output: {\r\n          filename: '[name].dll.js',\r\n          path: path.resolve(__dirname, '../dll'),\r\n          // 以entry名稱作為庫做使用\r\n          library: '[name]'\r\n        },\r\n        plugins: [\r\n          // 使用插件將庫之間的映射關係保存到 [name].manifest.json 文件\r\n          new webpack.DllPlugin({\r\n            name: '[name]',\r\n            path: path.resolve(__dirname, '../dll/[name].manifest.json'),\r\n          })\r\n        ]\r\n      }\r\n      ```\r\n    - 2.在 ```package.json script``` 加入並執行 ```\"build:dll\": \"webpack --config ./build/webpack.dll.js\"```\r\n    - 3.安裝依賴：```npm install add-asset-html-webpack-plugin --save```\r\n    - 4.在主要 ```webpack``` 設定加入\r\n      ```js\r\n      const AddAssetHtmlWebpackPlugin = require('add-asset-html-webpack-plugin');\r\n\r\n      // 固定的plugin\r\n      const plugins = [\r\n        new HtmlWebpackPlugin({\r\n          template: 'src/index.html'\r\n        }), \r\n        new CleanWebpackPlugin(['dist'], {\r\n          root: path.resolve(__dirname, '../')\r\n        })\r\n      ];\r\n\r\n      // 項目可能會有多個第三方依賴需要分別配置\r\n      // 讀取dll資料夾下所有文件\r\n      const files = fs.readdirSync(path.resolve(__dirname, '../dll'));\r\n      files.forEach(file => {\r\n        if(/.*\\.dll.js/.test(file)) {\r\n          // 將打包好的第三方庫引入html\r\n          plugins.push(new AddAssetHtmlWebpackPlugin({\r\n            filepath: path.resolve(__dirname, '../dll', file)\r\n          }))\r\n        }\r\n        if(/.*\\.manifest.json/.test(file)) {\r\n          /*\r\n            在引入第三方庫時，webpack會先透過\r\n            vendors.manifest.json文件取得第三方庫引入\r\n\r\n            若第三方庫無分開打包，打包速度會較慢，\r\n            webpack 引入依賴庫時一律往 node__modules 尋找\r\n          */\r\n          plugins.push(new webpack.DllReferencePlugin({\r\n            manifest: path.resolve(__dirname, '../dll', file)\r\n          }))\r\n        }\r\n      })\r\n      module.exports = {\r\n        plugins,\r\n      }\r\n      ```\r\n\r\n<hr id=\"user-content-multiple-page\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >多頁面配置</a>\r\n- 安裝依賴：```npm i html-webpack-plugin -D```\r\n- 在主要 ```webpack``` 設定加入\r\n  - 多個頁面即對應多個 ```new HtmlWebpackPlugin```\r\n  ```js\r\n  const htmlMinifyOptions = {\r\n    // 删除 html 中的註釋\r\n    removeComments: true,\r\n    // 删除 html 中的空格\r\n    collapseWhitespace: true,\r\n    // 删除 html 標籤的雙引號\r\n    removeAttributeQuotes: true,\r\n    // 將 html 文件內的 css 壓縮\r\n    minifyCSS: true,\r\n    // 將 html 文件內的 js 壓縮\r\n    minifyJS: true\r\n  }\r\n  plugins: [\r\n    // 設定增加需要顯示的頁面\r\n    new HtmlWebpackPlugin({\r\n      // 原資料檔案\r\n      template: './src/index.html',\r\n      // 輸出檔案名\r\n      filename: 'index.html',\r\n      // 設定需要的資源(entry)\r\n      chunks: ['your.js'],\r\n      minify: htmlMinifyOptions\r\n    }),\r\n  ]\r\n  ```\r\n\r\n<hr id=\"user-content-link\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >參考連結</a>\r\n- [Webpack 官網](https://webpack.js.org/)\r\n- [Webpack 中文網](https://www.webpackjs.com/concepts/)\r\n",v=Object(t["w"])(!0),g=Object(t["w"])(!1),f=Object(t["w"])(!0),b=Object(t["w"])(!1),k=Object(t["w"])(""),y={name:"WebpackNote",components:{Loading:m["a"]},setup:function(){return Object(t["p"])(Object(a["a"])(regeneratorRuntime.mark((function n(){var r;return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:if(!v.value){n.next=7;break}return r=c()({html:!0,linkify:!0,typographer:!0,highlight:function(n,r){return u.a.highlight(n,{language:r}).value}}).use(p["a"]),k.value=r.render("".concat(h)),n.next=5,Object(s["c"])((function(){v.value=!1}),1e3).then((function(){return Object(s["c"])((function(){f.value=!1,b.value=!0}),500)})).then((function(){return Object(s["c"])((function(){g.value=!0,Object(s["a"])()}),100)}));case 5:n.next=8;break;case 7:Object(s["a"])();case 8:case"end":return n.stop()}}),n)})))),Object(i["a"])(),{showLoading:v,showContent:g,displayLoading:f,displayContent:b,htmlContent:k}}};e("e3cf");y.render=o;r["default"]=y},"9a51":function(n,r,e){"use strict";e.r(r);var t=e("7a23");function o(n,r,e,o,a,s){var i=Object(t["y"])("Loading");return Object(t["r"])(),Object(t["d"])(t["a"],null,[o.displayLoading?(Object(t["r"])(),Object(t["d"])(i,{key:0,class:{"content--hide":!o.showLoading,"content--show":o.showLoading}},null,8,["class"])):Object(t["e"])("",!0),o.displayContent?(Object(t["r"])(),Object(t["d"])("div",{key:1,class:{"markdown-content":!0,"content--hide":!o.showContent,"content--show":o.showContent}},[Object(t["h"])("div",{class:"markdown-body",innerHTML:o.htmlContent},null,8,["innerHTML"])],2)):Object(t["e"])("",!0)],64)}var a=e("1da1"),s=(e("96cf"),e("ed08")),i=e("df69"),l=e("d4cd"),c=e.n(l),p=e("2338"),d=e("1487"),u=e.n(d),m=e("3a5e"),h='## Vue.js 筆記\r\n<a id="user-content-top"></a>\r\n\r\n### 目錄\r\n<details>\r\n<summary style="cursor: pointer;">&nbsp;基本使用 </summary>\r\n\r\n- [基本介紹與安裝](#user-content-introduce)\r\n- [組件的基礎概念](#user-content-components-basic-concept)\r\n- [了解生命週期](#user-content-lifecycle)\r\n- [常用模板語法](#user-content-common-template-syntax)\r\n- [methods、computed、watcher](#user-content-methods-computed-watcher)\r\n- [CSS常用綁定方法](#user-content-css-bind)\r\n- [條件渲染](#user-content-if)\r\n- [循環渲染](#user-content-for)\r\n- [事件綁定](#user-content-event)\r\n- [表單雙向綁定](#user-content-form-bind)\r\n\r\n</details>\r\n<details>\r\n<summary style="cursor: pointer;">&nbsp;進階使用(一) </summary>\r\n\r\n- [局部與全局組件](#user-content-local-global-components)\r\n- [組件間傳值與效驗](#user-content-passbyvalue-validation)\r\n- [單向資料傳輸](#user-content-oneway-data-transfer)\r\n- [繼承屬性](#user-content-inherit-property)\r\n- [父子組件的事件通信](#user-content-father-son-event-communication)\r\n- [父子組件的雙向綁定](#user-content-father-son-twoway-binding)\r\n- [插槽、具名插槽、作用域插槽](#user-content-slot)\r\n- [動態與異步組件](#user-content-dynamic-asynchronous-components)\r\n- [ref與provide/inject](#user-content-ref-provide-inject)\r\n- [組件的過渡與動畫](#user-content-transition)\r\n\r\n</details>\r\n<details>\r\n<summary style="cursor: pointer;">&nbsp;進階使用(二) </summary>\r\n\r\n- [Mixin 使用](#user-content-mixin)\r\n- [Directive 自定義指令](#user-content-directive)\r\n- [Teleport 傳送門](#user-content-teleport)\r\n- [Plugin 插件](#user-content-plugin)\r\n- [Rules 校驗規則](#user-content-rules)\r\n- [Setup 函數](#user-content-setup)\r\n- [ref、reactive 使用](#user-content-ref-reactive)\r\n\r\n</details>\r\n\r\n<hr id="user-content-introduce" style="height: 4px;">\r\n\r\n#### <a href="#user-content-top" >基本介紹</a>\r\n- Vue 介紹：用於構建用戶界面的漸進式框架。被設計為可以自底向上逐層應用，其核心庫只關注視圖層\r\n- 安裝使用方式請查看[官網](https://v3.cn.vuejs.org/guide/installation.html#%E5%AE%89%E8%A3%85)\r\n\r\n<hr id="user-content-components-basic-concept" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >組件的基礎概念</a>\r\n```js\r\n/*\r\n  createApp 創建一個 Vue 應用並儲存到該變量\r\n  裡面參數表示該應用最外層的組件(createApp裡面的object)如何展示\r\n\r\n  MVVM 設計模式\r\n  M -> Model 資料(data())， V -> View 視圖(template)， VM -> ViewModel 視圖數據連接層(vm)\r\n*/\r\nconst app = Vue.createApp({\r\n  data() {\r\n    return {\r\n      message: \'hello world\'\r\n    }\r\n  },\r\n  template: "<div>{{message}}</div>"\r\n});\r\n// vm 代表的就是 Vue 應用的根組件\r\nconst vm = app.mount(\'#root\');\r\n// 可藉由vm直接修改data裡的屬性(vm會偵測到並修改畫面)\r\nvm.$data.message = "7777";\r\n```\r\n\r\n<hr id="user-content-lifecycle" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >了解生命週期</a>\r\n- 官網[生命週期圖](https://v3.cn.vuejs.org/images/lifecycle.svg)\r\n- 大致可分為三個階段\r\n  - 構建階段：```beforeCreate(創建前)、created(創建後)```\r\n  - 渲染更新階段：```beforeMount(渲染前)、mounted(渲染後)、beforeUpdate(更新前)、updated(更新後)```\r\n  - 卸載階段：```beforeUnmount(卸載前)、unmounted(卸載後)```\r\n- 重點事項\r\n  - 在拆除階段避免內存洩漏需在 ```beforeUnmount(卸載前)``` 內進行事件解綁或解除子組件互相溝通\r\n- 簡易範例\r\n  ```js\r\n  // 生命週期函數：在特定時刻會執行的函數\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return {\r\n        message: \'hello world\'\r\n      }\r\n    },\r\n    // 實例生成前自動執行\r\n    beforeCreate() {\r\n      console.log(\'beforeCreate\')\r\n    },\r\n    // 實例生成後自動執行\r\n    created() {\r\n      console.log(\'created\')\r\n    },\r\n    // 在组件内容被渲染到页面之前自动执行的函数\r\n    beforeMount() {\r\n      // 無任何內容\r\n      console.log(document.getElementById(\'root\').innerHTML, \'beforeMount\')\r\n    },\r\n    // 在组件内容被渲染到页面之后自动执行的函数\r\n    mounted() {\r\n      // 輸出渲染後的內容\r\n      console.log(document.getElementById(\'root\').innerHTML, \'mounted\')\r\n    },\r\n    // 當資料發生變化時立即自動執行的函數\r\n    beforeUpdate() {\r\n      // 會印出更新前裡面的內容\r\n      console.log(document.getElementById(\'root\').innerHTML, \'beforeUpdate\');\r\n    },\r\n    // 當料發生變化，頁面重新渲染後，自動執行的函數\r\n    updated() {\r\n      // 會印出更新後裡面的內容\r\n      console.log(document.getElementById(\'root\').innerHTML, \'updated\');\r\n    },\r\n    // 當 Vue 應用失效時，自動執行的函數\r\n    // 可以使用 app.unmount() 進行測試\r\n    beforeUnmount() {\r\n      // 會印出失效前裡面的內容\r\n      console.log(document.getElementById(\'root\').innerHTML, \'beforeUnmount\');\r\n    },\r\n    // 当 Vue 应用失效时，且 dom 完全销毁之后，自動執行的函數\r\n    unmounted() {\r\n      // 會印出 undefined\r\n      console.log(document.getElementById(\'root\').innerHTML, \'unmounted\');\r\n    },\r\n  });\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-common-template-syntax" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >常用模板語法</a>\r\n- ```{{}}```：插值表達式，如：```template: \'<div>{{content}}</div>\'```\r\n- ```v-html```：若字串包含html元素會解析為字符實體，需使用 ```v-html``` 進行解析\r\n  ```html\r\n  \x3c!-- html --\x3e\r\n  <div id="app">\r\n      <div>{{img}}</div>\r\n      <div v-html="img"></div>\r\n  </div>\r\n\r\n  \x3c!-- js --\x3e\r\n  <script>\r\n      new Vue({\r\n        el: "#app",\r\n        data: {\r\n          img: "<img src=\'https://yourimage.png\'>"\r\n        }\r\n      });\r\n  <\/script>\r\n  ```\r\n- ```v-bind```：將標籤內部屬性與data裡的屬性進行綁定，可簡寫成 ```:```，如：```:disabled="disabled"```\r\n- ```v-on```：為特定事件綁定，可簡寫成 ```@```，如：```@click="handleBtnClick"```\r\n- ```v-once```：只顯示第一次渲染的效果，不會再次渲染\r\n- ```v-if```：判斷該元件是否存在，如：```v-if="isShow"``` \r\n  - 若該元件常變動則建議使用 ```v-show```\r\n- 數據控制方法方式\r\n  ```js\r\n  /*\r\n    數據控制使用方法:\r\n    @[event]="handleClick"(使用v-on作範例)\r\n    :[name]="message"\r\n  */\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return {\r\n        message: "hello world",\r\n        show: false,\r\n        event: \'click\',\r\n        name: \'title\',\r\n      }\r\n    },\r\n    methods: {\r\n      handleClick() {\r\n        alert(\'click\')\r\n      }\r\n    },\r\n    template: `\r\n      <div @[event]="handleClick"></div>\r\n    `\r\n  });\r\n  ```\r\n\r\n<hr id="user-content-methods-computed-watcher" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">methods、computed、watcher</a>\r\n- ```methods```：一般函數，只需注意 ```this``` 指向\r\n  ```js\r\n  methods: {\r\n    formatString(string) {\r\n      return string.toUpperCase();\r\n    },\r\n    getTotal() {\r\n      // 這邊的this會指向vue實例，可直接取數據(this.message)\r\n      console.log(this) \r\n    },\r\n    // 箭頭函數\r\n    getOther:() => {\r\n      // 這邊的this會指向window\r\n      console.log(this)\r\n    },\r\n  },\r\n  // 可以直接在 {{}} 裡面使用方法\r\n  template: `\r\n    <div> {{formatString(message)}} </div>\r\n  `\r\n  ```\r\n- ```computed```：若一個數據依賴於其他數據，則設計為 ```computed```，並會進行緩存\r\n- ```watcher```：若需要在某個數據變化時做一些事情，則使用 ```watch``` 來觀察這個數據變化\r\n- 範例\r\n  ```js\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return {\r\n        message: "hello world",\r\n        count: 2,\r\n        price: 5,\r\n        newTotal: 10,\r\n        test: {aaa:\'111\'}\r\n      }\r\n    },\r\n    watch: {\r\n      // price 发生变化时，函数会执行\r\n      // 第一個參數是改變後的值,第二個是上一次未改變的值\r\n      price(current, prev) {\r\n        this.newTotal = current * this.count;\r\n      }\r\n    },\r\n    computed: {\r\n      // 当计算属性依赖的内容发生变更时，才会重新执行计算\r\n      total() {\r\n        console.log(Date.now())\r\n        return Date.now() + this.count;\r\n        // return this.count * this.price\r\n      }\r\n    },\r\n    methods: {\r\n      formatString(string) {\r\n        return string.toUpperCase();\r\n      },\r\n      // 只要页面重新渲染，才会重新计算\r\n      getTotal() {\r\n        return Date.now() + this.count;\r\n        // return this.count * this.price;\r\n      },\r\n    },\r\n    template: `\r\n     <div> {{message}} {{newTotal}} </div>\r\n     <div> {{getTotal()}} </div>\r\n    `\r\n  });\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-css-bind" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">CSS常用綁定方法</a>\r\n- 控制 ```class``` 有三種方法：字串、對象、數組\r\n  - ```true``` 代表增加，```false``` 則相反\r\n  - 設定好動畫效果後，使用該方式切換可用來操作動畫\r\n  - 範例\r\n    ```html\r\n    <style>\r\n      @keyframes leftToRight {\r\n        0% {\r\n          transform: translateX(-100px);\r\n        }\r\n        50% {\r\n          transform: translateX(-50px);\r\n        }\r\n        0% {\r\n          transform: translateX(0px);\r\n        }\r\n      }\r\n      .animation {\r\n        animation: leftToRight 3s;\r\n      } \r\n    </style>\r\n    <script>\r\n      // 透過 data 切換進行動畫 :class="animate" 會自動將 animation 加入或移除class\r\n      const app = Vue.createApp({\r\n        data() {\r\n          return {\r\n            animate: {\r\n              animation: true,\r\n            }\r\n          }\r\n        },\r\n        methods: {\r\n          handleClick() {\r\n            this.animate.animation = ! this.animate.animation;\r\n          }\r\n        },\r\n        template: `\r\n          <div>\r\n            <div :class="animate">hello world</div>\r\n            <button @click="handleClick">切换</button>\r\n          </div>\r\n        `\r\n      });\r\n\r\n      const vm = app.mount(\'#root\');\r\n    <\/script>\r\n    ```\r\n- 控制 ```style``` 有兩種方法：字串、對象\r\n  - 設定好 ```transition``` 並操作樣式屬性，就可以操作樣式動畫\r\n  - 範例\r\n    ```html\r\n    <style>\r\n      .transition {\r\n        transition: 3s background-color ease;\r\n      }\r\n    </style>\r\n    <script>\r\n      const app = Vue.createApp({\r\n        data() {\r\n          return {\r\n            styleObj: {\r\n              background: \'blue\'\r\n            }\r\n          }\r\n        },\r\n        methods: {\r\n          handleClick() {\r\n            if(this.styleObj.background === \'blue\') {\r\n              this.styleObj.background = \'green\';\r\n            }else {\r\n              this.styleObj.background = \'blue\'\r\n            }\r\n          }\r\n        },\r\n        // 將 transition 過度效果加入class 並透過data切換背景顏色\r\n        template: `\r\n          <div>\r\n            <div class="transition" :style="styleObj">hello world</div>\r\n            <button @click="handleClick">切换</button>\r\n          </div>\r\n        `\r\n      });\r\n      const vm = app.mount(\'#root\');\r\n    <\/script>\r\n    ```\r\n- 總結範例\r\n  ```html\r\n  <style>\r\n  .red {\r\n      color: red;\r\n  }\r\n  .green {\r\n      color: green;\r\n  }\r\n  </style>\r\n  <body>\r\n    <div id="root"></div>\r\n  </body>\r\n  <script>\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return {\r\n        classString: \'red\',\r\n        // :class="classObject" 會等於 class="green"\r\n        classObject: { red: false, green: true },\r\n        // :class="classArray" 會等於 class="red green brown"\r\n        classArray: [\'red\', \'green\', {brown: true}],\r\n        // 推薦用對象寫法比較簡潔 :style="styleObject"\r\n        styleString: \'color: yellow; background: orange\',\r\n        styleObject: {\r\n            color: \'orange\',\r\n            background: \'yellow\'\r\n        }\r\n      }\r\n    },\r\n    template: `\r\n      <div :class="classString">\r\n      Hello World\r\n      </div>\r\n      <div :style="styleObject">\r\n      Hello World\r\n      </div>\r\n      <demo class="green"/>\r\n    `\r\n  });\r\n\r\n  app.component(\'demo\', {\r\n    // :class="$attrs.class" 表示繼承父祖件的class屬性\r\n    // 若子組件只有一個標籤則會直接繼承,複數個不會繼承\r\n    template: `\r\n      <div :class="$attrs.class">one</div>\r\n      <div :class="$attrs.class">two</div>\r\n    `\r\n  })\r\n  const vm = app.mount(\'#root\');\r\n  <\/script>\r\n  ```\r\n\r\n<hr id="user-content-if" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">條件渲染</a>\r\n- ```v-if``` 會決定該標嵌是否存在，若裡面含子標籤則會一併存在或消失\r\n- ```v-if v-else-if v-else``` 標籤之間不能有其他標籤否則抱錯\r\n- ```v-show``` 會控制該標籤的樣式 ```display``` 進行隱藏(```none```)或顯示(會移除 ```display``` 屬性)\r\n```js\r\nconst app = Vue.createApp({\r\n  data() {\r\n    return {\r\n      show: true,\r\n      conditionOne: false,\r\n      conditionTwo: true\r\n    }\r\n  },\r\n\r\n  template: `\r\n    <div v-if="show">Hello World</div>\r\n\r\n    <div v-if="conditionOne">if</div>\r\n    <div v-else-if="conditionTwo">elseif</div>\r\n    <div v-else>else</div>\r\n\r\n    <div v-show="show">Bye World</div>\r\n  `\r\n});\r\n\r\nconst vm = app.mount(\'#root\');\r\n```\r\n\r\n<hr id="user-content-for" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">循環渲染</a>\r\n- ```v-for``` 可渲染數組與對象，並且更改後會自動渲染\r\n  - 在數組有兩個回傳值：```value、index```\r\n  - 在對象有三個回傳值：```value、key、index```\r\n  - 關於 ```:key="key"```\r\n    - ```key 需是唯一值``` 能更快速的復用元件達到更快渲染效果\r\n    - 請勿將 ```index``` 放入，因為數組 ```index``` 會重複使用\r\n    - ```v-if``` 不能與 ```v-for``` 共用，可以用 ```template``` 做循環，裡面用 ```v-if``` 判斷，並且 ```template``` 不會產生標籤 \r\n- 數組：可使用數組函數、直接替換數組、更新數組內容\r\n- 對象：可直接添加對象屬性\r\n```js\r\nconst app = Vue.createApp({\r\n  data() {\r\n    return {\r\n      listArray: [\'ming\', \'test\', \'myjob\'],\r\n      listObject: {\r\n        firstName: \'ming\',\r\n        lastName: \'test\',\r\n        job: \'myjob\'\r\n      }\r\n    }\r\n  },\r\n  methods: {\r\n    handleAddBtnClick() {\r\n      // 使用數組函數\r\n      this.listArray.pop();\r\n      // 直接替换数组\r\n      this.listArray = [\'1\', \'2\']\r\n      // 直接更新数组的内容\r\n      this.listArray[1] = \'hello\'\r\n      // 直接添加对象的内容，也可以自动的展示出来\r\n      this.listObject.age = 100;\r\n    }\r\n  },\r\n  template: `\r\n    <div>\r\n      <template v-for="(value, key, index) in listObject"\r\n        :key="index">\r\n        <div v-if="key !== \'lastName\'">\r\n          {{value}} -- {{key}}\r\n        </div>\r\n      </template>\r\n      <div v-for="item in 10">{{item}}</div>\r\n      <button @click="handleAddBtnClick">新增</button>\r\n    </div>\r\n    <div v-for="(value,key,index) in listObject" :key="key">{{value}}-{{key}}-{{index}}</div>\r\n    <div v-for="(value,index) in listArray">{{value}}-{{index}}</div>\r\n  `\r\n});\r\n\r\nconst vm = app.mount(\'#root\');\r\n```\r\n\r\n<hr id="user-content-event" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">事件綁定</a>\r\n- ```v-on``` 可以使方法與標籤進行綁定觸發事件\r\n- ```v-on``` 可以簡寫成 ```@```：```@click```\r\n- 常用修飾符有以下幾種 \r\n  - 事件修饰符：```stop、prevent、capture、self、once、passive```\r\n    - ```@click.stop``` 避免冒泡\r\n    - ```@click.self``` 只觸發自己(不含子組件)\r\n    - ```@click.prevent``` 防止預設觸發\r\n    - ```@click.capture``` 代表從冒泡轉換到捕獲  \r\n    - ```@click.once``` 只觸發一次\r\n    - ```@scroll.passive``` 可幫助滾動優化\r\n  - 按键修饰符：```enter、tab、delete、esc、up、down、left、right```\r\n    - 如：```@keydown.enter=""``` 則當按下 ```enter``` 時觸發\r\n  - 鼠标修饰符：```left、right、middle```\r\n    - 如：```@click.left=""``` 則當滑鼠按下左鍵時觸發\r\n  - 精确修饰符：```exact``` 避免同時有多個按鍵觸發\r\n    - 如：```@click.left.exact=""``` 當滑鼠"只有左鍵點擊"時觸發\r\n- 使用參數取得目標標籤\r\n  - 若無需另外傳參數，則方法內 ```event.target``` 參數為標籤自身\r\n  - 若需另外傳參數，則需傳 ```$event``` 才能獲取，如：\r\n    -  ```@click="handleBtnClick(2, $event)"```\r\n- 若需要一次觸發多個方法，則用逗號分隔並且加上括弧，如：\r\n  - ```@click="handleBtnClick(), handleBtnClick1()"```\r\n- 範例\r\n  ```js\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return {\r\n        counter: 0,\r\n      }\r\n    },\r\n    methods: {\r\n      handleClick() {\r\n        console.log(\'click\')\r\n      },\r\n      handleBtnClick(num, event) {\r\n        alert(111);\r\n        this.counter += num;\r\n      },\r\n    },\r\n    template: `\r\n      <div>\r\n        <div @click.ctrl.exact="handleClick">123</div>\r\n      </div>\r\n      <div>\r\n        {{counter}}\r\n        <button @click="handleBtnClick(2, $event)">123</div>\r\n      </div>\r\n      <div @click.self="handleBtnClick()">\r\n        000\r\n        <button>3</div>\r\n      </div>\r\n    `\r\n  });\r\n\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-form-bind" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">表單雙向綁定</a>\r\n- ```v-model``` 可以使資料與標籤進行雙向綁定\r\n- 常用修饰符有以下幾個：\r\n  - ```v-model.lazy``` 當該標籤失去焦點時才同步數據\r\n  - ```v-model.number```輸入數字後自動轉成數字再存到 ```data```(預設為字符串)\r\n  - ```v-model.trim``` 輸入字符串後自動將前後空格去除再存到 ```data```(輸入框內還是保有空格)\r\n- 表單內常用標籤：```input、textarea、checkbox、radio、select```\r\n  - 如果 ```input``` 已經用 ```v-model``` 則無需用 ```value``` 設值\r\n  - 如果 ```textarea``` 已經用 ```v-model``` 則會自動綁定\r\n- ```radio``` 用法 \r\n  ```js\r\n  /*\r\n    data 設置 check:\'\' (一般字符串即可,當然數組也可但不妥當)\r\n    <input type="radio" v-model="check" value="okok1"\r\n    <input type="radio" v-model="check" value="okok2"\r\n    則當被勾起時會自動新增到check:\'okok1\'\r\n  */\r\n  ```\r\n- ```checkbox``` 用法\r\n  - 第一種：\r\n    ```js\r\n    /*\r\n      在 data 設置 check:true 或 false\r\n      <input type="checkbox" v-model="check">\r\n      則當勾起時會自動切換true 或未勾起 false\r\n\r\n      也可以自訂勾起與未勾起狀態值\r\n    ` 在 data 設置 check:\'hello\' 或 \'world\'\r\n      <input type="checkbox" v-model="check" true-value="hello" false-value="world">\r\n      則當勾起時會自動切換 hello 或未勾起 world`\r\n    */\r\n    ```\r\n  - 第二種：\r\n    ```js\r\n    /*\r\n      在 data 設置 check:[]\r\n      <input type="checkbox" v-model="check" value="okok1"\r\n      <input type="checkbox" v-model="check" value="okok2"\r\n      則當被勾起時會自動新增到check數組:["okok1","okok2"]\r\n    */\r\n    ```\r\n- ```select``` 用法\r\n  - 單選：\r\n    ```js\r\n    /*\r\n      在 data 設置 ,message:\'A\' (設定一開始選擇A)\r\n      <select v-model="message">\r\n        <option value="A">A</option>\r\n        <option value="B">B</option>\r\n        <option value="C">C</option>\r\n      </select>\r\n      若選擇 A 則 this.message=\'A\'\r\n    */\r\n    ```\r\n  - 複選：\r\n    ```js\r\n    /*\r\n      在 data 設置 ,message:[]\r\n      <select v-model="message" multiple>\r\n        <option value="A">A</option>\r\n        <option value="B">B</option>\r\n        <option value="C">C</option>\r\n      </select>\r\n      若按住ctrl選擇 A 與 B 則 this.message=[\'A\',\'B\']\r\n    */\r\n    ```\r\n- 簡單範例\r\n  ```js\r\n  /*\r\n    另外 option 可以用 v-for 產生\r\n    在 data 設置 ,options:[{text:\'A\',value:\'A\'},{text:\'B\',value:\'B\'},{text:\'C\',value:\'C\'}]\r\n    <select v-model="message" multiple>\r\n      <option v-for="item in options" :value="item.value">{{item.text}}</option>\r\n    </select>\r\n  */\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return {\r\n        message: \'hello\',\r\n      }\r\n    },\r\n    template: `\r\n      <div>\r\n        {{message}}\r\n        <input v-model.trim="message"  />\r\n      </div>\r\n    `\r\n  });\r\n\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-local-global-components" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">局部與全局組件</a>\r\n- 組件：代表成品的一部份，且具備重複使用的特性\r\n- 全局組件：只要定義了，處處皆可使用\r\n  - 需使用 ``` app.component``` 方法創建\r\n  - 性能不高，但很方便\r\n  - 名字常用小寫字母中間用 ```-``` 隔開\r\n- 局部組件：定義後需要註冊才能使用\r\n  - 需放置在 ```components``` 對象內才能使用\r\n  - 性能較高\r\n  - 名字常用大寫字母開頭，駝峰式命名，避免混亂\r\n  - 使用時需用一名字做映射對象，並且底層也會自動嘗試做映射\r\n    - 如：```<hello-world /> 與 HelloWorld```\r\n- 範例\r\n  ```js\r\n  // 局部组件\r\n  const Counter = {\r\n    data() {\r\n      return {\r\n        count: 1\r\n      }\r\n    },\r\n    template: `<div @click="count += 1">{{count}}</div>`\r\n  }\r\n\r\n  const HelloWorld = {\r\n    template: `<div>hello world</div>`\r\n  }\r\n\r\n  const app = Vue.createApp({\r\n    components: {\r\n      // counter: Counter,\r\n      // \'hello-world\': HelloWorld,\r\n      Counter, HelloWorld,\r\n    },\r\n    template: `\r\n      <div>\r\n        <hello-world />\r\n        <counter />\r\n      </div>\r\n    `\r\n  });\r\n\r\n  // 全局组件\r\n  // app.component(\'counter\', {\r\n  //   data() {\r\n  //     return {\r\n  //       count: 1\r\n  //     }\r\n  //   },\r\n  //   template: `<div @click="count += 1">{{count}}</div>`\r\n  // })\r\n\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-passbyvalue-validation" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">組件間傳值與效驗</a>\r\n- 傳值方式(不限局部或全局組件)：\r\n  ```js\r\n  const app = Vue.createApp({\r\n    data() {\r\n      // 藉由 data 來傳值，並且可以是其他類型數據\r\n      return { num: 1234 }\r\n    },\r\n    // 設定取值參數名稱(若是靜態傳值則不用 v-bind)\r\n    template: `\r\n      <div><test :content="num" /></div>\r\n    `\r\n  });\r\n  app.component(\'test\', {\r\n    // 使用 props 取值\r\n    props:[\'content\'],\r\n    template: `<div>{{content}}</div>`\r\n  });\r\n  ```\r\n- 傳值輔助有以下幾種\r\n  - 檢查傳值是否符合這些數據類型：```String、Boolean、Array、Object、Function、Symbol```\r\n    - 範例：\r\n      ```js\r\n      app.component(\'test\', {\r\n        props:{\r\n          content: Boolean,\r\n        },\r\n        template: `<div>{{content}}</div>`\r\n      });\r\n      ```\r\n  - ```required``` 要求必填參數，範例：\r\n    ```js\r\n    app.component(\'test\', {\r\n      props:{\r\n        content: {\r\n          type: Number,\r\n          required: true, \r\n        },\r\n      },\r\n      template: `<div>{{content}}</div>`\r\n    });\r\n    ```\r\n  - ```validator```：設定檢驗的條件(不符合條件則提示錯誤)\r\n  - ```default```：默認值(可以用方法回傳，也可以直接給值)\r\n  - ```validator``` 與 ```default``` 使用範例：\r\n    ```js\r\n    app.component(\'test\', {\r\n      props:{\r\n        content: {\r\n          type: Number,\r\n          validator: function(value) {\r\n            return value < 1000;\r\n          },\r\n          default: function() {\r\n            return 456;\r\n          }, \r\n        },\r\n      },\r\n      template: `<div>{{content}}</div>`\r\n    });\r\n    ```\r\n- 總結使用範例\r\n  ```js\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return { num: 1234 }\r\n    },\r\n    template: `\r\n      <div><test :content="num" /></div>\r\n    `\r\n  });\r\n\r\n  app.component(\'test\', {\r\n    props: {\r\n      content: {\r\n        type: Number,\r\n        validator: function(value) {\r\n          return value < 1000;\r\n        },\r\n        default: function() {\r\n          return 456;\r\n        }\r\n      }\r\n    },\r\n    template: `<div>{{content}}</div>`\r\n  });\r\n\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-oneway-data-transfer" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">單向資料傳輸</a>\r\n- 單向資料傳輸定義：子組件可使用父組件傳遞的資料，但不能修改傳遞的資料\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return { num: 1 }\r\n      },\r\n      template: `\r\n        <div>\r\n          <counter :count="num" />\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      // props 由父組件傳的參數只能讀不能改\r\n      // 可以設在 data 其中一個屬性當作初始值\r\n      props: [\'count\'],\r\n      data() {\r\n        return {\r\n          myCount: this.count,\r\n        }\r\n      },\r\n      template: `<div @click="myCount += 1">{{myCount}}</div>`\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 資料傳輸常用命名方式\r\n  - 舉例：需要傳輸資料時，則使用 ```content-abc``` 該命名方式，使用傳輸資料時，使用 ```contentAbc``` 命名方式\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          params:{\r\n            content: 1234,\r\n          }\r\n        }\r\n      },\r\n      template: `\r\n        <div>\r\n          <test :content-abc="content" />\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'test\', {\r\n      props: [\'contentAbc\'],\r\n      template: `<div @click="count += 1">{{contentAbc}}</div>`\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 進階用法：使用對象與 ```v-bind``` 傳輸資料\r\n  - 範例\r\n    ```js\r\n    /*\r\n      v-bind="params" 等同於 \r\n      :content="params.content" \r\n      :a="params.a" \r\n      :b="params.b" \r\n      :c="params.c"\r\n    */\r\n\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          params:{\r\n            content: 1234,\r\n            a: 123,\r\n            b: 234,\r\n            c: 345,\r\n          }\r\n        }\r\n      },\r\n      template: `\r\n        <div>\r\n          <test v-bind="params"/>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'test\', {\r\n      // 依照對象屬性選擇要接收的資料\r\n      props: [\'content\',\'a\',\'b\',\'c\'],\r\n      data (){\r\n        return {\r\n          count: this.content\r\n        }\r\n      },\r\n      template: `<div @click="count += 1">{{count}}</div>`\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-inherit-property" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">繼承屬性</a>\r\n- 繼承屬性定義：子組件會繼承父組件給予子組件標籤上的屬性\r\n- 若子組件 ```props``` 內有設定該屬性，則無法繼承\r\n- 繼承方式\r\n  - 使用 ```$attrs``` 取得可以繼承的屬性\r\n  - 讓特定標籤繼承所有屬性：```v-bind="$attrs"```\r\n  - 讓特定標籤繼承單一屬性，如：```:yourProperty="$attrs.msg"```\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      template: `\r\n        <div>\r\n          <counter msg="hello" msg1="hello1" />\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      mounted() {\r\n        // 可以透過 this.$attrs 取得\r\n        console.log(this.$attrs.msg);// hello\r\n      },\r\n      /*\r\n        下面標籤輸出：\r\n        <div msg="hello">Counter</div>\r\n        <div msg="hello" msg1="hello1">Counter</div>\r\n        <div msg1="hello1">Counter</div>\r\n      */\r\n      template: `\r\n        <div :msg="$attrs.msg">Counter</div>\r\n        <div v-bind="$attrs">Counter</div>\r\n        <div :msg1="$attrs.msg1">Counter</div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- ```inheritAttrs```：\r\n  - 若該屬性設為 ```false``` 則子組件不會自動繼承屬性\r\n  - 若該屬性設為 ```true``` (可省略不寫該屬性)，則子組件會自動繼承屬性\r\n    - 若子組件內有多個標籤也不會自動繼承，只有單個標籤會自動繼承\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      template: `\r\n        <div>\r\n          <counter msg="hello" />\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      inheritAttrs: false,\r\n      // 若設為 false 則輸出 <div>Counter</div>\r\n      // 若設為 true 或不寫則輸出 <div msg="hello">Counter</div>\r\n      template: `\r\n        <div>Counter</div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-father-son-event-communication" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">父子組件的事件通信</a>\r\n- 設定方法：子組件設定 ```$emit``` 溝通媒介，讓父組件透過子組件觸發自己的方法來進行通信\r\n  - 因為 ```HTML``` 大小寫不敏感，建議用 ```-``` 區隔或全小寫(會自動轉小寫)\r\n  - 簡單範例：\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return { count: 1 }\r\n      },\r\n      methods: {\r\n        handleAddOne(){\r\n          this.count += 1;\r\n        },\r\n      },\r\n      // 藉由父組件設定子組件標籤方式，來觸發父組件方法\r\n      template: `\r\n        <counter :count="count" @add-one="handleAddOne" />\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      props: [\'count\'],\r\n      // 使用 this.$emit() 讓子組件與父組件透過事件交流\r\n      methods: {\r\n        handleClick() {\r\n          this.$emit(\'add-one\');\r\n        }\r\n      },\r\n      template: `\r\n        <div @click="handleClick">{{count}}</div>\r\n      `\r\n    });\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- ```$emit``` 參數\r\n  - 若單個參數，如：```this.$emit(\'add\')```，則只呼叫父組件方法且無任何參數填入\r\n  - 若多個參數，如：```this.$emit(\'add\', 2)```，則呼叫父組件方法且帶有參數```2```填入，依此類推\r\n  - 若含有 ```emits``` 屬性，則可檢查傳入的參數是否符合父組件要求\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return { count: 1 }\r\n      },\r\n      methods: {\r\n        handleAddOne(param1, param2){\r\n          this.count += param2;\r\n        },\r\n      },\r\n      template: `\r\n        <counter :count="count" @add="handleAddOne" />\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      props: [\'count\'],\r\n      // emits 主要是幫忙檢查有哪些會對外提供溝通\r\n      // emits 也可以是陣列: emits:[\'add\']\r\n      emits: {\r\n        // 也可以是對象並檢查該參數是否符合\r\n        add: (count) => {\r\n          if(count > 0){\r\n            // 若大於0則允許你對外\r\n            return true;\r\n          }\r\n          return false;\r\n        }\r\n      },\r\n      // 另外可以傳參數至父組件\r\n      methods: {\r\n        handleClick() {\r\n          // 也可以算好再傳送過去 this.$emit(\'add\', this.count + 3);\r\n          this.$emit(\'add\', 2);\r\n        },\r\n        // 若使用 emits:[\'add\']\r\n        add(count) {\r\n          if(count > 0){\r\n            // 若大於0則允許你對外\r\n            return true;\r\n          }\r\n          return false;\r\n        }\r\n      },\r\n      template: `\r\n        <div @click="handleClick">{{count}}</div>\r\n      `\r\n    });\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n\r\n<hr id="user-content-father-son-twoway-binding" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">父子組件的雙向綁定</a>\r\n- 使用方式：```v-model``` 讓父組件藉由子組件觸發更新父組件  ```data```\r\n  - 若有 ```多個 v-model 雙向綁定``` 則必須使用自定義別名，如：```v-model:app="count"```\r\n  - 範例\r\n    ```js\r\n    // 父子組件使用v-model雙向綁定\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return { count: 1 }\r\n      },\r\n      // 若要自定義則可以寫成(app可換其他命名) <counter v-model:app="count" />\r\n      template: `\r\n        <counter v-model="count" />\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      // 若父組件只用 v-model="" 則只能用 modelValue\r\n      // 若自定義(v-model:app="count")則寫成 props: [\'app\'],\r\n      props: [\'modelValue\'],\r\n      methods: {\r\n        handleClick() {\r\n          // 更新父組件的屬性\r\n          // 若自定義(v-model:app="count")則寫成 this.$emit(\'update:app\', this.app + 3);\r\n          this.$emit(\'update:modelValue\', this.modelValue + 3);\r\n        }\r\n      },\r\n      template: `\r\n        <div @click="handleClick">{{modelValue}}</div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 自定義修飾符\r\n  - 設定方式：```v-model.yourname```，可搭配自定義別名\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          str: \'a\',\r\n        }\r\n      },\r\n      // 若在父組件使用一個自定義修飾符 uppercase\r\n      // 加上自定義命名:v-model:app.uppercase="str"\r\n      template: `\r\n        <counter v-model.uppercase="str" />\r\n      `\r\n    });\r\n\r\n    app.component(\'counter\', {\r\n      props: {\r\n        \'modelValue\': String,\r\n        // 在 modelModifiers 可以看到父組件使用的自定義修飾符 { uppercase: true }\r\n        // 若命名:v-model:app.uppercase="str" 則須將 modelModifiers 改為 appModifiers\r\n        \'modelModifiers\': {\r\n          // 預設為空\r\n          default: ()=> ({})\r\n        }\r\n      },\r\n      methods: {\r\n        handleClick() {\r\n          let newValue = this.modelValue + \'b\';\r\n          // 如果父組件有使用 uppercase 修飾符則都轉大寫\r\n          // 若命名:v-model:app.uppercase="str" 則須改為 this.appModifiers.uppercase\r\n          if(this.modelModifiers.uppercase) {\r\n            newValue = newValue.toUpperCase();\r\n          }\r\n          // 若命名:v-model:app.uppercase="str" 則須改為 this.$emit(\'update:app\', newValue);\r\n          this.$emit(\'update:modelValue\', newValue);\r\n        },\r\n      },\r\n      // 若命名:v-model:app.uppercase="str" 則須改為 {{app}}\r\n      template: `\r\n        <div @click="handleClick">{{modelValue}}</div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-slot" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">插槽、具名插槽、作用域插槽</a>\r\n- ```slot``` (插槽)：會將父組件調用子組件裡的內容替換掉\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data(){\r\n        return { text: \'提交\' }\r\n      },\r\n      template: `\r\n        <myform>\r\n          <div>{{text}}</div>\r\n        </myform>\r\n        <myform>\r\n          <button>{{text}}</button>\r\n        </myform>\r\n      `\r\n    });\r\n\r\n    app.component(\'myform\', {\r\n      methods:{\r\n        handleClick(){\r\n          alert(123)\r\n        },\r\n      },\r\n      /*\r\n        <slot>default value</slot> 會依照 <myform> 裡面的內容進行更換\r\n        父組件第一個 <myform> slot 會換成 <div>提交</div>\r\n        父組件第二個 <myform> slot 會換成 <button>提交</button>\r\n\r\n        若父組件 <myform> 裡面內容為空，則 slot 會直接輸出 slot 標籤內文字\r\n        依 myform 子組件為例，slot 被 span 包覆，則會轉換成 <span>default value</span>\r\n      */\r\n      template: `\r\n        <div>\r\n          <span @click="handleClick">\r\n            <slot>default value</slot>\r\n          </span>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 具名插槽：當需要多個插槽時，可為插槽命名，藉此指定要輸出內容\r\n  - 具名與不具名插槽可一起使用，不具名插槽會取得除了具名插槽的內容\r\n  - 父組件設定方式：```v-slot:yourSlotName```，可以簡寫成 ```#yourSlotName```\r\n    - 需搭配 ```template``` 一起使用，如：```<template #yourSlotName>```\r\n    - ```template``` 本身不會產生任何標籤搭配 ```slot```，裡面就會變一個具名插槽\r\n  - 子組件設定方是：```<slot name="yourSlotName">123</slot>```\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      template: `\r\n        <layout>\r\n          <template v-slot:header>\r\n            <div>header</div>\r\n          </template>\r\n          <template v-slot:footer>\r\n            <div>footer</div>\r\n          </template>\r\n          <div>456</div>\r\n        </layout>\r\n      `\r\n    });\r\n    /*\r\n      以下內容會輸出：\r\n      <div>header</div>\r\n      <div>content</div>\r\n      <div>footer</div>\r\n      <div>footer</div>\r\n      <div>456</div>\r\n    */\r\n    app.component(\'layout\', {\r\n      template: `\r\n        <div>\r\n          <slot name="header"></slot>\r\n          <div>content</div>\r\n          <slot name="footer"></slot>\r\n          <slot name="footer"></slot>\r\n          <slot>123</slot>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 作用域插槽：\r\n  - 由子組件傳給父組件要顯示的內容\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      /*\r\n        子組件定義 item，讓父組件使用 v-slot 取得 item 值並輸出\r\n        依案例由子組件 item 依序傳入的值為：{"item":1}、{"item":2}、{"item":3}\r\n        1.可以用解構的方式取值：const { item } = items 則變成 v-slot="{item}" 搭配 <div>{{item}}</div>\r\n        2.直接取值：v-slot="itemObj" 搭配 {{itemObj.item}} 取得對象 item 屬性\r\n      */\r\n      template: `\r\n        <list v-slot="{item}">\r\n          <div>{{item}}</div>\r\n        </list>\r\n      `\r\n    });\r\n\r\n    app.component(\'list\', {\r\n      data() {return {list: [1, 2, 3]}},\r\n      /*\r\n        slot 裡面的 item 代表要輸出的內容\r\n        藉由 v-bind 綁定 item 進行輸出\r\n        <div>1</div>\r\n        <div>2</div>\r\n        <div>3</div>\r\n      */\r\n      template: `\r\n        <div>\r\n          <slot v-for="item in list" :item="item" />\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-dynamic-asynchronous-components" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">動態與異步組件</a>\r\n- 動態組件：根據資料變化，使用 ```component``` 標籤來切換要顯示的組件\r\n  - 將組件名稱填入 ```component``` 的 ```is``` 屬性，可顯示指定的組件(不限局部或全局組件)\r\n  - 使用 ```<keep-alive>``` 組件可保留切換前的狀態，如 ```input``` 的輸入框值\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data(){\r\n        return { currentItem: \'input-item\' }\r\n      },\r\n      methods: {\r\n        handleClick() {\r\n          if(this.currentItem === \'input-item\') {\r\n            this.currentItem = \'common-item\';\r\n          } else {\r\n            this.currentItem = \'input-item\';\r\n          }\r\n        }\r\n      },\r\n      // component 可以取代如這樣的組件 <input-item v-show="currentItem === \'input-item\'"/> \r\n      template: `\r\n        <keep-alive>\r\n          <component :is="currentItem"/>\r\n        </keep-alive>\r\n        <button @click="handleClick">切換</button>\r\n      `\r\n    });\r\n\r\n    app.component(\'input-item\', {\r\n      template: `<input />`\r\n    });\r\n\r\n    app.component(\'common-item\', {\r\n      template: `<div>hello world</div>`\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 異步組件：異步執行特定組件\r\n  - 使用 ```Vue.defineAsyncComponent``` 方法進行異步操作\r\n  - 範例：四秒後創建特定組件\r\n    ```js\r\n    const app = Vue.createApp({\r\n      template: `\r\n        <div>\r\n          <common-item />\r\n          <async-common-item />\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'common-item\', {\r\n      template: `<div>hello world</div>`\r\n    });\r\n\r\n    // 此案例為4秒鐘後創建該組件\r\n    app.component(\'async-common-item\', Vue.defineAsyncComponent(() => {\r\n      return new Promise((resolve, reject) => {\r\n        setTimeout(() => {\r\n          resolve({\r\n            template: `<div>this is an async component</div>`\r\n          })\r\n        }, 4000)\r\n      })\r\n    }))\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-ref-provide-inject" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">ref與provide/inject</a>\r\n- ```ref```：取得指定節點資訊\r\n  - 建議在 ```mounted``` 方法內使用(組件渲染完使用)\r\n  - 若在標籤加上則獲取該 ```DOM``` 節點\r\n  - 若在子組件加上則可取得 ```data``` 資訊或呼叫子組件方法\r\n- ```provide/inject```：使子孫組件可直接取得父輩以上資訊\r\n  - 可以避免父傳子再傳孫子的繁重寫法\r\n  - 若父輩以上含有多個 ```provide``` 且裡面有相同屬性，則會取較近的屬性值\r\n  - 子孫使用 ```inject``` 取得的父輩屬性無法修改，因為 ```provide``` 只會傳第一次，須重新賦值給自己的屬性\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return { count: 1, vvv: 234 }\r\n      },\r\n      // 傳送資訊給子孫組件\r\n      provide() {\r\n        return {\r\n          count: this.count,\r\n          vvv: this.vvv\r\n        }\r\n      },\r\n      template: `\r\n        <div>\r\n          <child :count="count" />\r\n          <button @click="count += 1">Add</button>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    app.component(\'child\', {\r\n      data() {\r\n        return { count: 777, bbb: 222}\r\n      },\r\n      // 傳送資訊給子孫組件\r\n      provide() {\r\n        return {\r\n          count: this.count,\r\n          bbb: this.bbb,\r\n        }\r\n      },\r\n      template: `<child-child/>`\r\n    });\r\n\r\n    app.component(\'child-child\', {\r\n      mounted(){\r\n        // ref用法：2.取得或使用子組件資訊\r\n        console.log(this.$refs.count.vvv) // 234 (取得子組件的 vvv 屬性值)\r\n        console.log(this.$refs.count.handleClick()) // 呼叫子組件的 handleClick 方法\r\n      },\r\n      // ref用法：1.設定要取得的子組件(標籤)\r\n      template: `<child-child-child ref="count" />`\r\n    });\r\n\r\n    app.component(\'child-child-child\', {\r\n       // 使用 inject 取得父輩組件的 data\r\n      inject: [\'count\',\'bbb\',\'vvv\'],\r\n      methods: {\r\n        handleClick(){\r\n          console.log(this.count) // 777 (取得較近父輩的 count 屬性值)\r\n          console.log(this.bbb) // 222\r\n          console.log(this.vvv) // 234\r\n        }\r\n      },\r\n      template: `<div @click="handleClick">{{bbb}}</div>`\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-transition" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">組件的過渡與動畫</a>\r\n- 若該組件需要過渡與動畫效果，可用以下組件含使用區別： \r\n  - ```transition(Transition)```：組件內只能有一個元素存在，在操作單一元素進入和離開時應用\r\n  - ```transition-group(TransitionGroup)```：組件內可以有多個元素存在，用於在列表中操作(增、刪...)時應用\r\n- 入場與出場：\r\n  - 入場與出場各有三階段\r\n  - 若 ```transition``` 組件的 ```name``` 為空，則 ```class``` 名為 ```v``` 開頭，如：```.v-xxxx-xxxx```\r\n  - 入場(```v``` 會隨著 ```transition``` 的 ```name``` 變更)\r\n    - v-enter-from：定義元素在入場「之前」的樣式\r\n    - v-enter-active：定義元素在入場「過程」的樣式\r\n    - v-enter-to：定義元素在入場「結束時」的樣式\r\n  - 出場(```v``` 會隨著 ```transition``` 的 ```name``` 變更)\r\n    - v-leave-from：定義元素在出場「之前」的樣式\r\n    - v-leave-active：定義元素在出場「過程」的樣式\r\n    - v-leave-to：定義元素在出場「結束時」的樣式\r\n  - 範例：\r\n    ```html\r\n    <style>\r\n    @keyframes shake {\r\n      0% {\r\n        transform: translateX(-100px)\r\n      }\r\n      50% {\r\n        transform: translateX(-50px)\r\n      }\r\n      100% {\r\n        transform: translateX(50px)\r\n      }\r\n    }\r\n    /*\r\n      transition name 為 hello，則 class 為 hello-xxx-xxx \r\n    */\r\n    .hello-leave-active {\r\n      animation: shake 3s;\r\n    }\r\n    .hello-enter-active {\r\n      animation: shake 3s;\r\n    }\r\n    </style>\r\n    <script>\r\n    // 单元素，单组件的入场出场动画\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          show: false\r\n        }\r\n      },\r\n      methods: {\r\n        handleClick() {\r\n          this.show = !this.show;\r\n        }\r\n      },\r\n      template: `\r\n        <div>\r\n          <transition name="hello">\r\n            <div v-if="show">hello world</div>\r\n          </transition>\r\n          <button @click="handleClick">切换</button>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    <\/script>\r\n    ```\r\n- 自定義 ```class```：\r\n  - 可以與 [Animate.css](https://animate.style/) 進行結合使用\r\n  - 有以下幾種設定方式，功能與上面入出場相同：\r\n    - enter-from-class\r\n    - enter-active-class\r\n    - enter-to-class\r\n    - leave-from-class\r\n    - leave-active-class\r\n    - leave-to-class\r\n  - 若有同時使用 ```transition``` 與 ```animation``` 情況\r\n    - 若設定 ```type="transition"```，則設定的秒數後強制完成 ```animation``` 動畫\r\n    - 若設定 ```type="animation"```，則設定的秒數後強制完成 ```transition``` 過渡\r\n  - ```duration```\r\n    - 若設定 ```:duration="1000"```，則一秒後後強制完成過渡動畫\r\n    - 若 ```:duration="{enter: 1000, leave: 3000}"```，則入場一秒後強制結束過渡動畫，出場三秒後強制結束過渡動畫\r\n  - 範例\r\n    ```js\r\n    /*\r\n      1.先自定義的名稱寫css\r\n        .hello { 代表入場的動作 } .bye { 代表出場的動作 }\r\n      2.在 transition 組件上設定如：enter-active-class="hello" 即可生效\r\n        並且可同時用多個 class，如：enter-active-class="yourFirstClass yourSecondClass"\r\n    */\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          show: false\r\n        }\r\n      },\r\n      methods: {\r\n        handleClick() {\r\n          this.show = !this.show;\r\n        },\r\n      },\r\n      template: `\r\n        <div>\r\n          <transition\r\n            enter-active-class="hello"\r\n            leave-active-class="bye"\r\n          >\r\n            <div v-show="show">hello world</div>\r\n          </transition>\r\n          <button @click="handleClick">切换</button>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- ```JavaScript Hooks```：\r\n  - [官網介紹](https://vuejs.org/guide/built-ins/transition.html#javascript-hooks)\r\n  - 可以偵聽 ```Transition``` 組件上動畫轉換過程\r\n  - 若設定 ```:css="false"``` 則代表不用 ```css``` 動畫與過渡效果\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          show: false\r\n        }\r\n      },\r\n      methods: {\r\n        handleClick() {\r\n          this.show = !this.show;\r\n        },\r\n        handleBeforeEnter(el) {\r\n          // el 可以取得 transition 內的節點/組件資訊\r\n          el.style.color = "red";\r\n        },\r\n        handleEnterActive(el, done) {\r\n          const animation = setInterval(() => {\r\n            const color = el.style.color;\r\n            if(color === \'red\') {\r\n              el.style.color = \'green\';\r\n            } else {\r\n              el.style.color = \'red\';\r\n            }\r\n          }, 1000)\r\n          setTimeout(() => {\r\n            clearInterval(animation);\r\n            done();\r\n          }, 3000)\r\n        },\r\n        handleEnterEnd(el) {\r\n          console.log(123);\r\n        }\r\n      },\r\n      /*\r\n        @before-enter 代表入場執行，有 el 參數(transition本體)\r\n        @enter 代表入場中執行，有 el 參數(transition本體)與 done參數(要結束動畫時需呼叫:done())\r\n        @after-enter 代表入場完，有 el 參數(transition本體)\r\n        其他可詳細看官網\r\n      */\r\n      template: `\r\n        <div>\r\n          <transition\r\n            :css="false"\r\n            @before-enter="handleBeforeEnter"\r\n            @enter="handleEnterActive"\r\n            @after-enter="handleEnterEnd"\r\n          >\r\n            <div v-show="show">hello world</div>\r\n          </transition>\r\n          <button @click="handleClick">切换</button>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- ```transition``` 組件動畫切換元素/組件，```transition-group``` 官方不支持使用：\r\n  - 若要達到先入場再出場動畫效果則加入 ```mode="in-out"```，沒有加則預設同時\r\n  - 若要達到先出場再入場動畫效果則加入 ```mode="out-in"```，沒有加則預設同時\r\n  - ```appear``` 表示當渲染完時，進行入場動畫\r\n  - 範例\r\n    ```js\r\n    // 利用 component 組件來切換兩個自定義組件\r\n    const ComponentA = {\r\n      template: \'<div>hello world</div>\'\r\n    }\r\n\r\n    const ComponentB = {\r\n      template: \'<div>bye world</div>\'\r\n    }\r\n\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return { component: \'component-a\' }\r\n      },\r\n      methods: {\r\n        handleClick() {\r\n          if(this.component === \'component-a\') {\r\n            this.component = \'component-b\';\r\n          }else {\r\n            this.component = \'component-a\';\r\n          }\r\n        },\r\n      },\r\n      components: {\r\n        \'component-a\': ComponentA,\r\n        \'component-b\': ComponentB,\r\n      },\r\n      template: `\r\n        <div>\r\n          <transition mode="out-in" appear>\r\n            <component :is="component" />\r\n          </transition>\r\n          <button @click="handleClick">切换</button>\r\n        </div>\r\n      `\r\n    });\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n- 使用 ```transition-group``` 製作列表動畫\r\n  - 注意：內部的元素需具有唯一的 ```key``` 值(若沒有則動畫失效)\r\n  - 範例\r\n    ```html\r\n    <style>\r\n      .v-enter-from {\r\n        opacity: 0;\r\n        transform: translateY(30px);\r\n      }\r\n      .v-enter-active {\r\n        transition: all .5s ease-in;\r\n      }\r\n      .v-enter-to {\r\n        opacity: 1;\r\n        transform: translateY(0);\r\n      }\r\n      .v-move {\r\n        transition: all .5s ease-in;\r\n      }\r\n      .list-item {\r\n        display: inline-block;\r\n        margin-right: 10px;\r\n      }\r\n    </style>\r\n    <script>\r\n      const app = Vue.createApp({\r\n        data() {\r\n          return { list: [1, 2, 3] }\r\n        },\r\n        methods: {\r\n          handleClick() {\r\n            this.list.unshift(this.list.length + 1);\r\n          },\r\n        },\r\n        template: `\r\n          <div>\r\n            <transition-group>\r\n              <span class="list-item" v-for="item in list" :key="item">{{item}}</span>\r\n            </transition-group>\r\n            <button @click="handleClick">增加</button>\r\n          </div>\r\n        `\r\n      });\r\n      const vm = app.mount(\'#root\');\r\n    <\/script>\r\n    ```\r\n\r\n<hr id="user-content-mixin" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">Mixin 使用</a>\r\n- 主要將一些常用的方法、屬性、生命週期函數...抽離出來重複使用\r\n- 組件的內容屬性與方法優先於 ```Mixin``` 的內容\r\n- 局部 ```Mixin``` 透過 ```mixins: [yourMixin]``` 加入\r\n- 全局 ```Mixin``` 透過 ```app.mixin()``` 方法加入( ```app``` 為 ```Vue``` 實體)\r\n  - 將自動將 ```Mixin``` 內容自動註冊到每個組件\r\n- 父子組件與 ```Mixin``` 的生命週期：\r\n  - 1.```Mixin``` 的 ```beforeCreate```\r\n  - 2.【父組件】的 ```beforeCreate```\r\n  - 3.```Mixin``` 的 ```created ```\r\n  - 4.【父組件】的 ```created```\r\n  - 5.```Mixin``` 的 ```beforeMount```\r\n  - 6.【父組件】的 ```beforeMount```\r\n  - 7.【子組件】的 ```beforeCreate```\r\n  - 8.【子組件】的 ```created```\r\n  - 9.【子組件】的 ```beforeMount```\r\n  - 10.【子組件】的 ```mounted```\r\n  - 11.```Mixin```  的 ```mounted```\r\n  - 12.【父組件】的 ```mounted```\r\n- 範例：此範例含修改 ```Mixin``` 與組件的優先選擇權\r\n  ```js\r\n  /*\r\n    // 局部 Mixin，透過 mixins: [myMixin] 加入\r\n    const myMixin = {\r\n      data(){\r\n        return {\r\n          number: 2,\r\n          count: 222\r\n        }\r\n      },\r\n      created(){},\r\n      methods: {}\r\n    }\r\n\r\n    // 全局 Mixin 透過 app.mixin() 加入\r\n    app.mixin({\r\n      data(){\r\n        return {\r\n          number: 2,\r\n          count: 222\r\n        }\r\n      },\r\n      created(){},\r\n      methods: {}\r\n    })\r\n  */\r\n  const myMixin = {\r\n    number: 1\r\n  }\r\n  const app = Vue.createApp({\r\n    mixins: [myMixin],\r\n    // 裡面的自定義屬性可以用 this.$options 來取得\r\n    number: 2,\r\n    template: `\r\n      <div>\r\n        <div>{{this.$options.number}}</div>\r\n      </div>\r\n    `\r\n  });\r\n  // 通過此方式可修改 mixin 與 組件 的優先選擇權\r\n  app.config.optionMergeStrategies.number = (mixinVal, appValue) => {\r\n    // 若 mixin 存在則優先選擇 mixin\r\n    return mixinVal || appValue;\r\n  }\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-directive" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">Directive 自定義指令</a>\r\n- 更方便對特定組件/標籤取得資訊\r\n- 可用來解決 ```ref``` 覆用問題\r\n- 局部 ```directives``` 透過 ```directives: yourDirectives,``` 加入\r\n- 全局 ```directives``` 透過 ```app.directive``` 方法加入( ```app``` 為 ```Vue``` 實體)\r\n- 與組件一樣擁有生命週期(局部與全局都有)\r\n- 局部與全局 ```directives``` 使用範例\r\n  ```js\r\n  // 局部指令：取名為 focus 並將 v-focus 掛載到標籤上\r\n  const directives = {\r\n    focus: {\r\n      // 在該組件渲染完成時聚焦\r\n      mounted(el) {\r\n        el.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  // 使用 directives 掛載到組件上\r\n  const app = Vue.createApp({\r\n    directives: directives,\r\n    template: `\r\n      <div>\r\n        <input v-focus />\r\n      </div>\r\n    `\r\n  });\r\n\r\n  // 全局指令:自動掛載進去可以直接使用\r\n  app.directive(\'focus\', {\r\n    beforeMount(el){},\r\n    mounted(el){},\r\n    beforeUpdate(el){},\r\n    updated(el){},\r\n    beforeUnmount(el){},\r\n    unmounted(el){},\r\n  })\r\n\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n- 使用 ```binding``` 參數可接收到組件標籤的資料\r\n  - ```binding.arg``` 可接收到 ```v-param1:param2="param3"``` 的 ```param2``` 字串\r\n  - ```binding.value``` 可接收到 ```v-param1:param2="param3"``` 的 ```param3``` 傳值\r\n  - 範例\r\n    ```js\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          distance: 110\r\n        }\r\n      },\r\n      template: `\r\n        <div>\r\n          <div v-pos:right="distance" class="header">\r\n            <input />\r\n          </div>\r\n        </div>\r\n      `\r\n    });\r\n    app.directive(\'pos\', {\r\n      mounted(el, binding){\r\n        console.log(binding.arg) // right\r\n        console.log(binding.value) // 110\r\n        // 這段代表右移動110px\r\n        el.style[binding.arg] = (binding.value + \'px\');\r\n      },\r\n      updated(el, binding){\r\n        el.style[binding.arg] = (binding.value + \'px\');\r\n      }\r\n    })\r\n    /*\r\n      // 當只有 mounted 與 updated 時，可簡寫成下面寫法\r\n      app.directive(\'pos\', (el, binding) => {\r\n        el.style[binding.arg] = (binding.value + \'px\');\r\n      })\r\n    */\r\n    const vm = app.mount(\'#root\');\r\n    ```\r\n\r\n<hr id="user-content-teleport" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">Teleport 傳送門</a>\r\n- 使用 ```teleport``` 組件可以將裡面的內容掛載到 ```to``` 裡面指定的標籤內\r\n- ```to``` 可以放入三種選擇標籤方式：\r\n  - ```id```：```#yourTag```\r\n  - ```class```：```.yourTag```\r\n  - ```標籤```：```yourTag```\r\n- 無論用哪種放入方式，```Teleport``` 裡面內容都只會選擇第一個標籤放入\r\n- 若有多個 ```Teleport``` 都選擇同一個標籤，則標籤內會按順序加入所有 ```Teleport```內容\r\n- 常用在提示消息、載入中等常用覆蓋頁面功能\r\n- 範例\r\n  ```html\r\n  <style>\r\n    .area {\r\n      position: absolute;\r\n      left: 50%;\r\n      top: 50%;\r\n      transform: translate(-50%, -50%);\r\n      width: 200px;\r\n      height: 300px;\r\n      background: green;\r\n    }\r\n    .mask {\r\n      position: absolute;\r\n      left: 0;\r\n      right: 0;\r\n      top: 0;\r\n      bottom: 0;\r\n      background: #000;\r\n      opacity: 0.5;\r\n      color: #fff;\r\n      font-size: 100px;\r\n    }\r\n  </style>\r\n  <body>\r\n    <div id="root"></div>\r\n    <div id="hello"></div>\r\n  </body>\r\n  <script>\r\n    const app = Vue.createApp({\r\n      data() {\r\n        return {\r\n          show: false,\r\n          message: \'hello\'\r\n        }\r\n      },\r\n      methods: {\r\n        handleBtnClick() {\r\n          this.show = !this.show;\r\n        }\r\n      },\r\n      template: `\r\n        <div class="area">\r\n          <button @click="handleBtnClick">按钮</button>\r\n          <teleport to="#hello">\r\n            <div class="mask" v-show="show">{{message}}</div>\r\n          </teleport>\r\n        </div>\r\n      `\r\n    });\r\n\r\n    const vm = app.mount(\'#root\');\r\n  <\/script>\r\n  ```\r\n\r\n<hr id="user-content-plugin" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">Plugin 插件</a>\r\n- [官網介紹](https://v3.cn.vuejs.org/guide/plugins.html#%E6%8F%92%E4%BB%B6)\r\n- 用途：將通用性的功能封裝起來\r\n- 製作插件時需要對外暴露 ```install``` 方法\r\n- 以下為簡單定義與使用範例\r\n  ```js\r\n  const myPlugin = {\r\n    install(app, options) {\r\n      // 若使用場景為  app.use(myPlugin, { name: \'ming\'});\r\n      console.log(app) // 由 Vue 的 createApp 生成的 app 對象\r\n      console.log(options) // { name: \'ming\'}\r\n      // 提供給子孫組件屬性\r\n      app.provide(\'name\', \'ming\');\r\n      // 自定義指令(v-focus)\r\n      app.directive(\'focus\', {\r\n        mounted(el) {\r\n          el.focus();\r\n        }\r\n      })\r\n      // 抽離共用方法\r\n      app.mixin({\r\n        mounted(){\r\n          console.log(\'mixin\')\r\n        }\r\n      })\r\n      // 添加全局實例方法或屬性\r\n      app.config.globalProperties.$sayHello = \'hello world\';\r\n    }\r\n  }\r\n\r\n  const app = Vue.createApp({\r\n    template: `\r\n      <my-title />\r\n    `\r\n  });\r\n\r\n  app.component(\'my-title\', {\r\n    // 取得 plugin 內提供的 name 屬性\r\n    inject: [\'name\'],\r\n    mounted() {\r\n      console.log(this.$sayHello); // hello world\r\n    },\r\n    template: `<div>{{name}}<input v-focus /></div>`\r\n  })\r\n  // 使用自製 plugin\r\n  app.use(myPlugin, { name: \'ming\'});\r\n\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-rules" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">Rules 校驗規則</a>\r\n- 可針對 ```data``` 裡面屬性校驗是否符合規則\r\n- 範例\r\n  ```js\r\n  const app = Vue.createApp({\r\n    data() {\r\n      return { name: \'ming\', age: 12}\r\n    },\r\n    methods:{\r\n      addAge(){\r\n        this.age++\r\n      }\r\n    },\r\n    // 定義針對data裡的屬性校驗的規則\r\n    rules: {\r\n      age: {\r\n        // validate 只有在 false 時才會列印 message\r\n        validate: age => age > 18,\r\n        message: \'too young\'\r\n      },\r\n      name: {\r\n        validate: name => name.length >= 4,\r\n        message: \'name too short\'\r\n      }\r\n    },\r\n    template: `\r\n      <div @click="addAge">name:{{name}}, age:{{age}}</div>\r\n    `\r\n  });\r\n\r\n  // 使用 Plugin 對 mixin 做一個封裝\r\n  const validatorPlugin = (app, options) => {\r\n    console.log(options) // undefined，因沒有傳第二個參數\r\n    app.mixin({\r\n      created() {\r\n        console.log(this.$options.rules) // 會印出 rules 規則\r\n        for(let key in this.$options.rules) {\r\n          const item = this.$options.rules[key];\r\n          // 監聽 data 裡的屬性值，若屬性值(key)改變則自動校驗\r\n          this.$watch(key, (value) => {\r\n            const result = item.validate(value);\r\n            // 若result 為 false 則輸出 message\r\n            if(!result) console.log(item.message);\r\n          })\r\n        }\r\n      }\r\n    })\r\n  }\r\n\r\n  app.use(validatorPlugin);\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-setup" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">Setup 函數</a>\r\n- 使用目的：\r\n  ```txt\r\n  過去的寫法 Options API 需將功能的屬性、方法...\r\n  分別寫在如：data、methods...等程式區塊\r\n  若專案狀大將會造成程式的碎片化難以閱讀與理解\r\n\r\n  Vue3 推出 Composition API 後，就無須再分開寫在特定的區塊內\r\n  所有內容寫在setup()內，也就可用"功能"來區分寫的區塊，\r\n  ```\r\n- 將在初始化 ```beforeCreate``` 之前實例化\r\n- 使用參數\r\n  - ```props``` 為響應式的，當傳入新屬性時，將被更新\r\n  - ```context``` 是一個普通 ```JS``` 對象，可使用在 setup 中有用的屬性\r\n- 簡單範例\r\n  ```js\r\n  const app = Vue.createApp({\r\n    template: `\r\n      <div @click="handleClick">{{name}}</div>\r\n    `,\r\n    methods: {\r\n      test() {\r\n        console.log(this.$options.setup());\r\n      }\r\n    },\r\n    mounted() {\r\n      // 在其他方法可以呼叫setup\r\n      this.test();\r\n    },\r\n    // 尚未初始化前created 实例被完全初始化之前\r\n    setup(props, context) {\r\n      // 因還未有實例所以 this 不存在(無法呼叫其他方法)\r\n      return {\r\n        name: \'ming\',\r\n        handleClick: () => {\r\n          console.log(this) // window\r\n        }\r\n      }\r\n    }\r\n  });\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n\r\n<hr id="user-content-ref-reactive" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top">ref、reactive 使用</a>\r\n- ```ref```、```reactive``` 為響應式的引用，使 ```setup``` 可以雙向綁定\r\n- 原理：通過 ```proxy``` 對資料進行封裝，資料變化時將觸發模板內容更新\r\n- ```ref```：處理基本類型的資料，如：```String```，不適合用數組、對象類型\r\n- ```reactive```：處理非基本類型的資料，如：數組、對象類型\r\n- ```toRefs```：將響應式物件中的每一個屬性，個別封裝成 ```ref``` 物件\r\n  - 若直接拆解，因為是未封裝的資料，所以不會響應\r\n- ```readonly```：設定該響應式物件無法被修改\r\n- 範例\r\n  ```js\r\n  const app = Vue.createApp({\r\n    // Vue 會自動將被封裝的數據會調用 .value 取值\r\n    template: `\r\n      <div>{{name}}</div>\r\n    `,\r\n    mounted() {\r\n      setTimeout(() => {\r\n        // 5秒後無法修改 name，因為已設定 readonly\r\n        this.name = \'test\';\r\n        console.log(this.name);\r\n      }, 5000)\r\n    },\r\n    setup(props, context) {\r\n      /*\r\n        // ref 用法\r\n        const { ref } = Vue; // 取得 ref \r\n        // ref 將 \'ming\' 轉換成 proxy({value: \'ming\'}) 一個基本類型的響應式應用\r\n        let name = ref(\'ming\');\r\n        setTimeout(() => {\r\n        因為被封裝所以用 name.value 改變裡面的值\r\n          name.value = \'test\'\r\n        }, 2000)\r\n\r\n        return { name }\r\n      */\r\n      \r\n      const { reactive, readonly, toRefs } = Vue;\r\n      // reactive 將 { name: \'ming\'} 变成 proxy({ name: \'ming\'}) 一個響應式應用\r\n      const nameObj = reactive({ name: \'ming\', age: 18 });\r\n      // 設定該資料無法被修改\r\n      const copyNameObj = readonly(nameObj);\r\n      setTimeout(() => {\r\n        nameObj.name = \'test\';\r\n      }, 2000) \r\n      /*\r\n        toRefs 將 reactive 數據： proxy({ name: \'dell\', age: 28})\r\n        轉化成：{ name: proxy({ value: \'dell\'}), age: proxy({value: 28}) }\r\n        使裡面的 value 可以進行綁定，若不使用則更改資料時模板內容不會響應\r\n      */\r\n      // 因解構出來的會是未封裝的數據，需要用 toRefs 進行重新封裝數據才能進行響應\r\n      // 若輸出的是 readonly 封裝後的數據則之後無法進行修改\r\n      const { name, age } = toRefs(copyNameObj);\r\n      return { name }\r\n    }\r\n  });\r\n  const vm = app.mount(\'#root\');\r\n  ```\r\n',v=Object(t["w"])(!0),g=Object(t["w"])(!1),f=Object(t["w"])(!0),b=Object(t["w"])(!1),k=Object(t["w"])(""),y={name:"VueNote",components:{Loading:m["a"]},setup:function(){return Object(t["p"])(Object(a["a"])(regeneratorRuntime.mark((function n(){var r;return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:if(!v.value){n.next=7;break}return r=c()({html:!0,linkify:!0,typographer:!0,highlight:function(n,r){return u.a.highlight(n,{language:r}).value}}).use(p["a"]),k.value=r.render("".concat(h)),n.next=5,Object(s["c"])((function(){v.value=!1}),1e3).then((function(){return Object(s["c"])((function(){f.value=!1,b.value=!0}),500)})).then((function(){return Object(s["c"])((function(){g.value=!0,Object(s["a"])()}),100)}));case 5:n.next=8;break;case 7:Object(s["a"])();case 8:case"end":return n.stop()}}),n)})))),Object(i["a"])(),{showLoading:v,showContent:g,displayLoading:f,displayContent:b,htmlContent:k}}};e("e1ce");y.render=o;r["default"]=y},e1ce:function(n,r,e){"use strict";e("46d1")},e3cf:function(n,r,e){"use strict";e("58b8")}}]);
//# sourceMappingURL=webpackNote.42c26c6f.js.map