(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["gitNote"],{"470d":function(r,n,t){"use strict";t.r(n);var e=t("7a23");function i(r,n,t,i,o,a){var s=Object(e["y"])("Loading");return Object(e["r"])(),Object(e["d"])(e["a"],null,[i.displayLoading?(Object(e["r"])(),Object(e["d"])(s,{key:0,class:{"content--hide":!i.showLoading,"content--show":i.showLoading}},null,8,["class"])):Object(e["e"])("",!0),i.displayContent?(Object(e["r"])(),Object(e["d"])("div",{key:1,class:{"markdown-content":!0,"content--hide":!i.showContent,"content--show":i.showContent}},[Object(e["h"])("div",{class:"markdown-body",innerHTML:i.htmlContent},null,8,["innerHTML"])],2)):Object(e["e"])("",!0)],64)}var o=t("1da1"),a=(t("96cf"),t("ed08")),s=t("df69"),g=t("d4cd"),c=t.n(g),u=t("1487"),h=t.n(u),l=t("3a5e"),d='## git 使用指令\r\n<a id="user-content-top"></a>\r\n\r\n### 目錄\r\n<details open>\r\n<summary style="cursor: pointer;">&nbsp;目錄清單 </summary>\r\n\r\n- [安裝與介紹](#user-content-install-introduce)\r\n- [常用工作流](#user-content-workflow)\r\n  - [Git flow](#user-content-workflow-git-flow)\r\n  - [Github flow](#user-content-workflow-github-flow)\r\n  - [Gitlab flow](#user-content-workflow-gitlab-flow)\r\n- [使用者設定](#user-content-user-settings)\r\n- [開始專案](#user-content-start)\r\n- [上傳常用指令](#user-content-update)\r\n- [合併分支(含遠端)](#user-content-merge)\r\n- [gitignore](#user-content-gitignore)\r\n- [git branch 常用指令](#user-content-branch)\r\n- [git remote 常用指令](#user-content-remote)\r\n- [git tag (git 標籤)](#user-content-tag)\r\n- [git stash (git 暫存)](#user-content-stash)\r\n- [其他使用指令](#user-content-other)\r\n\r\n</details>\r\n\r\n<hr id="user-content-install-introduce" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >安裝與介紹</a>\r\n- [安裝 git](https://git-scm.com/downloads)\r\n- 什麼是 ```git``` ?\r\n  ```txt\r\n  git 為分散式版本管理系統\r\n  當初作者為了更好管理 linux 內核而開發的\r\n  git 會將檔案歷史保存下來，藉此可還原檔案過去的狀態，也可顯示其版本差異\r\n\r\n  注：甚麼是分散式版本管理系統?\r\n    又稱去中心化版本控制，是一種版本控制的方式，\r\n    它允許軟體開發者可以共同參與一個軟體開發專案，但是不必在相同的網路系統下工作。\r\n    其作法是在每個開發者電腦中複製一份完整的代碼庫以及完整歷史。\r\n  ```\r\n\r\n<hr id="user-content-workflow" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >常用工作流</a>\r\n- 常用工作流有以下三種，後面會逐一介紹\r\n  - ```Git flow```\r\n  - ```Github flow```\r\n  - ```Gitlab flow```\r\n- 關於 ```git merge --no-ff``` 參數指令\r\n  ```txt\r\n  通常 master 與 develop 分支在合併時，\r\n  master 節點會直接指向 develop 節點\r\n\r\n  若用 --no-ff 此參數指令\r\n  便會在 master 上建立新節點\r\n  並會由 develop 節點指向 master 新節點\r\n  以此來保證歷史版本的清晰\r\n  ```\r\n- 參考[連結](https://medium.com/@lf2lf2111/%E4%B8%89%E7%A8%AE%E7%89%88%E6%8E%A7%E6%B5%81%E7%A8%8B-29c82f5d4469)\r\n\r\n<hr id="user-content-workflow-git-flow" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >Git flow</a>\r\n- ```Git flow``` 是最早與最廣泛使用的工作流，使用方式如下：\r\n- 特點為有兩個長期分支：\r\n  - 主分支 ```master```：存放對外發布的穩定版本\r\n  - 開發分支 ```develop```：存放最新開發的版本，進展到可發布時才會與主分支合併\r\n- 並有三個臨時分支，通常只要被 ```merge``` 到長期分支就會被刪除：\r\n  - 功能分支 ```feature branch```：\r\n    ```txt\r\n    通常以 feature[-/][功能名] 為命名方式，如：feature/addItem\r\n    為了開發功能，通常從 develop 拉出來的分支\r\n    開發完成後會合併入 develop，為開發者直接修改並發送代碼的分支\r\n    ```\r\n  - 修復分支 ```hotfix branch```：\r\n    ```txt\r\n    通常以 fixbug[-/][bug功能名] 為命名方式，如：fixbug/cartAddItem\r\n    當 master 發生 bug 時，會從 master 拉出來的分支\r\n    修復完以後會直接合併入 master 與 develop，並刪除該分支\r\n    ```\r\n  - 預發分支 ```release branch```：\r\n    ```txt\r\n    通常以 release[-/][版本名] 為命名方式，如：release/websocket\r\n    當要上線到 master 之前，從 develop 拉出來的做"版本測試"的分支\r\n    該分支只處理發布前的提交，不能合併其他功能變更\r\n    版本測試結束後，需合併入 master 與 develop，並刪除該分支\r\n    ```\r\n\r\n<hr id="user-content-workflow-github-flow" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >Github flow</a>\r\n- ```Github flow``` 通常適合十人以上團隊，並一天內可能有多次部屬開發\r\n- ```Github``` 比 ```Git``` 多了 ```fork```、```pull request（PR）```、```issue tracking``` 用法\r\n- 使用 ```git tag``` 可以設版本號，如：```v0.1.0```\r\n- 主要分成三部分\r\n  - 共用遠端倉庫：```master```\r\n  - 私人遠端倉庫：在共用遠端倉庫 ```fork``` 到自己的私人倉庫\r\n  - 私人本地倉庫：與自己的遠端私人倉庫進行代碼提交\r\n- 流程如下：\r\n  ```txt\r\n                 fork                    clone\r\n     共用      ----------\x3e     私人     ---------\x3e   私人\r\n   遠端倉庫    <----------    遠端倉庫  <---------  本地倉庫\r\n          merge <- check <- PR            push\r\n  ```\r\n- 主要概念：\r\n  - 讓 ```master``` 保持可部署的狀態\r\n  - 若要創建新分支，則命名需含有功能描述，如：```addVisaPay```\r\n    - 每次提交時，必須寫 ```commit message``` 解釋提交內容\r\n  - 若準備合併，則創建 ```PR```，並藉由 ```PR``` 進行交流\r\n    - 若要請人幫忙檢閱，可以用 ```@``` 請求其他人反饋\r\n  - 確認完成後與 ```master``` 合併並且"一定要測試"，最後立刻部署\r\n  - ```issue tracking```：\r\n    - [詳細參考](https://github.com/g0v/dev/wiki/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Issue-Tracker-%E5%9B%9E%E5%A0%B1%E5%95%8F%E9%A1%8C%E3%80%81%E6%8F%90%E4%BA%A4%E5%BB%BA%E8%AD%B0)\r\n    ```txt\r\n    開發時可給專案標記 issue 或其他標籤，\r\n    若提交訊息含有 fix #1(issue編號)\r\n    可直接對應到相關編號的 issue\r\n    ```\r\n\r\n<hr id="user-content-workflow-gitlab-flow" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >Gitlab flow</a>\r\n- ```Gitlab flow``` 最主要原則為 ```Upstream First(上游優先)```，主要概念如下：\r\n  - ```master``` 為所有分支的上游\r\n  - 需一次合併並且通過測試才可往下合併\r\n  - 合併順序很重要，只有緊急情況才可跳過上游與下游合併\r\n- ```Gitlab flow``` 分兩種情況對應不同的開發流程\r\n  - 持續發布(Environment Branches & Upstream First)\r\n    ```txt\r\n    在持續發布的專案，建議可多出一個預發分支 pre-production\r\n    如果生產環境(production)發生錯誤，\r\n    則在 master 建一個新分支，修改完後合併到 master，\r\n    並經過測試，繼續往預發分支(pre-production)合併，再經過測試才能合併到生產環境\r\n    \r\n    流程(若 production 發生錯誤則跑此流程(到有錯誤的上游))：\r\n    建立的新分支 -> master -> pre-production -> production\r\n    \r\n    個人結論：以 production 為最終產出，一路合併到 production \r\n    ```\r\n  - 版本發布(Release Branches & Upstream First)\r\n    ```txt\r\n    在版本發布的項目\r\n    建議每一個穩定版本(release 分支)都從 master 分支拉出來一個新分支，比如 1–1-stable、1–2-stable\r\n    若要修復穩定版本，則在 master 創建一個修復分支\r\n    修補完後，照著上游優先規則，先合併到 master分支，\r\n    確認完才能夠合併到穩定版本，並且更新版本號。\r\n    \r\n    流程(若 1–2-stable 發生錯誤則須跑此流程)：\r\n    建立的新分支 -> master -> 1–2-stable\r\n    \r\n    個人結論：以 master 為主，來產生新穩定版本節點\r\n    ```\r\n\r\n<hr id="user-content-user-settings" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >使用者設定</a>\r\n- 設定使用者\r\n  - 設定名字：```git config --global user.name "[名字]"```\r\n  - 設定信箱：```git config --global user.email "[信箱]"```\r\n- 查看使用者資訊\r\n  - ```git config --global user.name```\r\n  - ```git config --global user.email```\r\n\r\n<hr id="user-content-start" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >開始專案</a>\r\n- 無原始檔案\r\n  - 初始化：```git init```\r\n  - 新增遠端位置：```git remote add [名稱(origin)] [網址]```\r\n    - 網址可透過開新專案後取得\r\n  - 將新增內容全部加入：```git add .```\r\n  - 加入初始化訊息：```git commit -m init```\r\n  - 上傳遠端：```git push origin master```\r\n    - ```master```：代表現在分支\r\n    - ```origin```：代表遠端位置\r\n- 若有原始專案\r\n  - 第一種方式：```git init``` -> ```git remote add [名稱(origin)] [網址]``` -> ```git pull [名稱(origin)] [分支]```\r\n  - 第二種方式：```git clone [網址]```(使用 ```git remote -v``` 會附有遠端網址)\r\n    - 複製他人專案分支：```git clone [網址] [分支名稱]```\r\n    - 若要觀看遠端分支資料：```git checkout [遠端分支名稱(可由 git branch -r 觀看)]```\r\n      - 如：```git checkout origin/experimental```\r\n    - 取得遠端分支資料(本地會多一個新分支)：```git checkout [遠端分支名稱]```\r\n      - 如：```git checkout experimental```\r\n    - 複製單一分支：```git clone --single-branch --branch [分支名稱] [遠端位置]```\r\n      - ```git clone -b [分支名稱] [遠端位置]```\r\n    - 更新遠端所有分支：```git remote update origin --prune```\r\n    - 取得遠端資訊(若取得不到)：```git fetch origin```\r\n    \r\n<hr id="user-content-update" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >上傳常用指令</a>\r\n- 1.查看目前狀態：```git status```\r\n  - 若對單一檔案想還原到上個 ```commit``` 狀態：```git checkout [檔名]```\r\n  - 全部還原到上一版狀態：```git reset --hard```\r\n- 2.加入全部到索引：```git add .```\r\n  - 加入單一檔案進索引：```git add [檔名]```\r\n  - 若要取消全部索引狀態：```git reset HEAD``` 或 ```git reset```\r\n  - 取消單筆：```git reset HEAD [檔名]``` 或 ```git reset [檔名]```\r\n- 3.```git commit -m [版本訊息]```\r\n  - 若想修改剛剛"最新"的 ```commit``` 訊息：```git commit --amend -m [修改的訊息]```\r\n- 4.```git push [遠端位置或名稱(origin)] [分支名稱]```\r\n  \r\n<hr id="user-content-merge" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >合併分支(含遠端)</a>\r\n- 通常該階段會交由 ```leader``` 操作，確保專案正常運行\r\n- 1.取得主分支的更新：```git pull origin [主分支]```\r\n- 2.若無問題，則切換到主分支：```git checkout [主分支]```\r\n- 3.將分支合併進主分支：```git merge [分支]```\r\n- 4.將主分支資訊上傳至遠端：```git push origin [主分支]```\r\n- 5.刪除遠端分支：\r\n  - 先刪除本地分支：```git branch -d [分支]```\r\n  - 將刪除分支資訊上傳到遠端：```git push origin :[分支]```\r\n- 若合併碰到錯誤情況\r\n  - 到該檔案進行編修\r\n  - 加入修改：```git add . ```\r\n  - 確認修改：```git commit \'[merge哪些東西]\'```\r\n  - 合併專案：```git merge [分支]```\r\n  - 上傳更新：```git push origin [主分支]```\r\n    \r\n<hr id="user-content-gitignore" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >gitignore</a>\r\n- 直接使用記事本新增即可( ```utf-8``` 編碼存取)\r\n  - 或使用終端機創建：```touch .gitignore```\r\n- 可以觀看個程式語言需要忽略的檔案：[gitignore](https://github.com/github/gitignore)\r\n- 忽略整個資料夾：資料夾名/\r\n- 忽略類似附檔名檔案：*.副檔名\r\n- 若忽略發生錯誤使用指令矯正:\r\n  ```txt\r\n  git rm -r --cached .\r\n  git add .\r\n  git commit -m "fixed untracked files"\r\n  ```\r\n\r\n<hr id="user-content-branch" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >git branch 常用指令</a>\r\n- 查看所有遠端分支：```git branch -r```\r\n  - 結束：```q```\r\n- 查看所有分支：```git branch -a```\r\n  - 結束：```q```\r\n- 查看本地所有分支與所在分支：```git branch```\r\n- 刪除分支：```git branch -d [分支名稱]```\r\n- 新增 [新分支] 於 [主分支] 底下：```git branch [新分支] [主分支]```\r\n  - 主分支可加可不加，但需在主分支底下 \r\n\r\n<hr id="user-content-remote" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >git remote 常用指令</a>\r\n- 重設遠端分支網址：```git remote set-url [遠端位置名稱] [url]```\r\n- 改變遠端位置名稱：```git remote rename [原名稱] [修改名稱]```\r\n- 查看有哪些遠端位置：```git remote -v```\r\n- 新增遠端位置：```git remote add [名稱(origin)] [網址]```\r\n- 本地更新遠端所有資訊與分支：```git remote update origin --prune```\r\n\r\n<hr id="user-content-tag" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >git tag (git 標籤)</a>\r\n- 在此版本新增標籤：```git tag [標籤名稱]```\r\n  - 如：```git tag v1```\r\n- 新增詳細標籤：```git tag -am \'[敘述]\' [標籤名稱]```\r\n- 切換到此標籤版本：```git checkout [標籤名稱]```\r\n- 查看所有標籤：```git tag```\r\n- 查看所有詳細標籤內容：```git tag -n```\r\n  - 若沒有設定標籤內容則會自帶當初此版本 ```commit``` 敘述內容\r\n- 刪除標籤：```git tag -d [標籤名稱]```\r\n\r\n<hr id="user-content-stash" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >git stash (git 暫存)</a>\r\n- 暫存當前版本進度：```git stash```\r\n  - ```Untracked``` 狀態的檔案預設沒辦法使用，需額外使用 ```-u```)\r\n  - 使用完會恢復到未更改的版本，這時使用 ```git status``` 會發現 ```nothing to commit```\r\n- 還原最新的暫存(最新暫存會刪除)：```git stash pop```\r\n  - 還原指定版本暫存：```git stash pop stash@{2}```\r\n- 不刪除暫存並套用分支上：```git stash apply stash@{2}``` 或 ```git stash apply```\r\n- 清除最新的暫存：```git stash drop```\r\n  - 刪除指定暫存：```git stash drop stash@{0}```\r\n- 清除全部暫存：```git stash clear```\r\n- 查看目前所有暫存：```git stash list```\r\n\r\n<hr id="user-content-other" style="height: 2px;">\r\n\r\n#### <a href="#user-content-top" >其他使用指令</a>\r\n- 切換至該版本紀錄\r\n  - ```git checkout [commit 前4碼，可由 git log 觀看]```\r\n  - 復原則直接切換到原本分支即可\r\n- 救回不小心刪除的檔案\r\n  - 將 ```xxx.txt``` 的檔案回復到上一次的 ```commit``` 的狀態：```git checkout xxx.txt```\r\n  - 將回復到兩個版本以前的 ```xxx.txt```：```git checkout HEAD~2 xxx.txt```\r\n  - 將檔案回復到上一次 ```commit``` 的狀態：```git checkout .```\r\n- 查看該檔案修改的所有紀錄：```git blame [檔名]```\r\n- 查看移動 ```HEAD``` 移動歷程(每當 ```HEAD``` 有移動，就會在這記上一筆)：```git reflog```\r\n',m=Object(e["w"])(!0),p=Object(e["w"])(!1),f=Object(e["w"])(!0),b=Object(e["w"])(!1),w=Object(e["w"])(""),x={name:"GitNote",components:{Loading:l["a"]},setup:function(){return Object(e["p"])(Object(o["a"])(regeneratorRuntime.mark((function r(){var n;return regeneratorRuntime.wrap((function(r){while(1)switch(r.prev=r.next){case 0:if(!m.value){r.next=7;break}return n=c()({html:!0,linkify:!0,typographer:!0,highlight:function(r,n){return h.a.highlight(r,{language:n}).value}}),w.value=n.render("".concat(d)),r.next=5,Object(a["c"])((function(){m.value=!1}),1e3).then((function(){return Object(a["c"])((function(){f.value=!1,b.value=!0}),500)})).then((function(){return Object(a["c"])((function(){p.value=!0,Object(a["a"])()}),100)}));case 5:r.next=8;break;case 7:Object(a["a"])();case 8:case"end":return r.stop()}}),r)})))),Object(s["a"])(),{showLoading:m,showContent:p,displayLoading:f,displayContent:b,htmlContent:w}}};t("adb6");x.render=i;n["default"]=x},a5ae:function(r,n,t){},adb6:function(r,n,t){"use strict";t("a5ae")}}]);
//# sourceMappingURL=gitNote.cfcb8c52.js.map