(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["jsNote"],{8287:function(n,r,e){"use strict";e("c3a3")},c3a3:function(n,r,e){},e19f:function(n,r,e){"use strict";e.r(r);var t=e("7a23");function o(n,r,e,o,s,a){var l=Object(t["y"])("Loading");return Object(t["r"])(),Object(t["d"])(t["a"],null,[o.displayLoading?(Object(t["r"])(),Object(t["d"])(l,{key:0,class:{"content--hide":!o.showLoading,"content--show":o.showLoading}},null,8,["class"])):Object(t["e"])("",!0),o.displayContent?(Object(t["r"])(),Object(t["d"])("div",{key:1,class:{"markdown-content":!0,"content--hide":!o.showContent,"content--show":o.showContent}},[Object(t["h"])("div",{class:"markdown-body",innerHTML:o.htmlContent},null,8,["innerHTML"])],2)):Object(t["e"])("",!0)],64)}var s=e("1da1"),a=(e("96cf"),e("ed08")),l=e("df69"),c=e("d4cd"),i=e.n(c),u=e("2338"),d=e("1487"),p=e.n(d),g=e("3a5e"),h="## JS 筆記\r\n<a id=\"user-content-top\"></a>\r\n\r\n### 目錄\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;語法與表達式 </summary>\r\n\r\n- [ECMAScript & JS 關係](#user-content-ecmascript-js)\r\n- [變量與數據類型](#user-content-variable-datatype)\r\n  - [變量](#user-content-variable-datatype)\r\n  - [const、let、var](#user-content-const-let)\r\n  - [輸出語句](#user-content-output-statement)\r\n  - [數值](#user-content-number)\r\n  - [undefined & null](#user-content-undefined-null)\r\n  - [typeof](#user-content-typeof)\r\n  - [數據類型轉換](#user-content-datatype-convert)\r\n  - [數據類型表](#user-content-datatype-table)\r\n- [字串](#user-content-string-splicing)\r\n  - [字串與拼接](#user-content-string-splicing)\r\n  - [includes](#user-content-string-includes)\r\n  - [padStart、padEnd](#user-content-string-padstart-padend)\r\n  - [trimStart、trimEnd](#user-content-string-trimstart-trimend)\r\n  - [模板字符串](#user-content-string-template-literals)\r\n- [表達式與操作符](#user-content-expressions-operators)\r\n  - [陳述式與表達式差異](#user-content-expressions-operators)\r\n  - [運算符](#user-content-operator)\r\n  - [Math函數](#user-content-math)\r\n\r\n</details>\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;流程控制與數組</summary>\r\n\r\n- [流程控制](#user-content-process-control)\r\n  - [判斷語句](#user-content-process-control)\r\n  - [循環語句](#user-content-loop)\r\n- [數組](#user-content-array)\r\n  - [創建數組](#user-content-array)\r\n  - [取得與更改數組項](#user-content-modify)\r\n  - [數組去重](#user-content-de-duplication)\r\n  - [二維數組](#user-content-two-dimensional)\r\n  - 常用方法\r\n    | 分類 | 常用方法 |\r\n    | :-- | :-- |\r\n    | 操作原數組 | [push、unshift、pop、shift](#user-content-pups)、[splice](#user-content-splice)、[reverse](#user-content-reverse)、[sort](#user-content-sort) |\r\n    | 取得數組資訊 | [indexOf](#user-content-indexof)、[lastIndexOf](#user-content-lastindexof)、[find、findIndex](#user-content-array-find-findindex)、[filter](#user-content-filter) |\r\n    | 取得新數組或新值 | [join](#user-content-join)、[concat](#user-content-concat)、[slice](#user-content-slice)、[map](#user-content-map)、[reduce、reduceRight](#user-content-reduce-reduceright)、[flat、flatMap](#user-content-flat-flatMap)、[Array.from](#user-content-array-from) |\r\n    | 判斷回傳布林值 | [every](#user-content-array-every)、[some](#user-content-array-some)、[includes](#user-content-array-includes)、[Array.isArray](#user-content-array-isarray) |\r\n</details>\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;函數、DOM、BOM</summary>\r\n\r\n- [函數](#user-content-function)\r\n  - [作用域與變量](#user-content-function)\r\n  - [函數優先提升](#user-content-function-promotion)\r\n  - [函數的使用](#user-content-function-use)\r\n  - [閉包](#user-content-closure)\r\n  - [IIFE](#user-content-iife)\r\n  - [箭頭函數](#user-content-arrow-function)\r\n- [DOM](#user-content-dom)\r\n  - [簡介](#user-content-dom)\r\n  - [onload 使用](#user-content-onload)\r\n  - [常用訪問節點方法](#user-content-get-element)\r\n  - [nodeType 常用屬性值](#user-content-node-type)\r\n  - [節點屬性](#user-content-node-attributes)\r\n  - [節點操作](#user-content-node-operate)\r\n  - [節點自定義屬性](#user-content-node-customize)\r\n  - [事件監聽](#user-content-event-listener)\r\n    - [表單](#user-content-event-listener)\r\n    - [頁面](#user-content-event-listener-page)\r\n    - [鼠標](#user-content-event-listener-mouse)\r\n    - [鍵盤](#user-content-event-listener-keybored)\r\n    - [on 與 addEventListener](#user-content-event-listener-on-add)\r\n    - [事件委託](#user-content-event-listener-entrust)\r\n  - [異步語句](#user-content-async-statment)\r\n- [BOM](#user-content-bom)\r\n  - [簡介](#user-content-bom)\r\n  - [History 對象](#user-content-history)\r\n  - [Location 對象](#user-content-location)\r\n  - [Navigator 對象](#user-content-navigator)\r\n  - [offsetTop 屬性](#user-content-offsettop)\r\n</details>\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;基於對象、正則表達式</summary>\r\n\r\n- [基於對象](#user-content-object-based)\r\n  - [簡介](#user-content-object-based)\r\n  - [關於對象](#user-content-about-object)\r\n  - [構造函數與對象](#user-content-constructor-object)\r\n  - [原型原型鏈](#user-content-object-prototype)\r\n  - [上下文規則與使用](#user-content-object-context)\r\n  - [call 與 apply](#user-content-call-apply)\r\n  - [Object.assign](#user-content-object-assign)\r\n  - [Object.keys、Object.values、Object.entries](#user-content-object-keys-values-entries)\r\n  - [Date 對象](#user-content-object-date)\r\n  - [Math 對象](#user-content-object-math)\r\n- [正則表達式](#user-content-regexp)\r\n  - [創建與使用](#user-content-regexp)\r\n  - [元字符](#user-content-metacharacter)\r\n  - [方括號表示法](#user-content-square-brackets)\r\n  - [字串相關方法](#user-content-string-regexp)\r\n  - [量詞](#user-content-measure-word)\r\n</details>\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;Promise</summary>\r\n\r\n- [簡介](#user-content-promise-introduce)\r\n- [基本用法](#user-content-promise-basic-use)\r\n- [實例方法](#user-content-promise-instance-function-then)\r\n- [then](#user-content-promise-instance-function-then)\r\n- [catch](#user-content-promise-instance-function-catch)\r\n- [finally](#user-content-promise-instance-function-finally)\r\n- [構造函數方法](#user-content-promise-constructor-function-resolve)\r\n- [Promise.resolve](#user-content-promise-constructor-function-resolve)\r\n- [Promise.reject](#user-content-promise-constructor-function-reject)\r\n- [Promise.all](#user-content-promise-constructor-function-all)\r\n- [Promise.race](#user-content-promise-constructor-function-race)\r\n- [Promise.allSettled](#user-content-promise-constructor-function-allsettled)\r\n- [Promise.any](#user-content-promise-constructor-function-any)\r\n- [注意事項](#user-content-promise-constructor-function-notice)\r\n- [應用範例](#user-content-promise-example)\r\n</details>\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;Class</summary>\r\n\r\n- [簡介](#user-content-class)\r\n- [定義形式](#user-content-class-definition-form)\r\n- [屬性與方法](#user-content-class-property-function)\r\n- [私有屬性與方法](#user-content-class-private-property-function)\r\n- [extends](#user-content-class-extends)\r\n- [super](#user-content-class-super)\r\n</details>\r\n<details>\r\n<summary style=\"cursor: pointer;\">&nbsp;其他用法</summary>\r\n\r\n- JS 本身額外用法\r\n  - [解構賦值](#user-content-destructuring-assignment)\r\n  - [對象與函數的提升](#user-content-object-function-promote)\r\n  - [剩餘參數](#user-content-rest-parameter)\r\n  - [展開運算符](#user-content-spread-operator)\r\n  - [Set 物件](#user-content-set-object)\r\n  - [Map 物件](#user-content-map-object)\r\n  - [Iterator 與 for-of 循環](#user-content-iterator-for-of)\r\n  - [Symbol](#user-content-symbol)\r\n- 其他常用用法\r\n  - [函數節流鎖](#user-content-function-throttle-lock)\r\n  - [分時函數](#user-content-separate-time-function)\r\n</details>\r\n\r\n<hr id=\"user-content-ecmascript-js\" style=\"height: 4px;\">\r\n\r\n### 語法與表達式\r\n#### <a href=\"#user-content-top\" >ECMAScript & JS 關係</a>\r\n- ECMAScript: JS 的標準化規範\r\n- JS: ECMAScript 的實現\r\n\r\n<hr id=\"user-content-variable-datatype\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >變量與數據類型</a>\r\n#### <a href=\"#user-content-top\" >變量</a>\r\n```html\r\n<script>\r\n  /*\r\n    變量宣告方式('myValue'可替換其他數據類型)\r\n    變量名只能用 字母、數字、底線、$ 組成並且不能用 數字 開頭\r\n          不能用 關鍵字 與 保留字\r\n          並且區分大小寫\r\n    變量名盡量使用駝峰式命名法: exampleLikeThis\r\n  */\r\n  var name = 'myValue'\r\n\r\n  // 變量提升\r\n  // 執行代碼前,JS有預解析階段,會預讀所有變量的\"定義\"\r\n  // 變量提升只會讀取定義但不會讀取賦值(所以第一個會輸出undefined)\r\n  console.log(a);// undefined\r\n  console.log(typeof a);// undefined\r\n  var a = 123;\r\n  console.log(a); // 123\r\n  // 上面等價於下面\r\n  var a;\r\n  console.log(a);// undefined\r\n  console.log(typeof a);// undefined\r\n  a = 123;\r\n  console.log(a); // 123\r\n<\/script>\r\n```\r\n\r\n<hr id=\"user-content-const-let\" style=\"height: 4px;\">\r\n\r\n#### <a href=\"#user-content-top\">const、let、var</a>\r\n- ```const``` 為聲明常量，一旦初始化，就不能重新赋值\r\n  - 為了初始化後不希望重新賦值的情況設計的\r\n  - 一旦聲明，就需立即初始化，無法留到以後賦值\r\n  - 允許在不重新赋值的情况下修改它的值(引用類型)\r\n  - 建議都先用 ```const``` 若需要重新賦值再改使用 ```let```\r\n- ```var、let``` 為聲明變量，一旦初始化後，可以重新赋值\r\n- 三者區別\r\n  - 重複聲明\r\n    - ```var``` 允許\r\n    - ```let、const``` 不允许\r\n  - 變量提升\r\n    - ```var``` 會提升聲明到當前作用域的頂部\r\n    - ```let、const``` 不會提升\r\n    - 可以養成良好的習慣，先聲明後使用\r\n  - 作用域\r\n    - ```var``` 沒有塊級作用域\r\n    - ```let、const``` 有塊級作用域\r\n    - 會自動綁定該作用域，不受到外部作用域的影響\r\n  - window 對象\r\n    - ```var``` 聲明的變量，透過 ```function``` 聲明的函數，會自動變成 window 對象的屬性與方法\r\n    - ```let、const``` 不會變成 window 對象\r\n\r\n<hr id=\"user-content-output-statement\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >輸出語句</a>\r\n```js\r\n// 裡面 'value' 可替換其他數據類型\r\n// 彈出視窗\r\nalert('value');\r\n/*\r\n  控制台輸出\r\n  控制台是一種REPL環境\r\n  read(讀) => eval(執行) => print(打印) => loop(循環:回到read)\r\n*/\r\nconsole.log('value');\r\n```\r\n\r\n<hr id=\"user-content-number\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >數值</a>\r\n```js\r\n// e 代表 10的次方\r\nconsole.log(3e4) //30000\r\nconsole.log(.3e5) // 0.3x100000=30000\r\nconsole.log(3e-4) // 0.0003\r\nconsole.log(-3e4) // -30000\r\n\r\n// 2進制:0b\r\nconsole.log(0b1111) //15\r\n\r\n// 8進制:0\r\nconsole.log(017) //15\r\n\r\n// 16進制:0x\r\nconsole.log(0xf) //15\r\n\r\n// 其他特殊運算\r\nconsole.log(0/0) //NaN\r\nconsole.log('1'-'2') //NaN\r\nconsole.log(typeof NaN) //Number\r\nconsole.log(NaN == NaN) //false\r\n\r\n/*\r\n  Infinity 是無限大\r\n  非零數字除以0，會是Infinity或-Infinity\r\n  Infinity 是一個數字類型\r\n*/\r\nconsole.log(typeof Infinity)// Number\r\n```\r\n\r\n<hr id=\"user-content-undefined-null\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >undefined & null</a>\r\n```js\r\n// undefined 是值也是類型(默認值)\r\nconsole.log(typeof undefined)// undefined\r\n// null: 空對象，若要將 對象、數組、事件監聽 銷毀可以設為 null\r\nconsole.log(typeof null)// object\r\n```\r\n\r\n<hr id=\"user-content-typeof\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >typeof</a>\r\n- 用來檢測變量的數據類型\r\n- 返回值有 ```undefined、Null、Boolean、Number、String、Object```\r\n- 使用方法有兩種：typeof 變量 和 typeof(變量)\r\n  ```js\r\n  var a = 123;\r\n  var b = 'test';\r\n\r\n  console.log(typeof a);// number\r\n  console.log(typeof b);// string\r\n  ```\r\n\r\n<hr id=\"user-content-datatype-convert\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">數據類型轉換</a>\r\n- 以下為轉換範例\r\n  ```js\r\n  Number('123');// 123\r\n  Number('123.4');// 123.4\r\n  Number('123年');// NaN\r\n  Number('2e3');// 2000\r\n  Number('');// 0\r\n  Number(true);// 1\r\n  Number(false);// 0\r\n  Number(undefined);// NaN\r\n  Number(null);// 0\r\n\r\n  // 將字串轉為整數(無條件捨去)\r\n  parseInt('3.14')// 3\r\n  parseInt('3.14是圓周率')// 3(.以後都去掉)\r\n  parseInt('圓周率是3.14')// NaN(非數字開頭)\r\n  parseInt('3.99')// 3\r\n  parseInt('33m44.99')// 33(非數字以後都去掉)\r\n  parseInt(3.99)// 3\r\n  parseInt('200px')// 200\r\n\r\n  parseFloat('3.14')// 3.14\r\n  parseFloat('3.14是圓周率')// 3.14\r\n  parseFloat('圓周率是3.14')// NaN(非數字開頭)\r\n  parseFloat('3.99')// 3.99\r\n\r\n  String(123) // '123'\r\n  String(123.4)// '123.4'\r\n  String(2e3)// '2000'\r\n  String(NaN)// 'NaN'\r\n  String(Infinity)// 'Infinity'\r\n  String(0xf)// '15'(會被轉成10進制)\r\n  String(true);// 'true'\r\n  String(false);// 'false'\r\n  String(undefined);// 'undefined'\r\n  String(null);// 'null'\r\n\r\n  (6).toString();// '6'\r\n  var a = 6;\r\n  a.toString();// '6'\r\n  true.toString();// 'true'\r\n  NaN.toString();// 'NaN'\r\n\r\n  Boolean(123);// true\r\n  Boolean(0);// false\r\n  Boolean(NaN);// false\r\n  Boolean(Infinity);// true\r\n  Boolean(-Infinity);// true\r\n  Boolean('');// false\r\n  Boolean('abc');// true\r\n  Boolean('false');// true\r\n  Boolean(undefined);// false\r\n  Boolean(null);// false\r\n  ```\r\n\r\n<hr id=\"user-content-datatype-table\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">數據類型表</a>\r\n| 類型 | typeof檢測值 | 範例 |\r\n| :-- | :-- | :-- |\r\n| 數字類型 | number | 1 |\r\n| 字串類型 | string | 'test' |\r\n| 布爾類型 | boolean | true false |\r\n| undefined類型 | undefined | undefined |\r\n| null類型 | object | null |\r\n\r\n<hr id=\"user-content-string-splicing\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\" >字串</a>\r\n#### <a href=\"#user-content-top\" >字串與拼接</a>\r\n```js\r\nvar a = 10;\r\nvar str = '我買了' + a + '顆蘋果';\r\nconsole.log(str);// 我買了10顆蘋果\r\nconsole.log(str.length) // 8\r\n\r\n// 若charAt超過該字符串長度則輸出''\r\nconsole.log(str.charAt(2)) //0為開始算到2 => 了\r\n\r\n// substring(a, b) 從a位到b位但不包含b位(省略b則擷取至末端)，a與b可對調 str.substring(0,3) = str.substring(3,0))\r\nconsole.log(str.substring(0,3)) //我買了\r\nconsole.log(str.substring(-1,3)) //我買了(若a為負數則視為0)\r\nconsole.log(str.substring(6,10)) //蘋果(若b超過長度則擷取至末端)\r\nconsole.log(str.substring(6)) //蘋果\r\n\r\n// substr(a, b) 從a位開始長度為b的字串(省略b則擷取至末端)\r\n// a可以為負數，則會從最後一位開始往前數\r\n// 當b為負數時，返回空字符串\r\nconsole.log(str.substr(0,2)) // 我買\r\nconsole.log(str.substr(0)) // 我買了10顆蘋果\r\n\r\n// 當有負數時(若往前數到字串末端則只擷取到末端)\r\nconsole.log('我買了10顆蘋果'.substr(-2, 5))// 蘋果\r\nconsole.log('123456'.substr(-4, 2)) //34(於第-4位往前數2位)\r\nconsole.log('123456'.substr(-2, 2)) //56(於第-2位往前數2位)\r\n\r\n/*\r\n  slice(a,b) 與 substring(a,b) 類似從a位到b位但不包含b位\r\n  但 slice a與b可以為負數且a必須小於b\r\n*/ \r\nconsole.log('123456'.slice(5, 2)) //''\r\nconsole.log('123456'.slice(-5, -2)) //234\r\nconsole.log('123456'.slice(-5))//23456\r\n\r\nconsole.log('aBc'.toUpperCase())//ABC\r\nconsole.log('aBc'.toLowerCase())//abc\r\n\r\nconsole.log('abcdef'.indexOf('de'))//3\r\nconsole.log('abcdef'.indexOf('g'))//找不到則為-1\r\n```\r\n\r\n<hr id=\"user-content-string-includes\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">includes</a>\r\n- 用於判斷字符串中是否含有字符\r\n- 第二個參數表示開始搜索的位置，默認為0\r\n- 用法\r\n  ```js\r\n  // 判斷字符串中是否含有字符\r\n  console.log('abc'.includes('a'));// true\r\n  console.log('abc'.includes('ab'));// true\r\n  console.log('abc'.includes('bc'));// true\r\n  console.log('abc'.includes('ac'));// false\r\n  // 第二個參數表示開始搜索的位置，默認為0\r\n  console.log('abc'.includes('a'));// true\r\n  console.log('abc'.includes('a', 0));// true\r\n  console.log('abc'.includes('a', 1)); // false\r\n  ```\r\n\r\n<hr id=\"user-content-string-padstart-padend\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">padStart、padEnd</a>\r\n- 用於補全字符串長度\r\n- ```padStart``` 往前補全字符串\r\n- ```padEnd``` 往後補全字符串\r\n- 注意事項\r\n  - 若長度大於等於最大長度，會直接返回原字符串\r\n  - 若補全的與原本的長度和超過最大長度，會截去部分的補全字符串\r\n  - 如果省略第二個参数，默認使用空格補全長度\r\n- 用法\r\n  ```js\r\n  // 補全字符串長度\r\n  console.log('x'.padStart(5, 'ab'));// ababx\r\n  console.log('x'.padEnd(5, 'ab'));// xabab\r\n  console.log('x'.padEnd(4, 'ab'));// xaba\r\n  // 長度大於等於最大長度，會直接返回原字符串\r\n  console.log('xxx'.padStart(2, 'ab'));// xxx\r\n  console.log('xxx'.padEnd(2, 'ab'));// xxx\r\n  // 超過最大長度會截去部分的補全字符串\r\n  console.log('abc'.padStart(10, '0123456789'));// 0123456abc\r\n  console.log('abc'.padEnd(10, '0123456789'));// abc0123456\r\n  // 如果省略第二個参数，默認使用空格補全長度\r\n  console.log('x'.padStart(4));//    x\r\n  console.log('x'.padEnd(4));// x   \r\n  ```\r\n\r\n\r\n<hr id=\"user-content-string-trimstart-trimend\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">trimStart、trimEnd</a>\r\n- 清除字符串的首或尾空格，中間的空格不會清除\r\n- 用法\r\n  ```js\r\n  const s = '  a b c  ';\r\n  // 清除字串前面所有空格\r\n  // trimStart = trimLeft\r\n  console.log(s.trimStart());// a b c  \r\n  console.log(s.trimLeft());// a b c  \r\n  // 清除字串後面所有空格\r\n  // trimEnd = trimRight\r\n  console.log(s.trimEnd());//  a b c\r\n  console.log(s.trimRight());//  a b c\r\n  ```\r\n\r\n<hr id=\"user-content-string-template-literals\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">模板字符串</a>\r\n- 可透過樣板字面值來使用多行字串及字串內插功能\r\n- 注意事項\r\n  - 凡最终可以得出一個值的就可透過 ```${}``` 注入\r\n  - 所有的空格、換行或縮進都會保留在輸出之中\r\n- 範例\r\n  ```js\r\n  const age = 18;\r\n  const introduce = `今年${age}歲`\r\n  console.log(introduce);// 今年18歲\r\n  ```\r\n\r\n<hr id=\"user-content-expressions-operators\" style=\"height: 4px;\">\r\n\r\n#### <a href=\"#user-content-top\">表達式與運算符</a>\r\n#### <a href=\"#user-content-top\">陳述式與表達式差異</a>\r\n- 陳述式\r\n  - 執行程式碼單詞或片段,主要特徵在於```但不會回傳結果```\r\n  - 比如```宣告``` ```流程控制``` ```迴圈```\r\n- 表達式\r\n  - 特徵在於```會回傳結果```\r\n  - 比如```變數``` ```運算子``` ```正規表達式```\r\n\r\n<hr id=\"user-content-operator\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">運算符</a>\r\n- 運算順序: ```NOT !``` > ```算術運算符``` > ```關係運算符``` > ```邏輯運算符```\r\n- 算術運算符\r\n  - ```加 +``` ```減 -``` ```乘 *``` ```除 /``` ```取餘 %```\r\n  ```js\r\n  /*\r\n    IEEE754 小數點運算問題\r\n    有時有精度問題所以需要用 toFixed(a)函數\r\n    a代表保留小數點後多少位\r\n    會輸出為字串,所以需要額外轉換成數字\r\n  */\r\n  console.log(0.1+0.2)//0.30000000000000004\r\n  console.log(Number((0.1+0.2).toFixed(2)))\r\n  ```\r\n- 關係運算符\r\n  - ```大於 >``` ```小於 <``` \r\n  - ```大於等於 >=``` ```小於等於 <=``` \r\n  - ```等於 ==``` ```不等於 !=```\r\n  - ```全等於 ===``` ```不全等於 !==```\r\n  ```js\r\n  1 == true;// true\r\n  1 === true;// false\r\n  0 == false;// true\r\n  0 === false;// false\r\n  0 == undefined;// false\r\n  0 === undefined;// false\r\n  null == undefined;// true\r\n  null === undefined;// false\r\n  ```\r\n- 邏輯運算符\r\n  - 依運算順序排列: ```NOT !``` ```AND &&``` ```OR ||```\r\n  ```js\r\n  // NOT !\r\n  !true;// false\r\n  !false;// true\r\n  !0;// true\r\n  !undefined;// true\r\n  !'';// true\r\n  !'test';// false\r\n  !!true;//true \r\n  !!0;// false\r\n  !!'';// false\r\n  !!'test';// true\r\n  \r\n  // AND &&\r\n  // 先判斷真假再判斷值\r\n  3 && 6;// 6\r\n  undefined && 15;// undefined\r\n  15 && undefined;// undefined\r\n  null && 2;// null\r\n  '' && 16;// ''\r\n  NaN && undefined;// NaN\r\n\r\n  // OR ||\r\n  3 || 6;// 3\r\n  0 || 6;// 6\r\n  null || undefined;// undefined\r\n  'a' || 'b';// 'a'\r\n  NaN || null;// null\r\n\r\n  !true || true;// true\r\n  3 && 4 || 5 && 6;// 4\r\n  ```\r\n- 賦值運算符\r\n  - ```賦值 =```\r\n  - ```快捷賦值 += -= *= /= %=```\r\n  - ```自增 ++```\r\n  - ```自減 --```\r\n  ```js\r\n  // 快捷賦值\r\n  var a = 6;\r\n  a *= 2;// 12\r\n  a += 3;// 15\r\n  a /= 3;// 5\r\n  a %= 2;// 1\r\n\r\n  // 自增自減\r\n  // 先加在賦值\r\n  var a = 3;\r\n  var b = ++a;\r\n  console.log(b);// 4\r\n  console.log(a);// 4\r\n  // 賦值後再加\r\n  var a = 3;\r\n  var b = a++;\r\n  console.log(b);// 3\r\n  console.log(a);// 4\r\n  ```\r\n- isNaN 函數\r\n  ```js\r\n  // isNaN 函數可以用來判斷變量是否為NaN\r\n  // 原理:只要傳入Number()後的結果是NaN就會得到true\r\n  isNaN(NaN);// true\r\n  isNaN(5);// false\r\n  isNaN(undefined);// true\r\n  isNaN('3');// true\r\n  isNaN(null);// false\r\n  ```\r\n\r\n<hr id=\"user-content-math\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Math函數</a>\r\n```js\r\n/*\r\n  Math.ceil 向上取整\r\n  Math.floor 向下取整\r\n*/\r\nconsole.log(Math.ceil(2.4))// 3\r\nconsole.log(Math.floor(2.4))// 2\r\n// 冪與開根號\r\nconsole.log(Math.pow(2,3))//8: 2的3次方\r\nconsole.log(Math.sqrt(81))//81開根號=9\r\nconsole.log(Math.sqrt(-81))//NaN\r\n// 取亂數\r\nconsole.log(Math.random())\r\n// 取 a到b 之間的隨機整數\r\nconsole.log(parseInt(Math.random()*(b-a+1))+a)\r\n```\r\n\r\n<hr id=\"user-content-process-control\" style=\"height: 4px;\">\r\n\r\n### 流程控制與數組\r\n#### <a href=\"#user-content-top\">流程控制</a>\r\n#### <a href=\"#user-content-top\">判斷語句</a>\r\n- if 語句\r\n  - [詳細請看 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/if...else)\r\n  - 包含 ```if、else if、else```\r\n  ```js\r\n  if (condition1)\r\n   statement1\r\n  else if (condition2)\r\n    statement2\r\n  else if (condition3)\r\n    statement3\r\n  else\r\n    statementN\r\n  ```\r\n- switch 語句\r\n  - [詳細請看 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/switch)\r\n  ```js\r\n  switch (expression) {\r\n    case value1:\r\n      //Statements executed when the\r\n      //result of expression matches value1\r\n      [break;]\r\n    case value2:\r\n      //Statements executed when the\r\n      //result of expression matches value2\r\n      [break;]\r\n    ...\r\n    case valueN:\r\n      //Statements executed when the\r\n      //result of expression matches valueN\r\n      [break;]\r\n    [default:\r\n      //Statements executed when none of\r\n      //the values match the value of the expression\r\n      [break;]]\r\n  }\r\n  ```\r\n- 三元運算符\r\n  ```js\r\n  var ans = age >= 18 ? '成年人' : '未成年人';\r\n  ```\r\n\r\n<hr id=\"user-content-loop\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">循環語句</a>\r\n- while 語句\r\n  - [詳細請看 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/while)\r\n  ```js\r\n  while (condition){\r\n    statement\r\n  }\r\n  ```\r\n- do-while 語句\r\n  - [詳細請看 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/do...while)\r\n  ```js\r\n  do{\r\n    statement\r\n  }while (condition);\r\n  ```\r\n- for 語句\r\n  - [詳細請看 MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for)\r\n  ```js\r\n  for ([initialization]; [condition]; [final-expression]){\r\n    statement\r\n  }\r\n  ```\r\n\r\n<hr id=\"user-content-array\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">數組</a>\r\n#### <a href=\"#user-content-top\">創建數組</a>\r\n```js\r\n// 方法1\r\nvar arr1 = [33, 44, 55, 66];\r\n// 方法2\r\nvar arr2 = new Array(33, 44, 55, 66);\r\n// 方法3\r\nvar arr3 = new Array(4);\r\n```\r\n\r\n<hr id=\"user-content-modify\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">取得與更改數組項</a>\r\n```js\r\n// 取得數組項\r\nvar arr = ['A', 'B', 'C', 'D'];\r\nconsole.log(arr[0]);// A\r\nconsole.log(arr[4]);// undefined\r\nconsole.log(arr[-1]);// undefined\r\nconsole.log(arr.length);// 4\r\nconsole.log(arr[arr.length - 1]);// D\r\n// 更改數組項\r\nvar arr = ['1', '2', '3', '4', '5'];\r\narr[6] = 'A';\r\nconsole.log(arr);//(7) [\"1\", \"2\", \"3\", \"4\", \"5\", empty, \"A\"]\r\n```\r\n\r\n<hr id=\"user-content-de-duplication\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">數組去重</a>\r\n```js\r\n// 原數組\r\nvar arr = [1, 1, 1, 2, 2, 3, 3, 3, 2, 1];\r\n// 结果數組\r\nvar result = [...new Set(arr)];\r\n```\r\n\r\n<hr id=\"user-content-two-dimensional\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">二維數組</a>\r\n```js\r\n// 數組包含多個一維數組\r\nvar matrix = [\r\n  [11, 33, 55],\r\n  [22, 33, 44],\r\n  [36, 49, 52],\r\n  [56, 10, 23]\r\n];\r\n```\r\n\r\n<hr id=\"user-content-pups\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">push、unshift、pop、shift</a>\r\n```js\r\n/*\r\n  push() 把新的參數添加到數組的尾部，返回值是數組的新長度\r\n  unshift() 把新的參數添加到數組的最前面，返回值是數組的新長度\r\n  pop() 刪除數組中的最後一個元素，返回值是被刪除的那個元素\r\n  shift() 刪除數組中的第一個元素，返回值是被刪除的那個元素\r\n*/\r\n\r\n// push()\r\nvar arr = [22, 33, 44, 55];\r\narr.push(66);\r\narr.push(77, 88, 99);\r\nconsole.log(arr);// [22, 33, 44, 55, 66, 77, 88, 99]\r\n// ***********************************\r\n// pop()\r\nvar arr = [22, 33, 44, 55];\r\nvar item = arr.pop();// 刪除最後一項並返回最後一項\r\nconsole.log(arr);// [22, 33, 44]\r\nconsole.log(item);// 55\r\n// ***********************************\r\n// unshift()\r\nvar arr = [22, 33, 44, 55];\r\narr.unshift(11);// 在首項前面新增一項\r\narr.unshift(0);\r\nconsole.log(arr);// [ 0, 11, 22, 33, 44, 55]\r\n\r\n// ***********************************\r\n// shift()\r\nvar arr = [22, 33, 44, 55];\r\nvar item = arr.shift();// 刪除首項並返回首項\r\nconsole.log(arr);// [33, 44, 55]\r\nconsole.log(item);// 22\r\n```\r\n\r\n<hr id=\"user-content-splice\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">splice</a>\r\n```js\r\n// 1\r\nvar arr = [0, 1, 2, 3];\r\narr.splice(2, 1);// 若第二個參數後面不寫則直接刪除\r\nconsole.log(arr);// [0, 1, 3]\r\n// 2\r\nvar arr = [0, 1, 2, 3, 4, 5];\r\nvar items = arr.splice(3, 0, 66, 77, 88, 99);\r\nvar items2 = arr.splice(3, 2, 66, 77, 88, 99);\r\nconsole.log(arr);// [0, 1, 2, 66, 77, 88, 99, 88, 99, 3, 4, 5]\r\nconsole.log(items);// []\r\nconsole.log(items2);// [66, 77] <= 會返回數組包含被刪除的項\r\n```\r\n\r\n<hr id=\"user-content-reverse\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">reverse</a>\r\n```js\r\n[0, 1, 2, 3, 4, 5].reverse();// [5, 4, 3, 2, 1, 0]\r\n// 將字串反轉\r\n'012345'.split('').reverse().join();// '5,4,3,2,1,0'\r\n'012345'.split('').reverse().join('');// '543210'\r\n```\r\n\r\n<hr id=\"user-content-sort\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">sort</a>\r\n```js\r\nvar arr = [33, 22, 11, 55];\r\n/*\r\n  a, b 分別為靠前靠後的項\r\n  若需要交換位置則返回正值,否則返回負值\r\n*/\r\narr.sort(function (a, b) {\r\n    return b - a;\r\n});\r\n\r\nconsole.log(arr);// [55, 33, 22, 11]\r\n```\r\n\r\n<hr id=\"user-content-indexof\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">indexOf</a>\r\n```js\r\n/*\r\n  indexOf 方法皆是以\"===\"做判斷\r\n  若有兩個參數則\r\n  第一個參數: 查找的項目\r\n  第二個參數: 從該點位置開始查找\r\n*/\r\n[0, 1, 2, 3, 4, 5].indexOf(6);// -1\r\n[0, 1, 2, 3, 4, 5, 2].indexOf(2);// 返回第一個出現的位置:2\r\n[0, 1, 2, 3, 4, 5].indexOf(3, 4);// -1\r\n```\r\n\r\n<hr id=\"user-content-lastindexof\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">lastIndexOf</a>\r\n```js\r\n/*\r\n  lastIndexof 方法皆是以\"===\"做判斷\r\n  若有兩個參數則\r\n  第一個參數: 查找的項目\r\n  第二個參數: 從該點位置開始往內查找\r\n*/\r\nlet arr = [1,2,3,4,1,2,3];\r\nconsole.log(arr.lastIndexOf(3));// 6\r\nconsole.log(arr.lastIndexOf(2,6));// 5\r\n```\r\n\r\n<hr id=\"user-content-array-find-findindex\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">find、findIndex</a>\r\n- ```find()```：滿足條件之後立即返回其值\r\n- ```findIndex()```：滿足條件後立即返回其索引\r\n- 第一個參數放入函數用来對每個元素進行判斷與回傳\r\n  - 裡面函數參數依序為：內容值、索引值、數組對象\r\n- 第二個參數為function裡面的this對象(若為箭頭函數則無this對象)\r\n- 用法\r\n  ```js\r\n  const testArray = [1, 5, 10, 15];\r\n  // find()\r\n  console.log(\r\n    testArray.find(function (value, index, arr) {\r\n      console.log(testArray === arr);// true\r\n      console.log(this);// #document\r\n      console.log(value, index);// 輸出內容值與索引值\r\n      return value > 9;\r\n    }, document)\r\n  );// 10，循環到10立即返回內容值\r\n\r\n  // findIndex()\r\n  console.log(\r\n    testArray.findIndex(function (value, index, arr) {\r\n      console.log(testArray === arr);// true\r\n      console.log(this);// #document\r\n      console.log(value, index);// 輸出內容值與索引值\r\n      return value > 9;\r\n    }, document)\r\n  );// 2，循環到10立即返回索引值\r\n  ```\r\n\r\n<hr id=\"user-content-filter\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">filter</a>\r\n```js\r\n// filter 會將每一項代入函數判斷，若為true則返回給新數組\r\n[1,2,3,4,5,6,7,8].filter(e => e > 3);    // [4, 5, 6, 7, 8]\r\n[1,2,3,4,5,6,7,8].filter(e => e%2 == 0); // [2, 4, 6, 8]\r\n```\r\n\r\n<hr id=\"user-content-join\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">join</a>\r\n```js\r\n[0, 1, 2, 3, 4, 5].join();// 等同於 toString\r\n[0, 1, 2, 3, 4, 5].toString();// '0,1,2,3,4,5'\r\n[0, 1, 2, 3, 4, 5].join('-');// '0-1-2-3-4-5'\r\n[0, 1, 2, 3, 4, 5].join('');// '012345'\r\n```\r\n\r\n<hr id=\"user-content-concat\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">concat</a>\r\n```js\r\n// 合併多個數組(不改變數組本身)\r\nvar arr1 = [1, 2, 3];\r\nvar arr2 = [4, 5, 6];\r\nvar arr3 = [7, 8, 9];\r\nvar arr = arr1.concat(arr2, arr3);\r\nconsole.log(arr);// [1, 2, 3, 4, 5, 6, 7, 8, 9]\r\nconsole.log(arr1);// [1, 2, 3]\r\n```\r\n\r\n<hr id=\"user-content-slice\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">slice</a>\r\n```js\r\n// 不會更改原數組只會返回\r\nvar arr = ['A', 'B', 'C', 'D', 'E', 'F'];\r\nvar child_arr1 = arr.slice(2, 5);\r\nvar child_arr2 = arr.slice(2);// 沒寫第二個參數則預設到最後一項\r\nvar child_arr3 = arr.slice(2, -1);// = arr.slice(2, 5)，-1 = 最後一項(往回數)\r\nconsole.log(child_arr1);// [\"C\", \"D\", \"E\"]\r\nconsole.log(child_arr2);// [\"C\", \"D\", \"E\", \"F\"]\r\nconsole.log(child_arr3);// [\"C\", \"D\", \"E\"]\r\n```\r\n\r\n<hr id=\"user-content-map\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">map</a>\r\n```js\r\n/*\r\n  map 會處理數組的每一項並回傳新數組\r\n  方法內有兩個參數:1.函數、2.this參數(選填)\r\n  函數裡有可取得的三個參數:\r\n  1.該項的值\r\n  2.該項的索引值(選填)\r\n  3.當前數組(選填)\r\n*/\r\nlet test1 = [1,2,3,4,5,6,7,8].map(e => {\r\n    return e + 10;\r\n});\r\nconsole.log(test1); // [11, 12, 13, 14, 15, 16, 17, 18]\r\n\r\n// 注意:若要將函數this指向10不能使用箭頭函數\r\nlet test2 = [1,2,3,4,5,6,7,8].map(function(e){\r\n    return e + this; // 此處的 this 為 10\r\n}, 10);\r\nconsole.log(test2); // [11, 12, 13, 14, 15, 16, 17, 18]\r\n```\r\n\r\n<hr id=\"user-content-reduce-reduceright\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">reduce、reduceRight</a>\r\n```js\r\n/*\r\n reduce(左到右)、reduceRight(右到左)\r\n 會計算數組的每一項，每次結果會再與下一項做計算，直到結束\r\n 方法內有兩個參數:1.函數、2.初始計算值(選填)\r\n  函數裡有可取得的四個參數:\r\n  1.計算的值 \r\n  2.該項的值\r\n  3.該項的索引值(選填)\r\n  4.當前數組(選填)\r\n*/\r\nlet test1 = [1,2,3,4,5,6,7,8].reduce(function(total, e){\r\n    return total + e;\r\n});\r\nconsole.log(test1); // 36 ( 1+2+3+4+5+6+7+8=36 )\r\nlet test2 = [1,2,3,4,5,6,7,8].reduceRight(function(total, e){\r\n    return total - e;\r\n});\r\nconsole.log(test2); // -20 ( 8-7-6-5-4-3-2-1 = -20 )\r\n```\r\n\r\n<hr id=\"user-content-flat-flatMap\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">flat、flatMap</a>\r\n```js\r\n/*\r\n flat、flatMap(先 map 後 flat )\r\n flat 將多維數組轉成一維，\r\n 一個可選填參數，表示要轉換的深度，預設為1，\r\n 若深度有多層，可用Infinity展開成一維陣列\r\n*/\r\n// flat\r\nlet a = [1,2,[3],[4,[5,[6]]]];\r\nlet b = a.flat();\r\nlet c = a.flat(2);\r\nlet d = a.flat(Infinity);\r\nconsole.log(b);// [1, 2, 3, 4, [5, [6]]]\r\nconsole.log(c);// [1, 2, 3, 4, 5, [6]]\r\nconsole.log(d);// [1, 2, 3, 4, 5, 6]\r\n// flatMap\r\nlet a = [1,2,[3],[4,5]];\r\nlet b = a.flatMap(e => e+1);\r\nlet c = a.map(e => e+1).flat();\r\nconsole.log(b);  // [2, 3, \"31\", \"4,51\"]\r\nconsole.log(c);  // [2, 3, \"31\", \"4,51\"]\r\n```\r\n\r\n<hr id=\"user-content-array-from\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Array.from</a>\r\n- 將其他數據類型轉換成數組\r\n- 第一個參數放入要轉換數組的數據\r\n- 第二個參數放入函數用来對每個元素進行處理並將值放入返回的數組\r\n- 第三個參數為function裡面的this對象(若為箭頭函數則無this對象)\r\n- 以下條件皆可轉換成數組\r\n  - 可遍歷的 ```Array、String、Set、Map、NodeList、arguments```\r\n  - 擁有 length 属性的對象 ```const test = {a:1, b:2, c:3, length:3}```\r\n- 用法\r\n  ```js\r\n  console.log(Array.from('str'));// (3) ['s', 't', 'r']\r\n  // 第二個參數放入函數用来對每個元素進行處理\r\n  console.log(Array.from('12', value => value * 2));// [2, 4]\r\n  // 第三個參數為function裡面的this對象\r\n  Array.from(\r\n    '12',\r\n    function (value) {\r\n      console.log(this);// #document\r\n      console.log(value);// 依序印出 1 2\r\n    },\r\n    document\r\n  );\r\n  ```\r\n\r\n<hr id=\"user-content-array-every\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">every</a>\r\n```js\r\n/*\r\n  every 會將數組每一項帶入函式內做判斷，\r\n  若有任何一項不符合條件，回傳 false，\r\n  若全部符合，則回傳 true。\r\n*/\r\nlet test1 = [1,2,3,4,5,6];\r\nconsole.log(test1.every(e => e > 3));// false \r\nconsole.log(test1.every(e => e > 0));// true\r\n```\r\n\r\n<hr id=\"user-content-array-some\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">some</a>\r\n```js\r\n/*\r\n  some 會將數組每一項帶入函式內做判斷，\r\n  若有任何一項符合條件，回傳 true\r\n  若全部不符合，則回傳 false\r\n*/\r\nlet test1 = [1,2,3,4,5,6];\r\nconsole.log(test1.some(e => e > 3));// true \r\nconsole.log(test1.some(e => e < 0));// false\r\n```\r\n\r\n<hr id=\"user-content-array-includes\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">includes</a>\r\n- 判斷數組中是否有該成員\r\n- 第二個參數為搜索的起始位置，默認為0\r\n- 遵循嚴格相等(===)，並且 NaN 等於 NaN\r\n- 基本用法\r\n  ```js\r\n  // 判斷數組中是否有該成員\r\n  console.log([1, 2, 3].includes('2'));// false\r\n  console.log([1, 2, 3].includes(2));// true\r\n  // 第二個參數為搜索的起始位置，默認為0\r\n  console.log([1, 2, 3].includes(2, 2));// false\r\n  // 遵循嚴格相等(===)，並且 NaN 等於 NaN\r\n  console.log([1, 2, NaN].includes(NaN));// true\r\n  ```\r\n\r\n<hr id=\"user-content-array-isarray\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Array.isArray</a>\r\n```js\r\n/*\r\n  Array.isArray 能判斷一個物件是否為陣列，\r\n  如果是回傳 true，否則回傳 false。\r\n*/\r\nlet a = [1,2,3,4,5,6,7,8];\r\nlet b = 123;\r\nlet c = 'hello';\r\nlet d = {};\r\nconsole.log(Array.isArray(a)); // true\r\nconsole.log(Array.isArray(b)); // false\r\nconsole.log(Array.isArray(c)); // false\r\nconsole.log(Array.isArray(d)); // false\r\n```\r\n\r\n<hr id=\"user-content-function\" style=\"height: 4px;\">\r\n\r\n### 函數、DOM、BOM\r\n#### <a href=\"#user-content-top\">函數</a>\r\n#### <a href=\"#user-content-top\">作用域與變量</a>\r\n```js\r\n// 範例1\r\nvar a = 1;\r\nvar b = 2;\r\nfunction fun() {\r\n  // 查看函數內部是否有該變量若無則查找全局變量\r\n  c = 3;// 函數內不加var則轉變為全局變量\r\n  c++;\r\n  a++;// 函數內部查無a變量則以全局變量a為主角\r\n  var b = 4;\r\n  b++;\r\n  console.log(b);// 5\r\n}\r\nfun();\r\nconsole.log(a);// 2\r\nconsole.log(b);// 2\r\nconsole.log(c);// 可以訪問到變量c:4\r\n\r\n// 範例2(遮蔽效應)\r\nvar m = 1;\r\nfunction fun() {\r\n  m++;\r\n  console.log(m);// undefined + 1 = NaN\r\n  var m = 4; \r\n  console.log(m);// 4\r\n}\r\nfun();\r\nconsole.log(m);// 1\r\n\r\n// 範例3(作用域)\r\nvar a = 10;\r\nvar b = 20;\r\nfunction fun() {\r\n  var c = 30;\r\n  function inner() {\r\n    var a = 40;\r\n    var d = 50;\r\n    // 從裡到外尋找變量\r\n    console.log(a, b, c, d);// 40 20 30 50\r\n  }\r\n  inner();\r\n}\r\nfun();\r\n```\r\n\r\n<hr id=\"user-content-function-promotion\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">函數優先提升</a>\r\n```js\r\n// 函數會被提升至最上方\r\nfun();// B\r\n\r\nvar fun = function () {\r\n  console.log('A');\r\n};\r\n\r\nfunction fun() {\r\n  console.log('B');\r\n}\r\n\r\nfun();// A\r\n```\r\n\r\n<hr id=\"user-content-function-use\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">函數的使用</a>\r\n```js\r\n// 1.函數內可定義參數\r\nfunction add(a, b, c) {\r\n  var sum = a + b + c;\r\n  console.log(sum);\r\n}\r\n// 定義函數需被呼叫才會執行\r\nadd(4, 5, 5);// 14\r\nadd(2, 2);// NaN\r\nadd(6, 3, 2, 4);// 11\r\n\r\n// 2.如果 return 後面沒有返回值，默認返回 undefined\r\nfunction sum(a, b) {\r\n  return a + b;\r\n}\r\nvar result = sum(3, 4);\r\nconsole.log(result);// 7\r\n\r\n// 3.arguments\r\n/*\r\n  arguments 類似數組(對象)，但並非真正的數組(對象)\r\n  arguments.length 可以獲得參數的數量\r\n  arguments[0] 括號裡面放索引可以取得參數值 \r\n*/\r\n// 計算參數總和\r\nfunction fun() {\r\n  var sum = 0;\r\n  for (var i = 0; i < arguments.length; i++) {\r\n    sum += arguments[i];\r\n  }\r\n  console.log('參數和=' + sum);\r\n}\r\n```\r\n\r\n<hr id=\"user-content-closure\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">閉包</a>\r\n```js\r\n// 1.封裝函數來使用私有變量\r\nfunction fun() {\r\n  // 定義局部(私有)變量\r\n  var a = 0;\r\n  return {\r\n    getA: function () {\r\n      return a;\r\n    },\r\n    add: function () {\r\n      a++;\r\n    },\r\n    pow: function () {\r\n      a *= 2;\r\n    }\r\n  };\r\n}\r\nvar obj = fun();\r\nconsole.log(obj.getA());// 0\r\n// 操作私有變量\r\nobj.add();\r\nobj.add();\r\nobj.add();\r\nconsole.log(obj.getA());// 3\r\nobj.pow();\r\nconsole.log(obj.getA());// 6\r\n\r\n// 2.內部函數呼叫\r\n// 創建一個函數\r\nfunction fun() {\r\n    // 定義局部變量\r\n    var name = 'test';\r\n    // 輸出局部變量\r\n    return function () {\r\n        console.log(name);\r\n    };\r\n}\r\n// 獲得內部函數，使用變量inn接收\r\nvar inn = fun();\r\n// 定義全局變量\r\nvar name = 'ABC';\r\n// 執行inn函數，相當於在fun函數的外部，执行了内部函数\r\ninn();// test\r\n\r\n// 3.閉包的記憶性\r\nfunction createCheckTemp(standardTemp) {\r\n  function checkTemp(n) {\r\n    if (n <= standardTemp) {\r\n      console.log('體溫正常');\r\n    } else {\r\n      console.log('體溫偏高');\r\n    }\r\n  }\r\n  return checkTemp;\r\n}\r\n// 以 37.1 度為標準\r\nvar checkTemp_A = createCheckTemp(37.1);\r\n// 以 37.3 度為標準\r\nvar checkTemp_B = createCheckTemp(37.3);\r\ncheckTemp_A(37.2);// 體溫偏高\r\ncheckTemp_B(37.2);// 體溫正常\r\n```\r\n\r\n<hr id=\"user-content-iife\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">IIFE</a>\r\n- 用處\r\n  - 1.可以避免裡面的變數影響到全域\r\n  - 2.JavaScript 引擎看到即立刻轉譯該 function\r\n- 變量賦值\r\n  ```js\r\n  (function () {\r\n      var name = \"Barry\";\r\n  })();\r\n  console.log(name);// Uncaught ReferenceError: name is not defined\r\n\r\n  var result = (function () {\r\n      var name = \"Barry\";\r\n      return name;\r\n  })();\r\n  // Immediately creates the output:\r\n  console.log(result); // \"Barry\"\r\n  ```\r\n- 全局轉換局部變量\r\n  ```js\r\n  var arr = [];\r\n  for (var i = 0; i < 5; i++) {\r\n    //使用IIFE將全局變量輸入至函數裡面作為局部變量使用\r\n    //若不使用IIFE則全部輸出都為5\r\n    (function(i){\r\n        arr.push(function () {\r\n            console.log(i);\r\n        });\r\n    })(i);\r\n  }\r\n  arr[0]();\r\n  arr[1]();\r\n  arr[2]();\r\n  arr[3]();\r\n  arr[4]();\r\n  ```\r\n\r\n<hr id=\"user-content-arrow-function\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">箭頭函數</a>\r\n- 主要為簡化函數表達式\r\n- 適用於非方法的函式，但不能被用作建構式\r\n- 結構\r\n  - ``` const/let 函數名 = 參數 => 函數體```\r\n- 注意事項\r\n  - 單個參數可以省略小括號\r\n    - ```const add = x => { return x + 1; };```\r\n  - 無參數或多個參數不能省略小括號\r\n    - ```const add = () => { return 1 + 1; };```\r\n    - ```const add = (x, y) => { return x + y; };```\r\n  - 單行函數體可同時省略大括號和return\r\n    - ```const add = (x, y) => x + y;```\r\n  - 箭頭函數沒有自己的 ```this``` 對象(會往上一層找 ```this``` 對象)\r\n    - 相當於嚴格模式 ```use strict``` 下的一般函數\r\n  - 箭頭函數中沒有 ```arguments```\r\n\r\n\r\n<hr id=\"user-content-dom\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">DOM</a>\r\n#### <a href=\"#user-content-top\">簡介</a>\r\n- DOM ( Document Object Model，文檔對象模型 )\r\n- 是 JS 操作 HTML 文檔的接口\r\n- 特點為將文檔表示為節點樹\r\n\r\n<hr id=\"user-content-onload\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">onload 使用</a>\r\n```html\r\n<head>\r\n  <script>\r\n    // 通常js會寫在html後面,若要寫在前面則使用 window.onload\r\n    // 給 window 對象添加 onload 事件監聽。\r\n    // onload 表示頁面都加載完畢。\r\n    window.onload = function () {\r\n      // 得到盒子1(取得第一個id元素)\r\n      var box1 = document.getElementById('box1');\r\n      // 得到盒子2\r\n      var box2 = document.getElementById('box2');\r\n\r\n      console.log(box1);\r\n      console.log(box2);\r\n      // 輸出class名\r\n      console.log(box1.className);\r\n      // 可以替換class名\r\n      box1.className = 'test1'\r\n      console.log(box1.className);\r\n    };\r\n  <\/script>\r\n</head>\r\n\r\n<body>\r\n  <div id=\"box1\" class=\"box1\">我是盒子1</div>\r\n  <div id=\"box2\">我是盒子2</div>\r\n</body>\r\n```\r\n\r\n<hr id=\"user-content-get-element\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">常用訪問節點方法</a>\r\n| 語法 | 功能 | 兼容性 |\r\n| :-- | :-- | :-- |\r\n| ```document.getElementById()``` | 通過 ```id``` 得到元素 | IE6 |\r\n| ```document.getElementsByTagName()``` | 通過 ```標籤名``` 得到元素數組 | IE6 |\r\n| ```document.getElementsByClassName()``` | 通過 ```類名``` 得到元素數組 | IE9 |\r\n| ```document.querySelector()``` | 通過 ```選擇器``` 得到元素 | IE9，IE8部分兼容 |\r\n| ```document.querySelectorAll()``` | 通過 ```選擇器``` 得到元素數組 | IE9，IE8部分兼容 |\r\n\r\n- 範例\r\n  ```js\r\n  // 先得到box1(取得第一個id元素)\r\n  var box1 = document.getElementById('box1');\r\n  // 得到box1中的p標籤的數組\r\n  var ps_inbox1 = box1.getElementsByTagName('p');\r\n  // 若不指定則取得全部p元素\r\n  var p = document.getElementsByTagName('p');\r\n\r\n  // 只能得到頁面上的一個元素(有多個則取第一個)\r\n  // 使用css語法\r\n  var the_p = document.querySelector('#box p:nth-child(1)');\r\n\r\n  // 返回一個元素數組 NodeList\r\n  var lis_inlist1 = document.querySelectorAll('#list1 li');\r\n  ```\r\n\r\n<hr id=\"user-content-node-type\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">nodeType 常用屬性值</a>\r\n| 屬性值 | 節點類型 |\r\n| :-- | :-- |\r\n| 1 | 元素節點(如 ```<p>```) |\r\n| 3 | 文本節點 |\r\n| 8 | 註釋節點 |\r\n| 9 | document節點 |\r\n| 10 | DTD節點 |\r\n\r\n- 使用方式\r\n  ```js\r\n  var box = document.getElementById('box');\r\n  var para = document.getElementById('para');\r\n\r\n  // 該節點屬性值\r\n  console.log(box.nodeType);\r\n  // 第一個子節點屬性值\r\n  console.log(box.firstChild.nodeType);\r\n  ```\r\n\r\n<hr id=\"user-content-node-attributes\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">節點屬性</a>\r\n| 關係 | 所有節點 | 只考慮元素節點 |\r\n| :-- | :-- | :-- |\r\n| 子節點 | childNodes | children |\r\n| 父節點 | parentNode | 一樣 |\r\n| 第一個子節點 | firstChild | firstElementChild |\r\n| 最後一個子節點 | lastChild | lastElementChild |\r\n| 前面一個兄弟節點 | previousSibling | previousElementSibling |\r\n| 後面一個兄弟節點 | nextSibling | nextElementSibling |\r\n\r\n- 使用方式\r\n  ```js\r\n  var box = document.getElementById('box');\r\n  var para = document.getElementById('para');\r\n\r\n  // 所有子節點\r\n  console.log(box.childNodes);\r\n  // 所有的元素子節點（IE9開始兼容）\r\n  console.log(box.children);\r\n  // 若裡面標籤有id則可以直接調用\r\n  console.log(box.children.para);\r\n  // 第一個子節點\r\n  console.log(box.firstChild);\r\n  // 第一個元素子節點（IE9開始兼容）\r\n  console.log(box.firstElementChild);\r\n  // 最後一個子節點\r\n  console.log(box.lastChild);\r\n  // 最後一個元素子節點（IE9開始兼容）\r\n  console.log(box.lastElementChild);\r\n  // 父節點\r\n  console.log(para.parentNode);\r\n  // 前一個兄弟節點\r\n  console.log(para.previousSibling);\r\n  // 前一個元素兄弟節點（IE9開始兼容）\r\n  console.log(para.previousElementSibling);\r\n  // 後一個兄弟節點\r\n  console.log(para.nextSibling);\r\n  // 後一个元素兄弟節點（IE9開始兼容）\r\n  console.log(para.nextElementSibling);\r\n  ```\r\n<hr id=\"user-content-node-operate\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">節點操作</a>\r\n- 創建與移動節點\r\n  ```js\r\n  var oBox = document.getElementById('box');\r\n  var oPs = oBox.getElementsByTagName('p');\r\n  // 創建節點\r\n  var oP = document.createElement('p');\r\n  // 設置文字\r\n  oP.innerText = '我是新来的';\r\n  // 移動節點:連同後代一起移動\r\n  // appendChild:增加至父標籤的最後\r\n  oBox.appendChild(oP);\r\n  // insertBefore(a,b):將a元素插入在b元素之前\r\n  oBox.insertBefore(oP, oPs[0]);\r\n  ```\r\n\r\n- 克隆節點\r\n  ```js\r\n  var box1 = document.getElementById('box1');\r\n  var box2 = document.getElementById('box2');\r\n  var theul = box1.getElementsByTagName('ul')[0];\r\n  // true代表後代節點都會被克隆,若不要深克隆則寫cloneNode()\r\n  var new_ul = theul.cloneNode(true);\r\n  box2.appendChild(new_ul);\r\n  ```\r\n\r\n- 刪除節點\r\n  ```js\r\n  var box = document.getElementById('box');\r\n  var the_first_p = box.getElementsByTagName('p')[0];\r\n  // 必須由父親刪除(會連同裡面後代一起刪除)\r\n  box.removeChild(the_first_p);\r\n  ```\r\n\r\n- 更改節點內容\r\n  ```js\r\n  var oBox = document.getElementById('box');\r\n  var oBox2 = document.getElementById('box2');\r\n  /*\r\n    innerHTML 與 innerText: \r\n    獲取元素的開始和結束標籤之間的內容\r\n    也可以通過innerHTML重新設置元素中的內容\r\n  */\r\n  // 下面兩個只差在是否取得含html標籤內容\r\n  console.log(oBox2.innerHTML)// 123 <p>456</p>789\r\n  console.log(oBox2.innerText)// 123 456 789\r\n  ```\r\n\r\n- 更改節點css樣式\r\n  ```js\r\n  // 使用 style 更改節點內容樣式\r\n  var oBox = document.getElementById('box');\r\n  oBox.style.fontSize = '50px';\r\n  ```\r\n\r\n- 更改非特殊節點屬性\r\n  ```js\r\n  var box = document.getElementById('box');\r\n  box.setAttribute('data-n', 10);\r\n  var n = box.getAttribute('data-n');\r\n  console.log(n);// 10\r\n  ```\r\n\r\n- 更改特殊節點屬性\r\n  ```html\r\n  <img src=\"image.jpg\" id=\"pic\">\r\n  <a href=\"https://www.google.com/\" id=\"link\">google</a>\r\n\r\n  <script>\r\n    var oPic = document.getElementById('pic');\r\n    // setAttribute 也可以替換(只是通常是用在非w3c標準屬性)\r\n    // oPic.setAttribute('src','image2.jpg');\r\n    oPic.src = 'image2.jpg';\r\n\r\n    var oLink = document.getElementById('link');\r\n    oLink.href = 'https://github.com/';\r\n    oLink.innerText = 'github';\r\n  <\/script>\r\n  ```\r\n\r\n<hr id=\"user-content-node-customize\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">節點自定義屬性</a>\r\n- 簡介\r\n  ```txt\r\n  HTML5 添加 data-n 方式來自定義屬性，n可以換成自定義屬性名\r\n  使用這樣的結構可進行數據存放，並且方便好管理\r\n  ```\r\n\r\n- 定義方式\r\n  - html 標籤\r\n    ```html\r\n    <h2 data-weather=\"rain\"></h2>\r\n    \x3c!-- 若有多重名詞組成則用 - 分開 --\x3e\r\n    <h2 data-number-two=\"2\"></h2>\r\n    ```\r\n  - js\r\n    ```js\r\n    var h2 = document.querySeletor('h2');\r\n    h2.dataset.weather = \"rain\";\r\n    // 若有多重名詞則用駝峰命名法書寫\r\n    h2.dataset.numberTwo = '2';\r\n    ```\r\n\r\n- 讀取自定義屬性\r\n  - js\r\n    ```html\r\n    <h2 data-weather=\"rain\" data-number-two=\"2\"></h2>\r\n    <script>\r\n      var h2 = document.querySeletor('h2');\r\n      console.log(h2.dataset.weather);// rain\r\n      console.log(h2.dataset.numberTwo);// 2\r\n    <\/script>\r\n    ```\r\n  - css\r\n    ```html\r\n    <style>\r\n      h2[data-number-two=\"2\"]{\r\n        color: green;\r\n      }\r\n    </style>\r\n    <h2 data-weather=\"rain\" data-number-two=\"2\"></h2>\r\n    ```\r\n\r\n<hr id=\"user-content-event-listener\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">事件監聽</a>\r\n#### <a href=\"#user-content-top\">表單</a>\r\n- 常用事件監聽\r\n\r\n  | 事件名 | 事件描述 |\r\n  | :-- | :-- |\r\n  | onchange | 當用戶改變內容(onchange => onblur) |\r\n  | onfocus | 當元素獲得焦點 |\r\n  | onblur | 當元素失去焦點 |\r\n  | onsubmit | 當表單被提交 |\r\n  | onreset | 當表單被重置 |\r\n  | oninput | 當用戶修改內容 |\r\n\r\n- 範例\r\n  ```html\r\n  <form id=\"myform\">\r\n    <p>\r\n      姓名：\r\n      <input type=\"text\" name=\"nameField\">\r\n    </p>\r\n    <p>\r\n      年齡：\r\n      <input type=\"text\" name=\"ageField\">\r\n    </p>\r\n    <p>\r\n      <input type=\"submit\">\r\n      <input type=\"reset\">\r\n    </p>\r\n  </form>\r\n\r\n  <script>\r\n    var myform = document.getElementById('myform');\r\n    var nameField = myform.nameField;\r\n    var ageField = myform.ageField;\r\n\r\n    nameField.onchange = function () {\r\n      console.log('已經修改完姓名');\r\n    };\r\n\r\n    nameField.oninput = function () {\r\n      console.log('正在修改姓名');\r\n    };\r\n\r\n    nameField.onfocus = function () {\r\n      console.log('姓名框得到焦點');\r\n    }\r\n\r\n    nameField.onblur = function () {\r\n      console.log('姓名框失去焦點');\r\n    }\r\n\r\n    myform.onsubmit = function () {\r\n      alert('正在嘗試提交表單');\r\n    }\r\n\r\n    myform.onreset = function () {\r\n      console.log('表單被重置');\r\n    }\r\n  <\/script>\r\n  ```\r\n\r\n<hr id=\"user-content-event-listener-page\" style=\"height: 1px;\">\r\n\r\n#### <a href=\"#user-content-top\">頁面</a>\r\n- 常用事件監聽\r\n\r\n  | 事件名 | 事件描述 |\r\n  | :-- | :-- |\r\n  | onload | 當頁面或圖像完成加載 |\r\n  | onunload | 當用戶退出頁面 |\r\n\r\n<hr id=\"user-content-event-listener-mouse\" style=\"height: 1px;\">\r\n\r\n#### <a href=\"#user-content-top\">鼠標</a>\r\n- 常用事件監聽\r\n\r\n  | 事件名 | 事件描述 |\r\n  | :-- | :-- |\r\n  | onclick | 鼠標```單擊```某個對象 |\r\n  | ondblclick | 鼠標```雙擊```某個對象 |\r\n  | onmousedown | 鼠標在某個對象被```按下``` |\r\n  | onmouseup | 鼠標在某個對象被```鬆開``` |\r\n  | onmousemove | 鼠標在某個對象```移動``` |\r\n  | onmouseenter | 鼠標```進入```某個對象(相似 onmouseover ) |\r\n  | onmouseleave | 鼠標```離開```某個對象(相似 onmouseout ) |\r\n\r\n- 取得鼠標位置\r\n\r\n  | 事件名 | 事件描述 |\r\n  | :-- | :-- |\r\n  | clientX | 鼠標指針對於```瀏覽器```的```水平```座標(含滾動內容) |\r\n  | clientY | 鼠標指針對於```瀏覽器```的```垂直```座標(含滾動內容) |\r\n  | pageX | 鼠標指針對於```整張網頁```的```水平```座標(不含滾動內容) |\r\n  | pageY | 鼠標指針對於```整張網頁```的```垂直```座標(不含滾動內容) |\r\n  | offsetX | 鼠標指針對於```事件元素```的```水平```座標(到區塊的邊界) |\r\n  | offsetY | 鼠標指針對於```事件元素```的```垂直```座標(到區塊的邊界) |\r\n\r\n- 範例\r\n  ```js\r\n  // 畫出一個區塊\r\n  var oBox = document.getElementById('box');\r\n  // 顯示座標\r\n  var oInfo = document.getElementById('info');\r\n  // 以區塊做標準，若超過區塊外則座標不更新\r\n  oBox.onmousemove = function (e) {\r\n    oInfo.innerHTML = \r\n      'offsetX/Y：' + e.offsetX + ',' + e.offsetY + '<br>'\r\n      + 'clientX/Y：' + e.clientX + ',' + e.clientY + '<br>'\r\n      + 'pageX/Y：' + e.pageX + ',' + e.pageY;\r\n  };\r\n  ```\r\n\r\n<hr id=\"user-content-event-listener-keybored\" style=\"height: 1px;\">\r\n\r\n#### <a href=\"#user-content-top\">鍵盤</a>\r\n- 常用事件監聽\r\n\r\n  | 事件名 | 事件描述 |\r\n  | :-- | :-- |\r\n  | onkeypress | 當鍵盤按鍵按下(無法識別系統按鍵如箭頭鍵) |\r\n  | onkeydown | 當鍵盤按鍵按下(可識別系統鍵並先於onkeypress觸發) |\r\n  | onkeyup | 當鍵盤按鍵被鬆開 |\r\n\r\n- charCode 字符碼\r\n  - ```e.charCode``` 常用於 ```onkeypress``` 事件\r\n\r\n  | 字符 | 字符碼 |\r\n  | :-- | :-- |\r\n  | 數字 0 ~ 9 | 48 ~ 57 |\r\n  | 大寫字母 A-Z | 65 ~ 90 |\r\n  | 小寫字母 a-z | 97 ~ 122 |\r\n\r\n- keyCode 鍵碼\r\n  - ```e.keyCode``` 常用於 ```onkeydown```與```onkeyup``` 事件\r\n\r\n  | 按鍵 | 鍵碼 |\r\n  | :-- | :-- |\r\n  | 數字 0 ~ 9 | 48 ~ 57 |\r\n  | 不區分大小寫 A-Z | 65 ~ 90 |\r\n  | 方向鍵(左、上、右、下) | 37、38、39、40 |\r\n  | Enter | 13 |\r\n  | 空白鍵 | 32 |\r\n\r\n- 範例\r\n  ```html\r\n  <input type=\"text\" id=\"field1\">\r\n  <h1 id=\"info1\"></h1>\r\n  <input type=\"text\" id=\"field2\">\r\n  <h1 id=\"info2\"></h1>\r\n\r\n  <script>\r\n    var oField1 = document.getElementById('field1');\r\n    var oInfo1 = document.getElementById('info1');\r\n    var oField2 = document.getElementById('field2');\r\n    var oInfo2 = document.getElementById('info2');\r\n\r\n    // 注意onkeypress不會監測系統鍵(如shift}\r\n    oField1.onkeypress = function (e) {\r\n      oInfo1.innerText = '你输入的字符的字符码是' + e.charCode;\r\n    };\r\n\r\n    oField2.onkeydown = function (e) {\r\n      oInfo2.innerText = '你按下的按键的键码是' + e.keyCode;\r\n    };\r\n  <\/script>\r\n  ```\r\n\r\n<hr id=\"user-content-event-listener-on-add\" style=\"height: 1px;\">\r\n\r\n#### <a href=\"#user-content-top\">on與addEventListener</a>\r\n- 冒泡 與 捕獲事件\r\n  - 捕獲事件由 ```外面``` 到 ```裡面``` 依序觸發\r\n  - 冒泡事件由 ```裡面``` 到 ```外面``` 依序觸發\r\n  - 先捕獲後冒泡\r\n    ```txt\r\n    假設有三個區域\r\n    由外到內分別為 box1、box2、box3\r\n    若點擊 box3 區域則順序為\r\n    box1捕獲 > box2捕獲 > box3捕獲 > \r\n    box3冒泡 > box2冒泡 > box1冒泡\r\n    ```\r\n  - 冒泡比如水波紋向外傳遞，捕獲則相反\r\n- onxxx 事件\r\n  - 為 DOM0級事件監聽\r\n  - 只會監聽到冒泡事件\r\n  - 後面會取代前面有同元素同樣的on事件\r\n- addEventListener 事件\r\n  - 為 DOM2級事件監聽\r\n  - 相同事件不會被覆蓋\r\n  - onxxx 事件不用加上 on，如 ```onclick => click```\r\n  - 第二個參數 \r\n    true：監聽捕獲階段\r\n    false：監聽冒泡階段\r\n  - 範例\r\n    ```js\r\n    var oBox2 = document.getElementById('box2');\r\n    oBox2.addEventListener('click', function() {\r\n      console.log('click');\r\n    }, false);\r\n    ```\r\n- stopPropagation 阻止事件傳播\r\n  ```js\r\n  oBtn.onclick = function (e) {\r\n    // 阻止事件繼續傳播\r\n    e.stopPropagation();\r\n    console.log('我是按鈕');\r\n  };\r\n\r\n  oBox.addEventListener('click', function(e) {\r\n    // 阻止事件繼續傳播\r\n    e.stopPropagation();\r\n    console.log('我是盒子');\r\n  }, true);\r\n  ```\r\n- preventDefault 阻止預設功能觸發\r\n  ```js\r\n  var oField = document.getElementById('field');\r\n  oField.onkeypress = function (e) {\r\n    console.log(e.charCode);\r\n    if (!(e.charCode >= 48 && e.charCode <= 57 || e.charCode >= 97 && e.charCode <= 122)) {\r\n      /*\r\n        若使用者不是輸入\r\n        數字 0~9，字符碼 48 ~ 57\r\n        小寫字母 a~z，字符碼 97 ~ 122\r\n        則輸入框不會出現該字碼文字\r\n      */\r\n      e.preventDefault();\r\n    }\r\n  };\r\n  ```\r\n\r\n<hr id=\"user-content-event-listener-entrust\" style=\"height: 1px;\">\r\n\r\n#### <a href=\"#user-content-top\">事件委託</a>\r\n- 使用時機\r\n  - 需要批量增加監聽事件，使用委託可減少內存開銷\r\n  - 當有動態元素上元素樹時，會自動具有事件監聽功能\r\n- target 與 currentTarget\r\n  - target：觸發事件最早的元素，即\"事件源元素\"\r\n  - currentTarget：事件處理程序附加到的元素(this)\r\n- 範例\r\n  ```html\r\n  <button id=\"btn\">按我创建一个新列表项</button>\r\n  <ul id=\"list\">\r\n    <li>列表项</li>\r\n    <li>列表项</li>\r\n    <li>列表项</li>\r\n  </ul>\r\n  <script>\r\n    var oList = document.getElementById('list');\r\n    var oBtn = document.getElementById('btn');\r\n\r\n    // onmouseenter 會使該DOM節點觸發自己的事件並無冒泡\r\n    // 若換成 onmouseenter 就會一次全部變成紅色\r\n    oList.onmouseover = function (e) {\r\n      // 避免觸發ul一次變紅\r\n      e.currentTarget.style.color = '';\r\n      // e.target表示使用者真正點擊的元素\r\n      e.target.style.color = 'red';\r\n    };\r\n\r\n    oBtn.onclick = function () {\r\n      // 創建新的li元素\r\n      var oLi = document.createElement('li');\r\n      // 加入內容\r\n      oLi.innerText = '我是新来的';\r\n      // 上文檔樹\r\n      oList.appendChild(oLi);\r\n    };\r\n  <\/script>\r\n  ```\r\n\r\n<hr id=\"user-content-async-statment\" style=\"height: 1px;\">\r\n\r\n#### <a href=\"#user-content-top\">異步語句</a>\r\n- setInterval 與 clearInterval\r\n  - setInterval \r\n    - 設定每隔一段時間執行函數(無限循環)\r\n    - 可以接收多個參數並按順序傳入函數\r\n  - clearInterval\r\n    - 解除定時器\r\n  - 範例\r\n    ```js\r\n    var a = 0;\r\n    // 無設定參數\r\n    setInterval(function () {\r\n      console.log(++a);\r\n    }, 1000);\r\n    // 設定參數\r\n    var timer = setInterval(function (b, c) {\r\n      console.log(b);// 88\r\n      console.log(c);// 66\r\n    }, 1000, 88, 66);\r\n    // 解除定時器\r\n    clearInterval(timer);\r\n    ```\r\n- setTimeout 與 clearTimeout\r\n  - setTimeout\r\n    - 隔一段時間後執行函數(只執行一次)\r\n    - 一樣可以接收多個參數並按順序傳入函數\r\n  - clearTimeout\r\n    - 解除定時器\r\n    - 只有未執行函數時才有作用\r\n  - 範例\r\n    ```js\r\n    var btn1 = document.getElementById('btn1');\r\n    var btn2 = document.getElementById('btn2');\r\n    var timer;\r\n\r\n    btn1.onclick = function () {\r\n      timer = setTimeout(function () {\r\n        console.log('你好');\r\n      }, 2000);\r\n    }\r\n\r\n    btn2.onclick = function () {\r\n      clearTimeout(timer);\r\n    }\r\n    ```\r\n\r\n<hr id=\"user-content-bom\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">BOM</a>\r\n#### <a href=\"#user-content-top\">簡介</a>\r\n- BOM(Browser Object Model)為瀏覽器對象模型\r\n- 核心為window對象，全局變量與函數皆包含在內\r\n- 窗口尺寸相關屬性\r\n  - ```innerWidth``` 窗口內寬(含滾動條)\r\n  - ```innerHeight``` 窗口內高(含滾動條)\r\n  - ```outerWidth``` 窗口外寬(含滾動條與瀏覽器邊框)\r\n  - ```outerHeight``` 窗口外高(含滾動條與瀏覽器邊框)\r\n  - ```document.documentElement.clientWidth``` 窗口內寬(不含滾動條)\r\n  - ```document.documentElement.clientHeight``` 窗口內高(不含滾動條)\r\n  - ```scrollTop``` 與 ```scrollY``` 代表已捲動的長度\r\n    - ```document.documentElement.scrollTop``` 可讀可寫\r\n    - ```window.scrollY``` 只能讀取\r\n    - 常用寫法\r\n      ```js\r\n      var scrollTop = \r\n          window.scrollY || \r\n          document.documentElement.scrollTop;\r\n      ```\r\n- resize 事件\r\n  - 當窗口改變大小時觸發\r\n  - 範例\r\n    ```js\r\n    window.onresize = function () {\r\n      var root = document.documentElement;\r\n      console.log(\r\n        '窗口改變尺寸了',\r\n        root.clientWidth,\r\n        root.clientHeight\r\n      );\r\n    };\r\n    ```\r\n- scroll 事件\r\n  - 當窗口滾動時觸發\r\n  - 範例\r\n    ```js\r\n    window.onscroll = function () {\r\n      console.log('窗口捲動了', window.scrollY);\r\n    };\r\n    ```\r\n- hasOwnProperty 查看屬性是否存在\r\n  ```js\r\n  var a = 3;\r\n  console.log(window.hasOwnProperty('a')); // true\r\n  console.log(window.a);  // 3\r\n  ```\r\n\r\n<hr id=\"user-content-history\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">History 對象</a>\r\n- window.history 對象提供操作瀏覽器會話歷史的接口\r\n- 常用功能如下\r\n  - ```history.back()``` 等於瀏覽器回退按鈕\r\n  - ```history.go(-1)``` 等同於 ```history.back()```\r\n- 範例\r\n  ```js\r\n  /*\r\n    go(-1)表示加载上一個頁面\r\n    go(1)表示加載下一個頁面\r\n    back()表示加载上一個頁面\r\n  */\r\n  var btn = document.getElementById('btn');\r\n  btn.onclick = function () {\r\n    // history.back();\r\n    history.go(-1);\r\n  };\r\n  ```\r\n\r\n<hr id=\"user-content-location\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Location 對象</a>\r\n- window.location 標示當前所在網址\r\n- 可透過該屬性賦值使瀏覽器跳轉\r\n  - ```window.location = 'https://www.google.com';```\r\n  - ```window.location.href = 'https://www.google.com';```\r\n- search 屬性\r\n  - 可以取得get請求的查詢參數\r\n  - 範例\r\n    ```js\r\n    // 若網址為: https://www.google.com?a=1&b=2\r\n    console.log(window.location.search);// \"?a=1&b=2\"\r\n    ```\r\n\r\n<hr id=\"user-content-navigator\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Navigator 對象</a>\r\n- navigator 對象具有使用者此次活動的瀏覽器相關屬性與標識\r\n- 有以下幾個常用屬性\r\n  - ```navigator.language``` 瀏覽器設定的語系\r\n  - ```navigator.cookieEnabled``` 瀏覽器cookie功能是否開啟\r\n  - ```navigator.javaEnabled()``` 瀏覽器是否允許 Java 程式\r\n  - ```navigator.appName``` 瀏覽器官方名稱\r\n  - ```navigator.appVersion``` 瀏覽器版本\r\n  - ```navigator.userAgent``` 瀏覽器完整的版本資訊\r\n  - ```navigator.platform``` 用戶操作系統\r\n  - ```navigator.vendor``` 瀏覽器廠商名稱\r\n\r\n<hr id=\"user-content-offsettop\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">offsetTop 屬性</a>\r\n- 計算該元素到上邊界的距離\r\n- 若父層有定位則計算到父元素的邊界\r\n- 範例\r\n  ```html\r\n  <style>\r\n    #box {\r\n      width: 400px;\r\n      height: 400px;\r\n      margin: 60px auto;\r\n      border: 4px solid red;\r\n    }\r\n\r\n    ul {\r\n      padding-top: 10px;\r\n    }\r\n\r\n    li {\r\n      padding-top: 10px;\r\n    }\r\n\r\n    #para {\r\n      width: 80px;\r\n      height: 80px;\r\n      background-color: orange;\r\n    }\r\n  </style>\r\n  </head>\r\n\r\n  <body>\r\n    <div id=\"box\">\r\n      <ul>\r\n        <li>\r\n          <p id=\"para\"></p>\r\n        </li>\r\n      </ul>\r\n    </div>\r\n    <script>\r\n      var para = document.getElementById('para');\r\n      // 計算top值\r\n      // 若 #box  加 position 屬性則輸出 20\r\n      //        沒加 position 屬性則輸出 84\r\n      console.log(para.offsetTop);\r\n    <\/script>\r\n  </body>\r\n  ```\r\n\r\n<hr id=\"user-content-object-based\" style=\"height: 4px;\">\r\n\r\n### 基於對象、正則表達式\r\n#### <a href=\"#user-content-top\">基於對象</a>\r\n#### <a href=\"#user-content-top\">簡介</a>\r\n- 面向對象與基於對象差別\r\n  - 基於對象(object-based)\r\n    - 基於對象的語言支持對象和封裝的使用。\r\n    - 它們不支持繼承或多態性或兩者。\r\n    - 基於對象的語言不支持內置對象。\r\n  - 面向對象(object-oriented)\r\n    - 面向對象語言支持 Oops 的所有特性，包括繼承和多態。\r\n    - 它們支持內置對象。\r\n\r\n<hr id=\"user-content-about-object\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">關於對象</a>\r\n- 對象基本使用\r\n  ```js\r\n  var xiaoming = {\r\n    name: '小明',\r\n    age: 12,\r\n    sex: '男',\r\n    hobbies: ['足球', '编程'],\r\n    // 不符合命名規範須以引號包裹\r\n    'favorite-book': '舒克和贝塔'\r\n  };\r\n\r\n  console.log(xiaoming.name);// 小明\r\n  console.log(xiaoming.age);// 12\r\n  console.log(xiaoming.sex);// 男\r\n  console.log(xiaoming.hobbies);// (2) ['足球', '编程']\r\n  // 不符合命名規範須用方括號取值\r\n  console.log(xiaoming['favorite-book']);\r\n\r\n  var key = 'sex';\r\n  // 如果用變量來呼叫對象則須用方括號\r\n  console.log(xiaoming[key]);\r\n  // 對象是引用類型值\r\n  // 例子1\r\n  var obj1 = {\r\n    a: 1, b: 2, c: 3\r\n  };\r\n  var obj2 = {\r\n    a: 1, b: 2, c: 3\r\n  };\r\n  console.log(obj1 == obj2); // false\r\n  console.log(obj1 === obj2);// false\r\n  console.log({} == {});     // false\r\n  console.log({} === {});    // false\r\n  // 例子2\r\n  var obj3 = {\r\n    a: 10\r\n  };\r\n  var obj4 = obj3;\r\n  obj3.a++;\r\n  console.log(obj4);// {a: 11}\r\n  ```\r\n\r\n- 包裝類\r\n  - 讓基本類型值可以從它們的構造函數prototype上獲得方法\r\n  - 範例\r\n    ```js\r\n    var a = new Number(123);\r\n    var b = new String('test');\r\n    var c = new Boolean(true);\r\n\r\n    // 包裝後會變為對象\r\n    console.log(typeof a);// object\r\n    console.log(typeof b);// object\r\n    console.log(typeof c);// object\r\n    console.log(5 + a);// 128\r\n    console.log(b.slice(0, 2));// 'te'\r\n    console.log(c && true);// true\r\n\r\n    var d = 123;\r\n    console.log(d.__proto__ == Number.prototype);// true\r\n    var e = 'test';\r\n    console.log(e.__proto__ == String.prototype);// true\r\n\r\n    // 查看自己是否擁有該方法\r\n    console.log(String.prototype.hasOwnProperty('toLowerCase'));// true\r\n    console.log(String.prototype.hasOwnProperty('slice'));// true\r\n    console.log(String.prototype.hasOwnProperty('substr'));// true\r\n    console.log(String.prototype.hasOwnProperty('substring'));// true\r\n    ```\r\n\r\n- 對象方法\r\n  ```js\r\n  // 設置對象的方法\r\n  var xiaoming = {\r\n    name: '小明',\r\n    age: 12,\r\n    sex: '男',\r\n    sayHello: function () {\r\n      console.log(this.sex);\r\n    },\r\n    sleep: function () {\r\n      console.log('sleep');\r\n    }\r\n  };\r\n  // 調用對象的方法\r\n  xiaoming.sayHello();\r\n  ``` \r\n\r\n- 淺克隆與深克隆\r\n  - 淺克隆\r\n    ```js\r\n    var obj1 = {\r\n      a: 1,\r\n      b: 2,\r\n      c: [44, 55, 66]\r\n    };\r\n\r\n    // 實現淺克隆\r\n    var obj2 = {};\r\n    for (var k in obj1) {\r\n      obj2[k] = obj1[k];\r\n    }\r\n    console.log(obj1.c == obj2.c);// true 證明了數組為同一個對象\r\n    ```\r\n  - 深克隆\r\n    ```js\r\n    function deepClone(o) {\r\n      var result\r\n      // 判断是對象還是數組\r\n      if (Array.isArray(o)) {\r\n        // 數組\r\n        result = [];\r\n        for (var i = 0; i < o.length; i++) {\r\n          result.push(deepClone(o[i]));\r\n        }\r\n      } else if (typeof o == 'object') {\r\n        // 因為typeof數組會顯示object，所以要先判斷是否為數組才能判斷對象)\r\n        result = {};\r\n        for (var k in o) {\r\n          result[k] = deepClone(o[k]);\r\n        }\r\n      } else {\r\n        // 基本类型值\r\n        result = o;\r\n      }\r\n      return result;\r\n    }\r\n    ```\r\n\r\n- 對象屬性新增修改與刪除\r\n  ```js\r\n  var obj = {\r\n    a: 10,\r\n    b: 20\r\n  };\r\n\r\n  // 修改屬性\r\n  obj.b = 40;\r\n  obj.b++;\r\n  console.log(obj.b);\r\n\r\n  // 新增屬性\r\n  obj.c = 60;\r\n  console.log(obj);\r\n\r\n  // 删除屬性\r\n  delete obj.a;\r\n  console.log(obj);\r\n  ```\r\n\r\n<hr id=\"user-content-constructor-object\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">構造函數與對象</a>\r\n```js\r\n// 通常習慣將首字母大寫的函數定義為構造函數(方便辨認)\r\nfunction People(name, age, sex) {\r\n  this.name = name;\r\n  this.age = age;\r\n  this.sex = sex;\r\n  this.sayHello = function () {\r\n    console.log('你好，我是' + this.name);\r\n  };\r\n  // 不管有無return都會返回 this(對象)\r\n}\r\n// 用new關鍵字初始創建對象:{}\r\nvar test1 = new People('小明', 12, '男');\r\n// {name: '小明', age: 12, sex: '男', sayHello: ƒ}\r\nconsole.log(test1);\r\ntest1.sayHello();\r\n```\r\n\r\n<hr id=\"user-content-object-prototype\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">原型原型鏈</a>\r\n- prototype的使用與省內存\r\n  ```js\r\n  // 若方法寫在函數本身裡面則實例化一個對象就會多佔一次內存\r\n  function People(name, age, sex) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.sex = sex;\r\n  }\r\n  // 將方法寫在原型上就不會因實例化而佔內存\r\n  People.prototype.sayHello = function () {\r\n    console.log('你好，我是' + this.name);\r\n  }\r\n  People.prototype.growup = function () {\r\n    this.age++;\r\n  }\r\n  // 也可以往原型上新增屬性\r\n  People.prototype.nationality = '美國';\r\n  var test1 = new People('小明', 12, '男');\r\n  var test2 = new People('小红', 11, '女');\r\n  // 查找該屬性是否存在\r\n  'nationality' in test1;// true\r\n\r\n  // 因函數為引用類型可以觀察是否調用同一個方法\r\n  // 若方法放在函數內部會因實例化而調用該實例方法: false\r\n  console.log(test1.sayHello === test2.sayHello);//true\r\n  console.log(test1.__proto__.sayHello === test2.__proto__.sayHello);// true\r\n  ```\r\n\r\n- 實現繼承\r\n  ```js\r\n  // 創建父類\r\n  function People(name, age, sex) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.sex = sex;\r\n  }\r\n  // 將方法寫在原型上就不會因實例化而佔內存\r\n  People.prototype.sayHello = function () {\r\n    console.log('你好，我是' + this.name);\r\n  }\r\n  People.prototype.sleep = function () {\r\n    console.log(this.name + '睡覺，zzzzz');\r\n  };\r\n  // 子類(須含有父類所有參數，若漏掉其中一個就使用父類prototype方法會抱錯)\r\n  function Student(name, age, sex, school, studentNumber) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.sex = sex;\r\n    this.school = school;\r\n    this.studentNumber = studentNumber;\r\n  }\r\n  // ***用子類原型繼承父類(繼承不需填參數)***\r\n  Student.prototype = new People();\r\n  // 覆寫（override）父類方法\r\n  Student.prototype.sayHello = function () {\r\n    console.log('你好我是' + this.name);\r\n  }\r\n  // 實例化\r\n  var test = new Student('test', 29, '男', '學校', 100556);\r\n  // 呼叫使用父類方法\r\n  test.sleep();// test睡覺，zzzzz\r\n  // 另外若有填參數，創建的Student對象也不會使用\r\n  Student.prototype = new People('test2',20,'yyy');\r\n  var test = new Student();\r\n  test.sleep();// undefined睡覺，zzzzz\r\n  test.__proto__.sleep();// test2睡覺，zzzzz\r\n\r\n  /*\r\n    整體繼承流程\r\n    1.創建父類(父類的prototype若無繼承則為object)\r\n    2.創建父類實例\r\n    3.創建子類\r\n    4.將子類的prototype指向父類實例(形成繼承)\r\n\r\n    以上完成會形成以下三角關係\r\n                prototype\r\n      子類 ---------------\x3e 父類實例\r\n        ＼ <--------------    ／\r\n          ＼   constructor  ／\r\n      new   ＼            ／ __proto__\r\n              ＼        ／\r\n                子類實例\r\n    子類實例.__proto__ 等於 子類.prototype 等於 父類實例\r\n    子類實例.__proto__.constructor 等於 子類\r\n    子類.prototype.constructor 等於 子類\r\n  */\r\n  ```\r\n\r\n- 原型鏈終點\r\n  ```js\r\n  function People(name, age) {\r\n    this.name = name;\r\n    this.age = age;\r\n  }\r\n  var test = new People('test', 12);\r\n  console.log(test.__proto__.__proto__ === Object.prototype);// true\r\n  // 透過Object原型查找可發現無上層繼承\r\n  console.log(Object.prototype.__proto__);// null\r\n  ```\r\n\r\n- hasOwnProperty方法 與 in關鍵字 使用\r\n  ```js\r\n  function People(name, age, sex) {\r\n    this.name = name;\r\n    this.age = age;\r\n    this.sex = sex;\r\n  }\r\n  // 往原型上加入nationality屬性\r\n  People.prototype.nationality = '美國';\r\n  var test = new People('test', 12, '男');\r\n\r\n  // hasOwnProperty 只會尋找自己是否含有該屬性不含原型屬性\r\n  console.log(test.hasOwnProperty('name'));// true\r\n  console.log(test.hasOwnProperty('age'));// true\r\n  console.log(test.hasOwnProperty('sex'));// true\r\n  console.log(test.hasOwnProperty('nationality'));// false\r\n\r\n  // in 會尋找自己與原型是否含有該屬性\r\n  console.log('name' in test);// true\r\n  console.log('age' in test);// true\r\n  console.log('sex' in test);// true\r\n  console.log('nationality' in test);// true\r\n  ```\r\n\r\n<hr id=\"user-content-object-context\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">上下文規則與使用</a>\r\n- 上下文規則1\r\n  - ```對象.方法()``` 上下文是 ```此對象```\r\n  - 範例\r\n    ```js\r\n    function fun(){\r\n      return this.a + this.b;\r\n    }\r\n    var a = 1;\r\n    var b = 2;\r\n    var obj = {\r\n      a: 3,\r\n      b: 3,\r\n      fun: fun\r\n    }\r\n    console.log(obj.fun());// 6 => obj.a + obj.b\r\n    ```\r\n\r\n- 上下文規則2\r\n  - ```函數()``` 上下文是 ```window對象```\r\n  - 範例\r\n    ```js\r\n    function fun(){\r\n      return this.a + this.b;\r\n    }\r\n    var a = 1;\r\n    var b = 2;\r\n    var obj = {\r\n      a: 3,\r\n      b: fun(),\r\n      fun: fun\r\n    }\r\n    console.log(obj.b);// 3 => window.a + window.b \r\n    ```\r\n\r\n- 上下文規則3\r\n  - ```數組或類數組argument[index]()``` 上下文是 ```此數組(類數組)```\r\n  - 範例\r\n    ```js\r\n    var arr = ['A','B','C',function(){console.log(this[0])}];\r\n    console.log(arr[3]());// 'A'\r\n    ```\r\n- 上下文規則4\r\n  - ```IIFE (function(){})()``` 上下文是 ```window對象```\r\n  - 範例\r\n    ```js\r\n    var a = 1;\r\n    var obj = {\r\n      a: 2,\r\n      fun: (function(){\r\n        var a = this.a;\r\n        console.log(this.a);// 1 => window.a\r\n        return function(){\r\n          console.log(a);// 1 => 閉包特性\r\n        }\r\n      })()\r\n    }\r\n    ```\r\n\r\n- 上下文規則5\r\n  - ```setTimeout setInterval``` 上下文是 ```window對象```\r\n  - 範例\r\n    ```js\r\n    var a = 1;\r\n    setTimeout(function(){\r\n      var a = 2;\r\n      console.log(this.a);// 1\r\n      console.log(a);// 2\r\n    },1000)\r\n    ```\r\n\r\n- 上下文規則6\r\n  - ```Dom元素.onclick=function(){} ``` 上下文是 ```Dom元素```\r\n  - 範例\r\n    ```html\r\n    <div id=\"test\">test</div>\r\n    <script>\r\n      var test = document.getElementById(\"test\");\r\n      test.onclick = function(){\r\n        console.log(this);// <div id=\"test\">test</div>\r\n      }\r\n    <\/script>\r\n    ```\r\n\r\n<hr id=\"user-content-call-apply\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">call 與 apply</a> \r\n```js\r\nfunction sum(b1, b2) {\r\n  console.log(this.c + this.m + this.e + b1 + b2);\r\n};\r\n\r\nvar xiaoming = {\r\n  c: 100,\r\n  m: 90,\r\n  e: 80\r\n};\r\n\r\n// call & apply 都可以帶入上下文\r\nsum.call(xiaoming, 3, 5);// call 需要使用逗號\r\nsum.apply(xiaoming, [3, 5]);// apply 需要使用數組\r\n```\r\n\r\n<hr id=\"user-content-object-assign\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Object.assign</a>\r\n- 合併到第一個参數中，返回合併後的第一個參數對象\r\n- 語法 ```Object.assign(目標對象, 源對象1, 源對象2,...): 目標對象```\r\n- 若要返回一個新對象則第一個參數放入空對象\r\n- 基本用法\r\n  ```js\r\n  const apple = {\r\n    color: '红色',\r\n    shape: '圓形',\r\n    taste: '甜'\r\n  };\r\n  const pen = {\r\n    color: '黑色',\r\n    shape: '圓柱形',\r\n    use: '寫字'\r\n  };\r\n  // 後面會覆蓋前面屬性的值\r\n  // {color: \"黑色\", shape: \"圓柱形\", taste: \"甜\", use: \"寫字\"}\r\n  console.log(Object.assign(apple, pen));\r\n  console.log(apple === Object.assign(apple, pen));// true\r\n  ```\r\n- 注意事項\r\n  - 基本數據會先轉換為對象在合併\r\n    ```js\r\n    console.log(Object.assign({}, undefined));// {}\r\n    console.log(Object.assign({}, null));// {}\r\n    console.log(Object.assign({}, 1));// {}\r\n    console.log(Object.assign({}, true));// {}\r\n    console.log(Object.assign({}, 'str'));// {0: \"s\", 1: \"t\", 2: \"r\"}\r\n    ```\r\n\r\n<hr id=\"user-content-object-keys-values-entries\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Object.keys、Object.values、Object.entries</a>\r\n- 基本用法\r\n  ```js\r\n  const person = {\r\n    name: 'test',\r\n    age: 18\r\n  };\r\n\r\n  console.log(Object.keys(person));// (2) ['name', 'age']\r\n  console.log(Object.values(person));// (2) ['test', 18]\r\n  console.log(Object.entries(person));// (2) [Array(2), Array(2)]\r\n  ```\r\n- 與數組方法的區別\r\n  - 對象的 keys()、values()、entries() 是構造函數並返回數組\r\n  - 數組的 keys()、values()、entries() 是實例方法並返回 Iterator\r\n\r\n<hr id=\"user-content-object-date\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Date 對象</a>\r\n- 創建日期對象\r\n  ```js\r\n  // 參數不加則取得今天此时此刻的日期对象\r\n  var d1 = new Date();\r\n  // Mon Oct 04 2021 17:20:18 GMT+0800 (台北標準時間)\r\n  console.log(d1);\r\n  console.log(typeof d1);// object\r\n  // 得到六月一日\r\n  var d2 = new Date(2020, 5, 1);      // 不算時區\r\n  var d3 = new Date('2020-06-01');    // 算時區，8點\r\n  // Mon Jun 01 2020 00:00:00 GMT+0800 (台北標準時間)\r\n  console.log(d2);\r\n  // Mon Jun 01 2020 08:00:00 GMT+0800 (台北標準時間)\r\n  console.log(d3);\r\n  ```\r\n\r\n- 日期對象方法\r\n  ```js\r\n  var d = new Date();\r\n  console.log('日期', d.getDate());// 1~31\r\n  console.log('星期', d.getDay());// 0~6(0=星期天)\r\n  console.log('年份', d.getFullYear());\r\n  console.log('月份', d.getMonth() + 1);// 1~12\r\n  console.log('小時', d.getHours());// 0~23\r\n  console.log('分鐘', d.getMinutes());// 0~59\r\n  console.log('秒數', d.getSeconds());// 0~59\r\n  ```\r\n\r\n- 時間戳\r\n  ```js\r\n  // 日期對象\r\n  var d = new Date();\r\n  // 取得時間戳的兩種方法。時間戳表示1970年1月1日距離此時的毫秒數\r\n  var timestamp1 = d.getTime();// 精确到毫秒\r\n  var timestamp2 = Date.parse(d);// 精确到秒，顯示毫秒，但最後三位一定是000\r\n  // 將时间戳變回日期對象\r\n  var dd = new Date(1601536565000);\r\n  // Thu Oct 01 2020 15:16:05 GMT+0800 (台北標準時間)\r\n  console.log(dd);\r\n  console.log(dd.getFullYear());// 2020\r\n  ```\r\n\r\n<hr id=\"user-content-object-math\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Math 對象</a> \r\n- 四捨五入\r\n  ```js\r\n  console.log(Math.round(3.49));// 3\r\n  console.log(Math.round(3.51));// 4\r\n  // 進位到小數點後面第二位\r\n  var a = 3.7554;\r\n  console.log(Math.round(a * 100) / 100);// 3.76\r\n  ```\r\n\r\n- 隨機數\r\n  ```js\r\n  // 0 ~ 1(包含 0，不包含1)\r\n  console.log(Math.random());\r\n  // 如果要生成[a, b]之内的整數，就要使用公式\r\n  // parseInt(Math.random() * (b - a + 1)) + a\r\n  // [3, 8]\r\n  console.log(parseInt(Math.random() * 6) + 3);\r\n  ```\r\n\r\n- 最大與最小數\r\n  ```js\r\n  console.log(Math.max(44, 55, 33, 22));// 55\r\n  console.log(Math.min(44, 55, 33, 22));// 22\r\n  var arr = [3, 4, 4, 3, 2, 2, 1, 3, 5, 7, 4, 3];\r\n  console.log(Math.max.apply(null, arr));// 7\r\n  ```\r\n\r\n<hr id=\"user-content-regexp\" style=\"height: 4px;\">\r\n\r\n#### <a href=\"#user-content-top\">正則表達式</a> \r\n#### <a href=\"#user-content-top\">創建與使用</a>\r\n- 創建表達式\r\n  ```js\r\n  // 創建正則表達式方法1(能用1則用1)\r\n  // ^:代表開始 $:代表結束 \\d:代表數字 {6}:代表量詞\r\n  var regexp1 = /^\\d{6}$/;\r\n  // 創建正則表達式方法2(因為字符串內部反斜線需要兩個才能正常顯示)\r\n  var regexp2 = new RegExp('^\\\\d{6}$');\r\n  var str = '555666';\r\n  // 正則表達式為引用類型值 regexp1 不等於 regexp2\r\n  console.log(regexp1 === regexp2);// false\r\n  console.log(typeof regexp1);// object\r\n  ```\r\n\r\n- 相關方法\r\n  - 修飾符\r\n    - 修飾符也叫標誌 ```flags``` 可以使用來進行高級搜索\r\n    - 說明\r\n\r\n    | 修飾符 | 意義 |\r\n    | :-- | :-- |\r\n    | ```i``` | 不區分大小寫搜索 |\r\n    | ```g``` | 全局搜索 |\r\n  - ```test()```\r\n    - 測試某字符串是否匹配正則表達式，返回布林值\r\n    - 範例\r\n    ```js\r\n    var regexp1 = /^\\d{6}$/;\r\n    var str = '555666';\r\n    console.log(regexp1.test(str));// true\r\n    ```\r\n  - ```exec()```\r\n    - 根據正則表達式，在字符串中查找，返回數組或null\r\n    - 範例\r\n    ```js\r\n    var str = 'abc123def456ghi789';\r\n    // 若不加g則正則表達式不會記錄已搜索到哪\r\n    var regexp = /\\d+/g;// +表示盡可能多的匹配\r\n    // 使用循環語句来循環執行exec，尋找所有匹配結果\r\n    var result;\r\n    // null=false\r\n    while (result = regexp.exec(str)) {\r\n      console.log(result);\r\n      /*\r\n        ['123', index: 3, input: 'abc123def456ghi789', groups: undefined]\r\n        ['456', index: 9, input: 'abc123def456ghi789', groups: undefined]\r\n        ['789', index: 15, input: 'abc123def456ghi789', groups: undefined]\r\n      */\r\n    }\r\n    console.log(result);// null\r\n    ```\r\n\r\n<hr id=\"user-content-metacharacter\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">元字符</a> \r\n- 說明\r\n  | 元字符 | 功能 |\r\n  | :-- | :-- |\r\n  | ```\\d``` | 匹配一個數字 |\r\n  | ```\\D``` | 匹配一個非數字 |\r\n  | ```\\w``` | 匹配一個單字字符(字母、數字或底線) |\r\n  | ```\\W``` | 匹配一個非單字字符 |\r\n  | ```\\s``` | 匹配一個空白字符(空格、制表符、換行符) |\r\n  | ```.```| 任意字符 |\r\n\r\n- 範例\r\n  ```js\r\n  // 1：某格式為：123-4567-890，使用正則表達式檢查某字符串是否符合此格式\r\n  // 正則表達式\r\n  var regexp1 = /^\\d\\d\\d-\\d\\d\\d\\d-\\d\\d\\d$/;\r\n  // 待測試的字符串\r\n  var str1 = '444-5555-000';\r\n  console.log(regexp1.test(str1));\r\n\r\n  // 2：某格式為：□□□-□□□□-□□□，其中□表示字母數字或者底線，使用正則表達式檢查某字符串是否符合此格式\r\n  // 正則表達式\r\n  var regexp2 = /^\\w\\w\\w-\\w\\w\\w\\w-\\w\\w\\w$/;\r\n  // 待測試的字符串\r\n  var str2 = 'abc-__ab-123';\r\n  console.log(regexp2.test(str2));\r\n\r\n  // 3：某格式為：123.45^67#89，使用正則表達式檢查某字符串是否符合此格式\r\n  // 通常在不確定是否為特殊字符時,在前面加入反斜槓以保證不具特殊意義\r\n  var regexp3 = /^\\d\\d\\d\\.\\d\\d\\^\\d\\d\\#\\d\\d$/;\r\n  // 待测试的字符串\r\n  var str3 = '666.66^66#66';\r\n  console.log(regexp3.test(str3));\r\n  ```\r\n\r\n<hr id=\"user-content-square-brackets\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">方括號表示法</a>\r\n- 說明\r\n  - 短橫 ```-``` 代表字符範圍\r\n  - ```^``` 代表否定\r\n\r\n  | 元字符 | 等價的方括號表示法 |\r\n  | :-- | :-- |\r\n  | ```\\d``` | ```[0-9]``` |\r\n  | ```\\D``` | ```[^0-9]``` |\r\n  | ```\\w``` | ```[A-Za-z0-9_]``` |\r\n  | ```\\W``` | ```[^A-Za-z0-9_]``` |\r\n\r\n- 範例\r\n  ```js\r\n  // 某格式為：第1位是一個字母，b表示本科生，y表示研究生，後面是7位数字，用正則表達式表示：\r\n  // 測試字符串\r\n  var str1 = 'm4444555';\r\n  // 用正則表達式檢查\r\n  console.log(/^[by]\\d{7}$/.test(str1));\r\n\r\n  // *******************************************\r\n  // 驗證某字符串是否是5位字母，大小寫均可\r\n  var str2 = 'abcde';\r\n  var str3 = 'abcd5';\r\n  console.log(/^[a-zA-Z]{5}$/.test(str2));\r\n  console.log(/^[a-zA-Z]{5}$/.test(str3));\r\n\r\n  // 驗證某字符串是否是5位，僅由小寫字母、點構成\r\n  var str4 = 'mnp..';\r\n  var str5 = 'mnp.#';\r\n  console.log(/^[a-z\\.]{5}$/.test(str4));\r\n  console.log(/^[a-z\\.]{5}$/.test(str5));\r\n\r\n  // 驗證某字符串為4位小寫字母，且最後一位不能是m\r\n  var str6 = 'abcd';\r\n  var str7 = 'abcm';\r\n  var str8 = 'ab1c';\r\n  // 直接排除小寫英文裡面的m\r\n  console.log(/^[a-z]{3}[a-ln-z]$/.test(str6));\r\n  console.log(/^[a-z]{3}[a-ln-z]$/.test(str7));\r\n  console.log(/^[a-z]{3}[a-ln-z]$/.test(str8));\r\n  ```\r\n\r\n<hr id=\"user-content-string-regexp\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">字串相關方法</a>\r\n- 說明\r\n\r\n  | 方法 | 簡介 |\r\n  | :-- | :-- |\r\n  | ```search()``` | 根據正則表達式進行匹配<br>返回首次匹配的索引，若無則返回-1 |\r\n  | ```match()``` | 根據正則表達式進行匹配<br>返回一個數組，若無則返回null |\r\n  | ```replace()``` | 使用替換字符串替換匹配到的字符串<br>可以使用正則表達式 |\r\n  | ```split()``` | 分隔字串為數組<br>可以使用正則表達式 |\r\n\r\n- 範例\r\n  ```js\r\n  var str = 'abc123def4567ghi89';\r\n  // search()方法 返回找到的第一個下標，若找不到則返回-1\r\n  // 像indexOf()但不能用正則表達式\r\n  var result1 = str.search(/\\d+/g);\r\n  var result2 = str.search(/m/g);\r\n  console.log(result1);// 3\r\n  console.log(result2);// -1\r\n\r\n  // match()方法，返回查找到的數組，找不到就是null\r\n  var result3 = str.match(/\\d+/g);\r\n  console.log(result3);// [\"123\", \"4567\", \"89\"]\r\n\r\n  // replace()方法，進行替換; \r\n  // 下面的+號是指將盡可能多的小寫字母轉換成*,若不寫+號將會把每一個小寫字母都換成*\r\n  // +表示盡可能多連續匹配小寫字母\r\n  var result4 = str.replace(/[a-z]+/g, '*');      \r\n  console.log(result4);// *123*4567*89\r\n\r\n  // split()方法，進行字符串拆為數組\r\n  var result5 = str.split(/\\d+/g);\r\n  console.log(result5);// [\"abc\", \"def\", \"ghi\", \"\"]\r\n  ```\r\n\r\n<hr id=\"user-content-measure-word\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">量詞</a>\r\n- 說明\r\n\r\n  | 量詞 | 意義 |\r\n  | :-- | :-- |\r\n  | ```*``` | 匹配前一個表達式0次或多次，等價於 ```{0,}``` |\r\n  | ```+``` | 匹配前一個表達式1次或多次，等價於 ```{1,}``` |\r\n  | ```?``` | 匹配前一個表達式0次或1次，等價於 ```{0,1}``` |\r\n  | ```{n}``` | n是一個正整數，匹配前一個字符剛好出現n次 |\r\n  | ```{n,}``` | n是一個正整數，匹配前一個字符至少出現n次 |\r\n  | ```{n,m}``` | n與m都是整數，匹配前一個字符至少n次最多m次 |\r\n\r\n- 範例\r\n  ```js\r\n  // 驗證字符串是否符合規則：11位數字，並且以1開頭\r\n  var str1 = '13812345678';\r\n  var str2 = '138123456789';\r\n  var str3 = '38123456789';\r\n  var regexp1 = /^1\\d{10}$/;\r\n  console.log(regexp1.test(str1));\r\n  console.log(regexp1.test(str2));\r\n  console.log(regexp1.test(str3));\r\n\r\n  /*\r\n    驗證字符串是否符合規則：\r\n    以字母開頭，中間為任意位數字（最少1位）構成，以字母结尾\r\n  */\r\n  var str4 = 'a123123123b';\r\n  var str5 = 'abcd';\r\n  var str6 = 'a1b';\r\n  var regexp2 = /^[a-zA-Z]\\d+[a-zA-Z]$/;\r\n  console.log(regexp2.test(str4));\r\n  console.log(regexp2.test(str5));\r\n  console.log(regexp2.test(str6));\r\n\r\n  /*\r\n    驗證某字符串是否符合規則：\r\n    以www.開頭，中間為任意位的字符（字母數字或底線，至少一位），\r\n    最後以.com结尾，也可以.com.cn结尾\r\n  */\r\n  var str7 = 'www.google.com';\r\n  var str8 = 'www.sina.com.cn';\r\n  var str9 = 'www.news.cn';\r\n  var regexp3 = /^www\\.\\w+\\.com(\\.cn)?$/;//()代表這整串字符串 ?代表可有可無\r\n  console.log(regexp3.test(str7));\r\n  console.log(regexp3.test(str8));\r\n  console.log(regexp3.test(str9));\r\n  ```\r\n\r\n<hr id=\"user-content-promise-introduce\" style=\"height: 4px;\">\r\n\r\n### <a href=\"#user-content-top\">Promise</a>\r\n#### <a href=\"#user-content-top\">簡介</a>\r\n- ```Promise``` 是異步操作的解決方案\r\n- 一般用来解決層層嵌套的 ```回調地獄``` 問題\r\n- 回調地獄例子\r\n  ```js\r\n  // 每一次移動完成自動調用結束函數\r\n  const move = (el, { x = 0, y = 0 } = {}, end = () => {}) => {\r\n    el.style.transform = `translate3d(${x}px, ${y}px, 0)`;\r\n    el.addEventListener(\r\n      'transitionend',\r\n      () => {\r\n        end();\r\n      },\r\n      false\r\n    );\r\n  };\r\n  const boxEl = document.getElementById('box');\r\n  // 因每一次都需調用結束函數進行下一次移動而造成回調地獄\r\n  document.addEventListener(\r\n    'click',\r\n    () => {\r\n      move(boxEl, { x: 150 }, () => {\r\n        move(boxEl, { x: 150, y: 150 }, () => {\r\n          move(boxEl, { y: 150 }, () => {\r\n            move(boxEl, { x: 0, y: 0 });\r\n          });\r\n        });\r\n      });\r\n    },\r\n    false\r\n  );\r\n  ```\r\n\r\n<hr id=\"user-content-promise-basic-use\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">基本用法</a>\r\n- 1.實例化構造函數生成實例對象\r\n  ```js\r\n  const p = new Promise(() => {});\r\n  ```\r\n- 2.```Promise``` 三種狀態\r\n  - 實例化後是 ```pending（未完成）```\r\n  - 執行 ```resolve```，變成 ```fulfilled(resolved)```，已成功\r\n  - 執行 ```reject```，變成 ```rejected```，已失败\r\n  ```js\r\n  // resolve、reject 可以改名\r\n  const p = new Promise((resolve, reject) => {\r\n    // 通常reject會傳error\r\n    reject(new Error('reason'));\r\n  });\r\n\r\n  p.then(\r\n    data => {\r\n      // 會得到 resolve 的參數\r\n      console.log('success', data);\r\n    },\r\n    err => {\r\n      // 會得到 reject 的 err 參數\r\n      console.log('error', err);\r\n    }\r\n  );\r\n  console.log(p);// Promise\r\n  ```\r\n<hr id=\"user-content-promise-instance-function-then\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">實例方法</a>\r\n#### <a href=\"#user-content-top\">then</a>\r\n- ```resolved``` 時，執行 ```then``` 的第一個回調函數\r\n- ```rejected``` 時，執行 ```then``` 的第二個回調函數\r\n- 執行後返回值\r\n  - 無返回則 ```return undefined``` 並返回成功狀態 Promise 對象\r\n  - return 後面的數據，會用 Promise 包裝\r\n- 範例  \r\n  ```js\r\n  const p = new Promise((resolve, reject) => {\r\n    // resolve();\r\n    reject();\r\n  });\r\n\r\n  p.then(\r\n    () => {\r\n      // 當 resolve() 時執行該函數\r\n    },\r\n    () => {\r\n      // 當 reject() 時執行該函數\r\n\r\n      // 若要返回錯誤狀態\r\n      // return new Promise((resolve, reject) => {\r\n      //   reject('reason');\r\n      // });\r\n\r\n      // return 123;\r\n      // 與以下代碼等價(若只有resolve則reject可省略)\r\n      // return new Promise(resolve => {\r\n      //  // 默认返回的永远都是成功状态的 Promise 对象\r\n      //   resolve(123);\r\n      // });\r\n      return 123;\r\n    }\r\n  )\r\n  .then(\r\n    data => {\r\n      console.log('success2', data);// 123\r\n      // 等價於 return undefined;\r\n      return new Promise(resolve => {\r\n        resolve(undefined);\r\n      });\r\n    },\r\n    err => {\r\n      console.log('err2', err);\r\n    }\r\n  )\r\n  .then(\r\n    data => {\r\n      console.log('success3', data);// undefined\r\n    },\r\n    err => {\r\n      console.log('err3', err);\r\n    }\r\n  );\r\n  ```\r\n\r\n<hr id=\"user-content-promise-instance-function-catch\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">catch</a>\r\n- 專門用來處理 ```rejected``` 狀態\r\n- 是 ```then``` 的特例 ```then(null, err => {});```\r\n- 用法\r\n  ```js\r\n  new Promise((resolve, reject) => {\r\n    reject('reason');\r\n  }).then(data => {\r\n    // 因為是reject所以第一個函數不會輸出\r\n    // 並且無reject完後的執行函數所以會跳到catch\r\n    console.log(data);\r\n  })\r\n  // .then(null, err => {\r\n  //   console.log(err);\r\n  // });\r\n  // 注意!若沒發生錯誤則會執行下一個then並跳過catch\r\n  .catch(err => {\r\n    console.log(err);// reason\r\n    // 也可以拋出錯誤\r\n    throw new Error('reason');\r\n  }).then(data => {\r\n    console.log('test',data); \r\n  }).catch(err => {\r\n    console.log('err', err);// err Error: reason\r\n  });\r\n  ```\r\n\r\n<hr id=\"user-content-promise-instance-function-finally\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">finally</a>\r\n- 不論是 resolve 或 reject 都會執行，不變化不會執行\r\n- 是 ```then``` 的特例，\r\n  - 不會取得參數並執行完函數後將前面的參數往後拋\r\n  - 等價於以下\r\n    ```js\r\n    .then(\r\n      result => {\r\n        return result;\r\n      },\r\n      err => {\r\n        return new Promise((resolve, reject) => {\r\n          reject(err);\r\n        });\r\n      }\r\n    )\r\n    ```\r\n- 通常用在最後執行結束的程式\r\n- 用法\r\n  ```js\r\n  new Promise((resolve, reject) => {\r\n    resolve(123);\r\n    // reject('reason');\r\n  })\r\n  .finally(data => {\r\n    // 若在中間也不會有任何的參數\r\n    console.log(data);// undefined\r\n  })\r\n  .then(result =>{\r\n    console.log(result);// 123\r\n  })\r\n  .catch(err => {});\r\n  ```\r\n\r\n<hr id=\"user-content-promise-constructor-function-resolve\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">構造函數方法</a>\r\n#### <a href=\"#user-content-top\">Promise.resolve</a>\r\n- 為成功狀態 ```Promise``` 的一種簡寫形式\r\n- 會先執行 ```resolve``` 括號內的東西\r\n- 以下兩者等價相等\r\n  ```js\r\n  new Promise(resolve => resolve('foo'));\r\n  // 簡寫\r\n  Promise.resolve('foo');\r\n  ```\r\n- 一般參數(預設為成功狀態所以直接輸出)\r\n  ```js\r\n  Promise.resolve('foo').then(data => {\r\n    console.log(data);// foo\r\n  });\r\n  ```\r\n- ```Promise``` 作為參數\r\n  - 會根據 ```resolve``` 括號內的 ```Promise 對象```的狀態變化來決定\r\n  ```js\r\n  const p1 = new Promise((resolve,reject) => {\r\n    setTimeout(resolve, 1000, '執行了');\r\n    // 上面等價於下面\r\n    // setTimeout(() => {\r\n    //   resolve('我执行了');\r\n    // }, 1000);\r\n  });\r\n  Promise.resolve(p1).then(data => {\r\n    console.log(data);// 執行了\r\n  });\r\n  // 等價於\r\n  p1.then(data => {\r\n    console.log(data);// 執行了\r\n  });\r\n  console.log(Promise.resolve(p1) === p1);// true\r\n  ```\r\n- ```then 方法對象``` 作為參數\r\n  - 會轉為 ```Promise 對象```，並立即執行 ```thenable 對象```的 ```then 方法```\r\n  ```js\r\n  const thenable = {\r\n    then(resolve, reject) {\r\n      resolve('data');\r\n    }\r\n  };\r\n  // Promise.resolve(thenable) 整個會轉為 Promise 對象\r\n  // 轉完 Promise 對象後直接執行 then 方法\r\n  // 若裡面觸發 reject 則會到 err \r\n  Promise.resolve(thenable).then(\r\n    data => console.log(data),// data\r\n    err => console.log(err)\r\n  );\r\n  console.log(Promise.resolve(thenable));// Promise {<pending>}\r\n  ```\r\n\r\n<hr id=\"user-content-promise-constructor-function-reject\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Promise.reject</a>\r\n- 為失敗狀態 ```Promise``` 的一種簡寫形式\r\n- 以下兩者等價相等\r\n  ```js\r\n  new Promise((resolve, reject) => {\r\n    reject('reason');\r\n  });\r\n  // 等價於\r\n  Promise.reject('reason');\r\n  ```\r\n- 用法\r\n  ```js\r\n  const p1 = new Promise((resolve,reject) => {\r\n    setTimeout(resolve, 1000, '執行了');\r\n  });\r\n  // 不管 resolve、reject 都會跳到catch(rejected)\r\n  Promise.reject(p1)\r\n  .then(data => console.log(data))\r\n  .catch(err => {\r\n    // 若 p1 狀態為 resolve 則會保持 promise 對象\r\n    // 若 p1 狀態為 reject 則會輸出 \"執行了\"\r\n    console.log(err);//Promise {<pending>}\r\n    return err;// 將 p1 的 resolve promise 對象往後拋\r\n  })\r\n  .then(data => console.log(data));// 執行了\r\n  ```\r\n\r\n<hr id=\"user-content-promise-constructor-function-all\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Promise.all</a>\r\n- 可觀測多個 ```Promise 實例對象```的狀態變化\r\n- 傳入多個 ```Promise 實例```並包裝成一個 ```新的 Promise 實例```返回\r\n- 所有實例狀態都變成 ```resolved```，最终狀態才會變成 ```resolved```\r\n- 只要有一個變成 ```rejected```，最終狀態就變成 ```rejected```(只會輸出```第一個 rejected 結果```)\r\n- 不管中間成功或失敗都會依序執行\r\n- 參數若為空數組，最終狀態為 ```resolved```\r\n  ```js\r\n  const p = Promise.all([]);\r\n  p.then(\r\n    data => {\r\n      console.log(data);// []\r\n    }\r\n  );\r\n  ```\r\n- 用法\r\n  ```js\r\n  const delay = ms => {\r\n    return new Promise(resolve => {\r\n      setTimeout(resolve, ms);\r\n    });\r\n  };\r\n  const p1 = delay(1000).then(() => {\r\n    console.log('p1 完成了');\r\n    return 'p1';\r\n  });\r\n  const p2 = delay(2000).then(() => {\r\n    console.log('p2 完成了');\r\n    return 'p2';\r\n  });\r\n  const p = Promise.all([p1, p2]);\r\n  p.then(\r\n    data => {\r\n      // 只有所有都成功時才會輸出\r\n      console.log(data);// [\"p1\", \"p2\"]\r\n    },\r\n    err => {\r\n      // 只要一個是失敗就直接輸出(並且只會輸出第一個失敗)\r\n      console.log(err);\r\n    }\r\n  );\r\n  ```\r\n\r\n<hr id=\"user-content-promise-constructor-function-race\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Promise.race</a>\r\n- 狀態取決於多個對象中第一個完成的 ```Promise 實例對象```\r\n- 不管中間成功失敗都會依序執行\r\n```js\r\nconst delay = ms => {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n};\r\nconst p1 = delay(1000).then(() => {\r\n  return 'p1';\r\n});\r\nconst p2 = delay(2000).then(() => {\r\n  return Promise.reject('reason');\r\n});\r\nconst racePromise = Promise.race([p1, p2]);\r\nracePromise.then(\r\n  data => {\r\n    console.log(data);// 只會輸出第一個成功的:p1\r\n  },\r\n  err => {\r\n    console.log(err);\r\n  }\r\n);\r\n```\r\n\r\n<hr id=\"user-content-promise-constructor-function-allsettled\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Promise.allSettled</a>\r\n- 不管中途為成功或失敗永遠都是成功的\r\n- 並會忠實地記錄所有 ```Promise 實例對象```的回傳\r\n```js\r\nconst delay = ms => {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n};\r\nconst p1 = delay(1000).then(() => {\r\n  return 'p1';\r\n});\r\nconst p2 = delay(2000).then(() => {\r\n  return Promise.reject('p2');\r\n});\r\nconst allSettledPromise = Promise.allSettled([p1, p2]);\r\nallSettledPromise.then(data => {\r\n  console.log('success', data);\r\n});\r\n/*\r\n  success (2) [{…}, {…}]\r\n    0: {status: 'fulfilled', value: 'p1'}\r\n    1: {status: 'rejected', reason: 'p2'}\r\n    length: 2\r\n    [[Prototype]]: Array(0)\r\n*/\r\n```\r\n\r\n<hr id=\"user-content-promise-constructor-function-any\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Promise.any</a>\r\n- 只有全部 ```Promise 實例對象```都是失敗，狀態才會轉變為失敗\r\n- 只要有一個 ```Promise 實例對象```是成功\r\n  - 則狀態轉變為成功\r\n  - 取得該實例對象回傳(不再理會其他實例對象回傳)\r\n  - 不管中間成功或失敗都會依序執行\r\n  - 若同時則按照文檔流順序\r\n- 可用在哪張圖片加載比較快就用哪張圖片\r\n```js\r\nconst delay = ms => {\r\n  return new Promise(resolve => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n};\r\nconst p1 = delay(1000).then(() => {\r\n  return 'p1';\r\n});\r\nconst p2 = delay(2000).then(() => {\r\n  return 'p2';\r\n});\r\nconst anyPromise = Promise.any([p1, p2]);\r\nanyPromise.then(data => {\r\n  console.log('success', data);\r\n});\r\n```\r\n\r\n<hr id=\"user-content-promise-constructor-function-notice\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">注意事項</a>\r\n- ```Promise.all``` / ```race``` / ```allSettled``` 的參數問題\r\n  - 若參數非 ```Promise 數組```，會將數組元素轉變成 ```Promise 對象```\r\n  - 任何可遍歷的都可以作为參數\r\n    - ```Array、String、Set、Map、NodeList、arguments```\r\n  ```js\r\n  Promise.all([1, 2, 3]).then(datas => {\r\n    console.log(datas);// [1, 2, 3]\r\n  });\r\n  // 上下等價\r\n  Promise.all([\r\n    Promise.resolve(1),\r\n    Promise.resolve(2),\r\n    Promise.resolve(3)\r\n  ]).then(datas => {\r\n    console.log(datas);\r\n  });\r\n  ```\r\n- ```Promise.all``` / ```race``` / ```allSettled``` 的錯誤處理\r\n  - 錯誤一旦被個別處理，就不會再處理一遍\r\n  - 若有多個錯誤，第一個錯誤若個別處理則會延續至第二個\r\n  ```js\r\n  const delay = ms => {\r\n    return new Promise(resolve => {\r\n      setTimeout(resolve, ms);\r\n    });\r\n  };\r\n\r\n  const p1 = delay(1000).then(() => {\r\n    return Promise.reject('reason p1');\r\n  })\r\n  .catch(err => {});\r\n\r\n  const p2 = delay(2000).then(() => {\r\n    return Promise.reject('reason p2');\r\n  });\r\n\r\n  const allPromise = Promise.all([p1, p2]);\r\n  allPromise\r\n    .then(datas => {\r\n      console.log(datas);\r\n    })\r\n  .catch(err => console.log(err));// reason p2\r\n  ```\r\n\r\n<hr id=\"user-content-promise-example\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">應用範例</a>\r\n```html\r\n<body>\r\n  <img\r\n    src=\"https://one.jpg\"\r\n    alt=\"\"\r\n    id=\"img\"\r\n  />\r\n\r\n  <script>\r\n    // 異步加載圖片\r\n    const loadImgAsync = url => {\r\n      return new Promise((resolve, reject) => {\r\n        const img = new Image();\r\n        // 加載完時調用\r\n        img.onload = () => {\r\n          resolve(img);\r\n        };\r\n        // 加載錯誤時調用\r\n        img.onerror = () => {\r\n          reject(new Error(`Could not load image at ${url}`));\r\n        };\r\n        // 開始加載\r\n        img.src = url;\r\n      });\r\n    };\r\n\r\n    const imgDOM = document.getElementById('img');\r\n    loadImgAsync('https://two.jpg')\r\n      .then(img => {\r\n        // 如果加載成功則一秒鐘後替換掉原圖片\r\n        setTimeout(() => {\r\n          imgDOM.src = img.src;\r\n        }, 1000);\r\n      })\r\n      .catch(err => {\r\n        // 否則輸出失敗\r\n        console.log(err);\r\n      });\r\n  <\/script>\r\n</body>\r\n```\r\n\r\n<hr id=\"user-content-class\" style=\"height: 2px;\">\r\n\r\n### <a href=\"#user-content-top\">Class</a>\r\n#### <a href=\"#user-content-top\">簡介</a>\r\n- 作為 JavaScript 現有原型程式(prototype-based)繼承的語法糖\r\n- 使用更簡潔的語法來建立物件和處理繼承\r\n- 類可看做是對象的模板，可以創建許多不同的對象\r\n- 基本用法\r\n  - 類名一般為大寫\r\n  - 實例化時會執行構造方法，所以必須有構造方法，但可以不寫\r\n  - 必須使用 ```new``` 關鍵字創建實例對象\r\n    ```js\r\n    // 類名一般為大寫\r\n    class Person {\r\n      // 實例化時會執行構造方法\r\n      constructor(name, age) {\r\n        // this 代表實例對象，定義的是屬性或方法\r\n        // 一般在構造函數中定義屬性，方法不在裡面定義\r\n        this.name = name;\r\n        this.age = age;\r\n        // this.speak = () => {};\r\n      }\r\n      // 所有實例的共享方法(在構造方法定義方法會佔內存)\r\n      speak () {\r\n        console.log('speak');\r\n      }\r\n    }\r\n    // 必須使用 new 關鍵字創建實例對象\r\n    const ls = new Person('LS', 28);\r\n    ```\r\n\r\n<hr id=\"user-content-class-definition-form\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">定義形式</a>\r\n- 聲明形式\r\n  ```js\r\n  class Person {\r\n    constructor() {}\r\n    speak() {}\r\n  }\r\n  // es5\r\n  function Person(){}\r\n  Person.prototype.speak = function (){}\r\n  ```\r\n- 表達式形式\r\n  ```js\r\n  const Person = class {\r\n    constructor() {\r\n      console.log('constructor');\r\n    }\r\n    speak() {}\r\n  };\r\n  // es5\r\n  const Person = function () {};\r\n  ```\r\n- IIFE\r\n  ```js\r\n  // 立即執行的匿名類\r\n  new class {\r\n    constructor() {\r\n      console.log('constructor');\r\n    }\r\n  }();\r\n  // es5\r\n  // 立即執行的匿名構造函數\r\n  (function () {\r\n    console.log('function');\r\n  })();\r\n  ```\r\n\r\n<hr id=\"user-content-class-property-function\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">屬性與方法</a>\r\n- 實例屬性與方法\r\n  ```js\r\n  class Person {\r\n    // 在class內可以直接定義屬性(但不能加const與let)\r\n    age = 0;\r\n    sex = 'male';\r\n    // 建議還是使用建構式定義屬性(若與上面屬性重複則以建構式屬性為主)\r\n    constructor(name, sex) {\r\n      this.name = name;\r\n      this.sex = sex;\r\n    }\r\n    /*\r\n      實例方法就是值為函數的特殊屬性\r\n      建議別使用此創建方式: getSex = function(){}\r\n      因為每實例一個就會給予一個新的函數會占內存\r\n    */\r\n    getSex () {\r\n      return this.sex;\r\n    };\r\n  }\r\n  // 也可以直接定義新增屬性\r\n  const p = new Person('test');\r\n  p.heigh = 180;\r\n  ```\r\n- 靜態屬性與方法\r\n  - 屬於該類的屬性與方法\r\n  - 實例會調用實例的方法，類會調用類的方法\r\n  - 若沒宣告靜態屬性 ```name``` 而直接調用則會輸出類名\r\n  ```js\r\n  class Person {\r\n    // 定義實例屬性\r\n    constructor(name) {\r\n      this.name = name;\r\n    }\r\n    // 定義實例方法\r\n    speak () {\r\n      console.log(this.name)\r\n      return this.name;\r\n    };\r\n\r\n    // 定義類的屬性\r\n    static name = 'test2';\r\n    // 定義類的方法\r\n    static speak() {\r\n      console.log('可以說話');\r\n      // this 指向類\r\n      console.log(this);\r\n    }\r\n  }\r\n  // 也可以在外宣告\r\n  Person.height = 180;\r\n\r\n  const p = new Person('test');\r\n  p.speak();// test\r\n  Person.speak();// 可以說話 class Person {...}\r\n  console.log(Person.name);// test2\r\n  ```\r\n\r\n<hr id=\"user-content-class-private-property-function\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">私有屬性與方法</a>\r\n- 一般屬性與方法是公開的，有被修改的可能，造成意想不到的錯誤\r\n- 以下為常見的兩種解決方法\r\n  - 第一種：開頭 ```_``` 表示私有\r\n    ```js\r\n    class Person {\r\n      constructor(name) {\r\n        this._name = name;\r\n      }\r\n\r\n      speak() {\r\n        console.log('speak');\r\n      }\r\n\r\n      getName() {\r\n        return this._name;\r\n      }\r\n    }\r\n    ``` \r\n  - 第二種：將私有屬性或方法移出類\r\n    ```js\r\n    (function () {\r\n      let name = '';\r\n      class Person {\r\n        constructor(username) {\r\n          name = username;\r\n        }\r\n\r\n        speak() {\r\n          console.log('speak');\r\n        }\r\n\r\n        getName() {\r\n          return name;\r\n        }\r\n      }\r\n\r\n      window.Person = Person;\r\n    })();\r\n    const p = new Person('Test');\r\n    console.log(p.name);// undefined\r\n    console.log(p.getName());// Test\r\n    ``` \r\n\r\n<hr id=\"user-content-class-extends\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">extends</a>\r\n- 子類使用 ```extends``` 關鍵字繼承父類\r\n- 子類會繼承父類的全部屬性與方法\r\n- 若子類與父類有一樣的屬性與方法則會覆蓋父類\r\n  - 有個例外狀況：\r\n    ```js\r\n    // 若子類方法寫法為\r\n    say(){}\r\n    // 父類方法寫法為\r\n    say = function(){}\r\n    // 則子類調用 say 方法會使用父類 say 方法\r\n    ```\r\n- 範例\r\n  ```js\r\n  // 創建父類\r\n  class Person {\r\n    constructor(name, sex) {\r\n      this.name = name;\r\n      this.sex = sex;\r\n\r\n      this.say = function () {\r\n        console.log('say');\r\n      };\r\n    }\r\n\r\n    speak() {\r\n      console.log('speak');\r\n    }\r\n\r\n    static speak() {\r\n      console.log('static speak');\r\n    }\r\n  }\r\n  Person.version = '1.0';\r\n\r\n  // 創建子類\r\n  class Programmer extends Person {\r\n    constructor(name, sex, feature) {\r\n      // this 操作不能放在 super 前面\r\n      super(name, sex);\r\n      // this.feature = feature;\r\n    }\r\n    // 子類覆蓋父類的屬性與方法\r\n    // 同名覆盖實例方法\r\n    speak() {\r\n      console.log('Programmer speak');\r\n    }\r\n    // 同名覆盖靜態方法\r\n    static speak() {\r\n      console.log('Programmer static speak');\r\n    }\r\n  }\r\n  // 同名覆盖靜態屬性\r\n  Programmer.version = '2.0';\r\n\r\n  const zs = new Programmer('zs', '男', '強');\r\n  zs.say();// say\r\n  zs.speak();// Programmer speak\r\n  Programmer.speak();// Programmer static speak\r\n  console.log(Programmer.version);// 2.0\r\n  ```\r\n\r\n<hr id=\"user-content-class-super\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">super</a>\r\n- 作為函數調用\r\n  - 代表父類的構造方法，只能用在子類的構造方法中\r\n  - ```super``` 雖然代表父類的構造方法，但父類內部的 ```this``` 指向子類的實例\r\n  ```js\r\n  class Person {\r\n    constructor(name) {\r\n      this.name = name;\r\n      console.log(this);\r\n    }\r\n  }\r\n\r\n  class Programmer extends Person {\r\n    constructor(name, sex) {\r\n      super(name, sex);\r\n    }\r\n  }\r\n  // 創建 Programmer 實例後，父類 super 會輸出 Programmer\r\n  new Programmer();\r\n  ```\r\n- 作為對象使用\r\n  -  ```super``` 代表父類的原型對象 ```父類.prototype```\r\n  - 透過 ```super``` 調用父類的方法時，内部的 this 指向當前的子類實例\r\n  - 在靜態方法中使用 ```super```\r\n    - 指向父類，而非父类的原型對象(prototype)\r\n    - 透過 ```super``` 調用父類方法時，内部的 ```this``` 指向子類非子類的實例\r\n  ```js\r\n  class Person {\r\n    constructor(name) {\r\n      this.name = name;\r\n      console.log(this);\r\n    }\r\n\r\n    speak() {\r\n      console.log('speak');\r\n      console.log(this);// 若是子類呼叫則輸出子類實例\r\n    }\r\n\r\n    static speak() {\r\n      console.log('Person speak');\r\n      console.log(this);// 若是子類呼叫則輸出子類原型\r\n    }\r\n  }\r\n\r\n  class Programmer extends Person {\r\n    constructor(name, sex) {\r\n      super(name, sex);\r\n      console.log(super.name);// undefined\r\n    }\r\n\r\n    speak() {\r\n      super.speak();// 呼叫父類實例方法\r\n      console.log('Programmer speak');\r\n    }\r\n\r\n    // 在靜態方法中使用 super\r\n    static speak() {\r\n      super.speak();// 呼叫父類靜態方法\r\n      console.log('Programmer speak');\r\n    }\r\n  }\r\n  new Programmer('test').speak();\r\n  Programmer.speak();\r\n  ```\r\n\r\n<hr id=\"user-content-destructuring-assignment\" style=\"height: 4px;\">\r\n\r\n### 其他用法\r\n#### <a href=\"#user-content-top\">解構賦值</a>\r\n- 主要為解析某數據結構並方便取得結構中資料\r\n- 數組或類數組(如```arguments```)的解構賦值\r\n  - 依結構匹配實例\r\n    ```js\r\n    // 依索引值的完成赋值\r\n    const [a, b, c] = [1, 2, 3];\r\n    console.log(a, b, c);// 1 2 3\r\n\r\n    // 若不取該索引內容，可用逗號跳過\r\n    const [a, [, , b], c] = [1, [2, 4, 5], 3];\r\n    console.log(a, b, c);// 1 5 3\r\n\r\n    // 交換變量的值\r\n    let x = 1;\r\n    let y = 2;\r\n    [x, y] = [y, x];\r\n    console.log(x, y);// 2 1\r\n    ```\r\n  - 使用默認值實例\r\n    - 若默認值為表達式，則為惰性求值\r\n    - 當數組成員```嚴格等於(===)undefined```，對應的默認值才會生效\r\n      ```js\r\n      // 基本用法\r\n      const [a = 1, b = 2] = [];\r\n      console.log(a, b);// 1 2\r\n\r\n      // 生效條件範例\r\n      const [a = 1, b = 2] = [3, null];\r\n      console.log(a, b);// 3 null\r\n\r\n      /*\r\n        默認值表達式為惰性求值\r\n        先解構，若取值不到再去執行表達式\r\n      */\r\n      const func = () => {\r\n        console.log('did');\r\n        return 2;\r\n      };\r\n      const [x = func()] = [];// did\r\n      console.log(x);// 2\r\n      ```\r\n- 對象的解構賦值\r\n  - 依属性名完成赋值\r\n    ```js\r\n    // 若名稱與屬性名相同可省略名稱(下面兩行相等)\r\n    const { age, username } = { username: 'test', age: 18 };\r\n    const { age: age, username: username } = { username: 'test', age: 18 };\r\n\r\n    // 取別名\r\n    const { age: age, username: uname } = { username: 'test', age: 18 };\r\n    console.log(age, uname);// 18 test\r\n    ```\r\n  - 使用默認值實例\r\n    - 若默認值為表達式，則為惰性求值\r\n    ```js\r\n    const { username = 'ZhangSan', age = 0 } = { username: 'test' };\r\n    console.log(username, age);// test 0\r\n    ```\r\n  - 在已聲明的變量用於對象的解構賦值，則賦值需在小括號內進行\r\n    ```js\r\n    let x = 2;\r\n    ({ x } = { x: 1 });// 瀏覽器會誤認{}為區塊非對象\r\n    console.log(x);// 1\r\n    ```\r\n- 其他類型的解構賦值\r\n  - 字符串的解構賦值\r\n    ```js\r\n    // 數組形式的解構賦值\r\n    const [a, b, , , c] = 'hello';\r\n    console.log(a, b, c);// h e o\r\n\r\n    // 對象形式的解構賦值\r\n    const { 0: a, 1: b, length } = 'hello';\r\n    console.log(a, b, length);// h e 5\r\n    ```\r\n  - 數值(或布林值)的解構賦值\r\n    ```js\r\n    // 會先將等號右邊轉為對象\r\n    // = new Number(123);\r\n    const { toString:b } = 123;\r\n    console.log(b);// ƒ toString() { [native code] }\r\n    ```\r\n  - undefined 和 null 無法解構賦值\r\n    ```js\r\n    const { toString } = undefined;// Cannot destructure property 'toString'\r\n    const { toString } = null;// Cannot destructure property 'toString'\r\n    ```\r\n\r\n<hr id=\"user-content-object-function-promote\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">對象與函數的提升</a>\r\n- 對象的簡潔表示法\r\n  - 屬性簡潔表示法\r\n    ```js\r\n    // key值若與變量或常量名一樣，可只寫一個\r\n    const age = 18;\r\n    const person = {\r\n      // age: age\r\n      age\r\n    };\r\n    console.log(person);\r\n    ```\r\n  - 方法簡潔表示法\r\n    ```js\r\n    // 可以省略冒號和function關鍵字\r\n    const person = {\r\n      // speak: function () {}\r\n      speak() {}\r\n    };\r\n    console.log(person);\r\n    ```\r\n- 函數的默認參數\r\n  - 函數調用時沒有傳參數才使用默認參數\r\n  - 注意事項\r\n    - 不傳參數或傳undefined作為參數，默認值才會生效\r\n    - 與前面相同默認值為表達式時是惰性求值的\r\n    - 設置默認參數建議從最右邊開始(傳的參數較少時會讀取默認值)\r\n    ```js\r\n    const multiply = (x, y = 1) => x * y;\r\n    console.log(multiply(2));// 2\r\n\r\n    const multiply2 = (x = 1, y) => x * y;\r\n    console.log(multiply2(2));// NaN\r\n    console.log(multiply2(2, undefined));// NaN\r\n    ```\r\n  - 經典範例(結合默認參數與解構賦值)\r\n    ```js\r\n    /*\r\n      1.利用解構賦值特性方便調用屬性\r\n      2.利用默認值特性給予該對象沒值時的默認值\r\n      3.為避免傳進去的參數非對象,所以預設先給一個空對象(={})\r\n        再利用第2點與第1點特性使用解構賦值給予對象屬性與默認值\r\n    */\r\n    const logUser = \r\n    ({ username = 'test', age = 0, sex = 'male' } = {}) =>\r\n    console.log(username, age, sex);\r\n    logUser();// test 0 male\r\n    ```\r\n\r\n<hr id=\"user-content-rest-parameter\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">剩餘參數</a>\r\n- 表示不確定數量的參數，並將其視為一個數組\r\n- 即使沒有多餘的參數，剩餘參數也會是一個空數組\r\n- 注意事項\r\n  - 箭頭函數的參數即使只有一個剩餘參數，也不能省略括號\r\n    ```js\r\n    // 不能省略小括號\r\n    // 建議使用剩餘參數取代arguments\r\n    const add = (...args) => {};\r\n    ```\r\n  - 剩餘參數只能為最後一個參數，之後不能再有其他參數，否則報錯\r\n    ```js\r\n    const add = (x, y, ...args) => {\r\n      console.log(args);\r\n    };\r\n    ```\r\n- 範例\r\n  ```js\r\n  // 搭配解構賦值\r\n  // 數組\r\n  const [num, ...args] = [1, 2, 3, 4];\r\n  console.log(args);// (3) [2, 3, 4]\r\n  // 對象\r\n  const { x, y, ...z } = { a: 3, x: 1, y: 2, b: 4 };\r\n  console.log(z);// {a: 3, b: 4}\r\n  ```\r\n\r\n<hr id=\"user-content-spread-operator\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">展開運算符</a>\r\n- 將可迭代的陣列或字串展開成多個元素\r\n- 如果是物件的話則展開成多個key-value\r\n- 數組展開範例\r\n  ```js\r\n  // 以前無展開運算符做法(因為Math.min()只能依序放入參數)\r\n  console.log(Math.min.apply(null,[3, 1, 2]));\r\n  // 現在做法\r\n  console.log(Math.min(...[3, 1, 2]));\r\n  // 相當於\r\n  console.log(Math.min(3, 1, 2));\r\n  // 合併數組\r\n  const a = [1, 2];\r\n  const b = [3];\r\n  const c = [4, 5];\r\n  console.log([1, ...b, 2, ...a, ...c, 3]);// (8) [1, 3, 2, 1, 2, 4, 5, 3]\r\n  // 字串展開成數組\r\n  console.log(...'test');// t e s t\r\n  // 類數組轉換為數組\r\n  function func() {\r\n    console.log([...arguments]);\r\n  }\r\n  ```\r\n- 對象展開範例\r\n  - 對象不能直接展開，需在 ```{}``` 中展开\r\n  - 在合併對象時，後者會覆蓋前者相同屬性\r\n    ```js\r\n    const apple = {\r\n      color: '红色',\r\n      shape: '球形',\r\n      taste: '甜'\r\n    };\r\n    const pen = {\r\n      color: '黑色',\r\n      shape: '圆柱形',\r\n      use: '寫字'\r\n    };\r\n    console.log({ ...apple, ...pen });\r\n    // {color: '黑色', shape: '圆柱形', taste: '甜', use: '寫字'}\r\n    ```\r\n  - 非對象展開\r\n    - 會自動轉換成對象，將其屬性羅列出來\r\n    ```js\r\n    console.log({ ...1 });// {}\r\n    console.log({ ...undefined });// {}\r\n    console.log({ ...null });// {}\r\n    console.log({ ...true });// {}\r\n    // 若是字符串，會自動轉換一個類似數組對象\r\n    console.log({ ...'test' });// {0: \"t\", 1: \"e\", 2: \"s\", 3: \"t\"}\r\n    ```\r\n\r\n<hr id=\"user-content-set-object\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Set 物件</a>\r\n- Set為一系列無序、無重複值的數據集合\r\n- 類似數組不能像數組一樣通過字面量的方式創建 ```const s = new Set();```\r\n- Set 對重複值的判斷基本遵循嚴格相等(===)，並且定義 NaN 等於 NaN\r\n- 使用時機\r\n  - 數組或字符串去重時\r\n  - 無須訪問內部指定項，只需要遍歷時\r\n  - 需使用 Set 提供的方法和屬性時\r\n- Set 可傳入的參數\r\n  - 數組\r\n    ```js\r\n    const s = new Set([1, 2, 1]);\r\n    console.log(s);// Set(2) {1, 2}\r\n    ```\r\n  - 字符串\r\n    ```js\r\n    console.log(new Set('hi'));// Set(2) {'h', 'i'}\r\n    ```\r\n  - arguments\r\n    ```js\r\n    function func() {\r\n      console.log(new Set(arguments));\r\n    }\r\n    func(1, 2, 1);// Set(2) {1, 2}\r\n    ```\r\n  - NodeList\r\n    ```html\r\n    <body>\r\n      <p>1</p>\r\n      <p>2</p>\r\n      <p>3</p>\r\n      <script>\r\n        // Set(3) {p, p, p}\r\n        console.log(new Set(document.querySelectorAll('p')));\r\n      <\/script>\r\n    </body>\r\n    ```\r\n  - Set\r\n    ```js\r\n    const s = new Set([1, 2, 1]);\r\n    // 複製set\r\n    console.log(new Set(s) === s);//false (引用類型)\r\n    console.log(s);// Set(2) {1, 2}\r\n    ```\r\n- Set 屬性與方法\r\n  - size 屬性\r\n    ```js\r\n    const s = new Set();\r\n    s.add(1).add(2).add(2);\r\n    console.log(s);// Set(2) {1, 2}\r\n    console.log(s.size);// 2\r\n    ```\r\n  - add 方法\r\n    ```js\r\n    const s = new Set();\r\n    s.add(1).add(2).add(2);\r\n    console.log(s);// Set(2) {1, 2}\r\n    ```\r\n  - has 方法\r\n    ```js\r\n    const s = new Set();\r\n    s.add(1).add(2).add(2);\r\n    console.log(s.has(1));// true\r\n    console.log(s.has(3));// false\r\n    ```\r\n  - delete 方法\r\n    - delete 不存在的成員，不會報錯也不會輸出\r\n    ```js\r\n    const s = new Set();\r\n    s.add(1).add(2).add(2);\r\n    s.delete(1);\r\n    s.delete(3);\r\n    console.log(s);// Set(1) {2}\r\n    ```\r\n  - clear 方法\r\n    ```js\r\n    const s = new Set();\r\n    s.add(1).add(2).add(2);\r\n    s.clear();\r\n    console.log(s);// Set(0) {size: 0}\r\n    ```\r\n  - forEach 方法\r\n    - 第一個參數是回調函數，第二個參數指定了回調函數中this對象\r\n    - 若回調函數是箭頭函數，則第二個參數不會影響該函數內的this指向\r\n    - 會按照成員添加集合的順序遍歷\r\n    ```js\r\n    s.forEach( function (value, key, set) {\r\n      // Set 中 value = key、set = s\r\n      console.log(value, key, set === s);\r\n      // 若為 function 則輸出 document(要回傳的對象)\r\n      // 若為 箭頭函數 則輸出 window (因為該函數在全局定義)\r\n      console.log(this);// #document\r\n    }, document);\r\n    ```\r\n- 範例\r\n  ```html\r\n  <body>\r\n    <p>1</p>\r\n    <p>2</p>\r\n    <p>3</p>\r\n    <script>\r\n      // 數組去重\r\n      console.log([...new Set([1, 2, 1])]);// [1, 2]\r\n      // 字符串去重\r\n      console.log([...new Set('abbacbd')].join(''));// abcd\r\n      // 遍歷\r\n      const s = new Set(document.querySelectorAll('p'));\r\n      s.forEach(function (elem) {\r\n        elem.style.color = 'red';\r\n        elem.style.backgroundColor = 'yellow';\r\n      });\r\n    <\/script>\r\n  </body>\r\n  ```\r\n\r\n<hr id=\"user-content-map-object\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Map 物件</a>\r\n- Map 是鍵值對的集合\r\n- Map 判断键名是否相同基本遵循嚴格相等(===)，並且定義 NaN 等於 NaN\r\n- 使用時機\r\n  - 需要 key -> value 結構，或字符串以外的值做key\r\n  - 模拟現實實體時，建議才使用對象\r\n- Map 和對象的區别\r\n  - 對象一般用字符串當鍵\r\n  - Map 可將以下都作為鍵\r\n    - 基本數據類型：number、string、boolean、undefined、null\r\n    - 引用數據類型：對象（[]、{}、函数、Set、Map 等）\r\n    ```js\r\n    const m = new Map();\r\n    m.set('name', 'test');\r\n    m.set(true, 'true');\r\n    m.set({}, 'object');\r\n    m.set(new Set([1, 2]), 'set');\r\n    m.set(undefined, 'undefined');\r\n    /*\r\n      {\r\n        \"name\" => \"test\",\r\n        true => \"true\",\r\n        {…} => \"object\",\r\n        Set(2) => \"set\",\r\n        undefined => \"undefined\"\r\n      }\r\n    */\r\n    console.log(m);\r\n    ```\r\n- Map 可傳入的參數\r\n  - 二維數組，必须體現鍵和值\r\n    ```js\r\n    console.log(\r\n      new Map([\r\n        ['name', 'test'],\r\n        ['age', 18]\r\n      ])\r\n    );// {\"name\" => \"test\", \"age\" => 18}\r\n    ```\r\n  - Set，必须體現鍵和值\r\n    ```js\r\n    const s = new Set([\r\n      ['name', 'test'],\r\n      ['age', 18]\r\n    ]);\r\n    console.log(new Map(s));// {\"name\" => \"test\", \"age\" => 18}\r\n    console.log(s);// {Array(2), Array(2)}\r\n    ```\r\n  - Map\r\n    ```js\r\n    // 複製了一个新Map\r\n    const m1 = new Map([\r\n      ['name', 'test'],\r\n      ['age', 18]\r\n    ]);\r\n    console.log(m1);// {\"name\" => \"test\", \"age\" => 18}\r\n    const m2 = new Map(m1);\r\n    console.log(m2, m2 === m1);// {\"name\" => \"test\", \"age\" => 18} false\r\n    ```\r\n- Map 屬性與方法\r\n  - size 屬性\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    console.log(m.size);// 2\r\n    ```\r\n  - set 方法\r\n    - 添加的新成员，鍵若已存在，後添加的鍵值會覆蓋前面的\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    console.log(m);// Map(2) {'age' => 20, true => 'true'}\r\n    ```\r\n  - get 方法\r\n    - 獲取不存在的成員，返回 ```undefined```\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    console.log(m.get('true'));// undefined\r\n    console.log(m.get(true));// true\r\n    ```\r\n  - has 方法\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    console.log(m.has('age'));// true\r\n    console.log(m.has('true'));// false\r\n    ```\r\n  - delete 方法\r\n    - delete 不存在的成員，不會報錯也不會輸出\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    m.delete('age');\r\n    m.delete('name');\r\n    console.log(m);// Map(1) {true => 'true'}\r\n    ```\r\n  - clear 方法\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    m.clear();\r\n    console.log(m);// Map(0) {size: 0}\r\n    ```\r\n  - forEach 方法\r\n    - 第一個參數是回調函數，第二個參數指定了回調函數中this對象\r\n    - 若回調函數是箭頭函數，則第二個參數不會影響該函數內的this指向\r\n    ```js\r\n    const m = new Map();\r\n    m.set('age', 18).set(true, 'true').set('age', 20);\r\n    m.forEach(function (value, key, map) {\r\n      console.log(value, key, map === m);\r\n      console.log(this);// #document\r\n    }, document);\r\n    ```\r\n- 範例\r\n  ```html\r\n  <body>\r\n    <p>1</p>\r\n    <p>2</p>\r\n    <p>3</p>\r\n    <script>\r\n      const [p1, p2, p3] = document.querySelectorAll('p');\r\n      const m = new Map([\r\n        [\r\n          p1,\r\n          {\r\n            color: 'red',\r\n            backgroundColor: 'yellow',\r\n            fontSize: '40px'\r\n          }\r\n        ],\r\n        [\r\n          p2,\r\n          {\r\n            color: 'green',\r\n            backgroundColor: 'pink',\r\n            fontSize: '40px'\r\n          }\r\n        ],\r\n        [\r\n          p3,\r\n          {\r\n            color: 'blue',\r\n            backgroundColor: 'orange',\r\n            fontSize: '40px'\r\n          }\r\n        ]\r\n      ]);\r\n\r\n      // 利用每一個元素與css屬性的對應關係做遍歷\r\n      m.forEach((propObj, elem) => {\r\n        for (const p in propObj) {\r\n          elem.style[p] = propObj[p];\r\n        }\r\n      });\r\n    <\/script>\r\n  </body>\r\n  ```\r\n\r\n<hr id=\"user-content-iterator-for-of\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Iterator 與 for-of 循環</a>\r\n- Iterator 迭代器\r\n  - 何謂 Iterator\r\n    ```txt\r\n    Symbol.iterator（可遍历对象的生成方法） ->\r\n    it（可遍历对象） -> it.next() ->...（直到 done 为 true）\r\n    ```\r\n  - 為何需要 Iterator\r\n    - Iterator 是一個統一的遍歷方式\r\n    - 遍歷數組：for 循環 和 forEach方法\r\n    - 遍歷對象：for in 循環\r\n  - 以下為常用到 Iterator 的場合\r\n    - for-of\r\n    - 展開運算符\r\n    - 解構賦值\r\n    - Set 和 Map 的構造函數\r\n  - 範例\r\n    ```js\r\n    const it = [1, 2][Symbol.iterator]();\r\n    console.log(it.next()); // {value: 1, done: false}\r\n    console.log(it.next()); // {value: 2, done: false}\r\n    console.log(it.next()); // {value: undefined, done: true}\r\n    ```\r\n- for-of 循環\r\n  - 為 iterator 的封裝\r\n  - 只會遍歷出 done 為 false 時對應的 value 值\r\n  - 範例\r\n    - keys() 得到可遍歷對象索引值\r\n    - values() 得到可遍歷對象內容\r\n    - entries() 得到可遍歷對象索引+內容组成的數組\r\n    ```js\r\n    const arr = [1, 2, 3];\r\n    // 依序列出 1 2 3\r\n    for (const item of arr) {\r\n      console.log(item);\r\n    }\r\n\r\n    // 與 break、continue 一起使用\r\n    // 依序列出 1 3\r\n    for (const item of arr) {\r\n      if (item === 2) {\r\n        continue;\r\n      }\r\n      console.log(item);\r\n    }\r\n\r\n    // entries() 得到可遍歷對象索引+內容组成的數組\r\n    // 並利用解構賦值解構\r\n    for (const [index, value] of arr.entries()) {\r\n      console.log(index, value);\r\n    }\r\n    ```\r\n- 原生可遍歷對象\r\n  - 何謂原生可遍歷對象\r\n    ```txt\r\n    只要有 Symbol.iterator 方法，\r\n    並且此方法可生成可遍歷對象，就是可遍歷\r\n    也就可使用 for-of 循環来遍歷\r\n    ```\r\n  - 原生可遍歷對象大致以下幾種\r\n    - Array\r\n    - String\r\n    - Set\r\n    - Map\r\n    - Arguments\r\n    - NodeList\r\n  - 建立非原生可遍歷對象的for-of\r\n    ```js\r\n    // 創建一般對象\r\n    const person = { sex: 'male', age: 18 };\r\n    // 實現next方法並含 value & done 屬性 {next()} {value,done}\r\n    person[Symbol.iterator] = () => {\r\n      let index = 0;\r\n      return {\r\n        next() {\r\n          index++;\r\n          if (index === 1) {\r\n            return {\r\n              value: person.age,\r\n              done: false\r\n            };\r\n          } else if (index === 2) {\r\n            return {\r\n              value: person.sex,\r\n              done: false\r\n            };\r\n          } else {\r\n            return {\r\n              done: true\r\n            };\r\n          }\r\n        }\r\n      };\r\n    };\r\n    // 依序列出 18 male\r\n    for (const item of person) {\r\n      console.log(item);\r\n    }\r\n    ```\r\n<hr id=\"user-content-symbol\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">Symbol</a>\r\n- 為ES6引入的基本數據類型\r\n- 主要用途是表示獨一無二的值，避免對象屬性被覆蓋\r\n- 基本語法\r\n  ```js\r\n  // 創建 Symbol\r\n  let test1 = Symbol();\r\n  let test2 = Symbol();\r\n  console.log(test1);// Symbol()\r\n  console.log(test1 === test2);// false\r\n  ```\r\n- 新增 Symbol 變量的敘述\r\n  - 增加 Symbol 的可讀性\r\n  ```js\r\n  // 創建並敘述該Symbol\r\n  let test1 = Symbol('test1');\r\n  let test2 = Symbol('test2');\r\n  console.log(test1);// Symbol(test1)\r\n  console.log(test2);// Symbol(test2)\r\n  ```\r\n- Symbol 屬性的遍歷\r\n  - Symbol作為對象屬性時，不會出現在for-in、for-of循環中\r\n  ```js\r\n  let test1 = Symbol('test1');\r\n  let test2 = Symbol('test2');\r\n  let a = {\r\n    name: 'test3',\r\n    [test1]: 18,\r\n    [test2]: function(){}\r\n  }\r\n  // 只會輸出 name\r\n  for(const i in a){\r\n    console.log(i);\r\n  }\r\n  ```\r\n- Symbol.for()\r\n  - 可以創建相同的Symbol\r\n  ```js\r\n  // 全局註冊以'test'為描述符的Symbol\r\n  // 若裡面參數非字串則自動轉換成字串\r\n  let test1 = Symbol.for('test');\r\n  let test2 = Symbol.for('test');\r\n  console.log(test1);// Symbol(test)\r\n  console.log(test1 === test2);// true\r\n  ```\r\n- Symbol.keyFor()\r\n  - 查詢全局註冊Symbol的描述符\r\n  ```js\r\n  let test1 = Symbol.for('test');\r\n  let key = Symbol.keyFor(test1);\r\n  console.log(key);// test\r\n  ```\r\n- Symbol 轉換其他類型值\r\n  ```js\r\n  let s1 = Symbol('test');\r\n  let s2 = String(s1);\r\n  let s3 = Boolean(s1);\r\n  let s4 = Number(s1);\r\n  console.log(s2);// Symbol(test)\r\n  console.log(s3);// true\r\n  console.log(s4);// Cannot convert a Symbol value to a number\r\n  ```\r\n\r\n<hr id=\"user-content-function-throttle-lock\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">函數節流鎖</a>\r\n- 功能：確保函數執行中途不會再次執行\r\n- 使用情境：常使用在動畫或輪播圖，避免使用者短時間觸發多次\r\n- 範例\r\n  ```js\r\n  var lock = true;\r\n  function needToLock(){\r\n    // 如果關閉狀態則不執行\r\n    if(!lock) return;\r\n    // 鎖住\r\n    lock = false;\r\n    // 一秒過後開鎖\r\n    setTimeout(function(){\r\n      lock = true;\r\n    }, 1000);\r\n  }\r\n  ```\r\n\r\n<hr id=\"user-content-separate-time-function\" style=\"height: 2px;\">\r\n\r\n#### <a href=\"#user-content-top\">分時函數</a>\r\n- 功用：需單次渲染大量資料時使用，避免造成畫面停頓卡住\r\n- 使用情境：當後端一次性給予大量項目資料時可使用\r\n- 範例\r\n  ```js\r\n  /*\r\n    dataArray：需依序放入指定函數的資料的陣列\r\n    fn：將陣列中單個資料放入後執行的函數\r\n    count：每次執行要處理陣列內多少個數據\r\n    duration：每次執行的秒數\r\n  */\r\n  const timeChunk = function(dataArray, fn, count, duration) {\r\n    // 若沒有要處理的資料則直接返回\r\n    if(!dataArray || !dataArray.length) return;\r\n    // 存儲定時器\r\n    let timer;\r\n    // 防止重複執行\r\n    let isRunning = false;\r\n    // 分批執行函數\r\n    let eachExecute = function() {\r\n      for(let i = 0; i < Math.min(count || 1, dataArray.length); i++) {\r\n        const obj = dataArray.shift();\r\n        fn(obj);// 執行指定函數\r\n      }\r\n    }\r\n\r\n    return function() {\r\n      if (isRunning) return;\r\n      isRunning = true;\r\n      // 使用定時器\r\n      timer = setInterval(function() {\r\n        // 當資料處理完成時，將定時器清除\r\n        if (dataArray.length == 0) {\r\n          clearInterval(timer);\r\n          isRunning = false;\r\n        }\r\n        // 若還未處理完成則繼續分批處理\r\n        eachExecute();\r\n      }, duration);\r\n    }\r\n  }\r\n\r\n  const render = timeChunk(new Array(10), function() {console.log('render')}, 5, 1000);\r\n  /*\r\n    輸出:\r\n    render\r\n    render\r\n  */\r\n  ```\r\n",m=Object(t["w"])(!0),f=Object(t["w"])(!1),y=Object(t["w"])(!0),b=Object(t["w"])(!1),x=Object(t["w"])(""),v={name:"JSNote",components:{Loading:g["a"]},setup:function(){return Object(t["p"])(Object(s["a"])(regeneratorRuntime.mark((function n(){var r;return regeneratorRuntime.wrap((function(n){while(1)switch(n.prev=n.next){case 0:if(!m.value){n.next=7;break}return r=i()({html:!0,linkify:!0,typographer:!0,highlight:function(n,r){return p.a.highlight(n,{language:r}).value}}).use(u["a"]),x.value=r.render("".concat(h)),n.next=5,Object(a["c"])((function(){m.value=!1}),1e3).then((function(){return Object(a["c"])((function(){y.value=!1,b.value=!0}),500)})).then((function(){return Object(a["c"])((function(){f.value=!0,Object(a["a"])()}),100)}));case 5:n.next=8;break;case 7:Object(a["a"])();case 8:case"end":return n.stop()}}),n)})))),Object(l["a"])(),{showLoading:m,showContent:f,displayLoading:y,displayContent:b,htmlContent:x}}};e("8287");v.render=o;r["default"]=v}}]);
//# sourceMappingURL=jsNote.3b0f02c4.js.map