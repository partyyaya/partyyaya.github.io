{"version":3,"sources":["webpack:///./src/views/OtherNote.vue","webpack:///./src/assets/md/Other.md","webpack:///./src/views/OtherNote.vue?ea19","webpack:///./src/views/OtherNote.vue?d613"],"names":["displayLoading","class","displayContent","htmlContent","showLoading","showContent","name","components","Loading","setup","value","mdConfig","html","linkify","typographer","highlight","str","lang","language","result","render","setTimeout"],"mappings":"oNACA,4BAKU,EAAAA,gB,iBALV,eAMI,GANJ,MACKC,MAAK,C,iBAA6B,c,gBAAqC,gB,mBAD5E,sBAaU,EAAAC,gB,iBANR,eASM,OAhBR,MAQKD,MAAK,C,uCAA8D,c,gBAAqC,gB,CAOzG,eAAsD,OAAjDA,MAAM,gBAAgB,UAAQ,EAAAE,a,2BAfvC,uB,sFCDe,25bD2BXC,EAAc,gBAAI,GAClBC,EAAc,gBAAI,GAClBL,EAAiB,gBAAI,GACrBE,EAAiB,gBAAI,GACnBC,EAAc,eAAI,IAET,GACbG,KAAM,YACNC,WAAY,CAAEC,UAAA,MACdC,MAHa,WAiCX,OA7BA,eAAS,wCAAC,sGACJL,EAAYM,QACRC,EAAW,IAAG,CAClBC,MAAM,EACNC,SAAS,EACTC,aAAa,EAEbC,UALkB,SAKPC,EAAKC,GACd,OAAO,IAAKF,UAAUC,EAAK,CAACE,SAAUD,IAAOP,SAG3CS,EAASR,EAASS,OAAT,UAAmB,IAClCjB,EAAYO,MAAQS,EAEpBE,YAAW,WAETjB,EAAYM,OAAQ,EACpBW,YAAW,WAETrB,EAAeU,OAAQ,EACvBR,EAAeQ,OAAQ,EACvBW,YAAW,WAEThB,EAAYK,OAAQ,IACnB,OACF,OACF,MA1BG,4CA6BH,CACLN,cACAC,cACAL,iBACAE,iBACAC,iB,UElEN,EAAOiB,OAASA,EAED,gB,yDCPf","file":"js/otherNote.0adf7d65.js","sourcesContent":["<template>\r\n  <Loading\r\n    :class=\"{\r\n      'content--hide': !showLoading,\r\n      'content--show': showLoading,\r\n    }\"\r\n    v-if=\"displayLoading\"\r\n  />\r\n  <div\r\n    :class=\"{\r\n      'markdown-content': true,\r\n      'content--hide': !showContent,\r\n      'content--show': showContent,\r\n    }\"\r\n    v-if=\"displayContent\"\r\n  >\r\n    <div class=\"markdown-body\" v-html=\"htmlContent\"></div>\r\n  </div>\r\n</template>\r\n\r\n<script>\r\nimport { ref, onMounted } from \"vue\";\r\nimport md from \"markdown-it\";\r\nimport hljs from \"highlight.js\";\r\nimport Loading from \"../components/Loading\";\r\nimport data from \"!raw-loader!../assets/md/Other.md\";\r\n\r\nlet showLoading = ref(true);\r\nlet showContent = ref(false);\r\nlet displayLoading = ref(true);\r\nlet displayContent = ref(false);\r\nconst htmlContent = ref(\"\");\r\n\r\nexport default {\r\n  name: \"OtherNote\",\r\n  components: { Loading },\r\n  setup() {\r\n    onMounted(async () => {\r\n      if (showLoading.value) {\r\n        const mdConfig = md({\r\n          html: true,\r\n          linkify: true,\r\n          typographer: true,\r\n          // 針對特定語言顯示文字突出效果\r\n          highlight (str, lang) {\r\n            return hljs.highlight(str, {language: lang}).value;\r\n          },\r\n        });\r\n        const result = mdConfig.render(`${data}`);\r\n        htmlContent.value = result;\r\n\r\n        setTimeout(() => {\r\n          // 等待 v-if 效果\r\n          showLoading.value = false;\r\n          setTimeout(() => {\r\n            // 等待loading動畫結束\r\n            displayLoading.value = false;\r\n            displayContent.value = true;\r\n            setTimeout(() => {\r\n              // 等待 v-if 效果\r\n              showContent.value = true;\r\n            }, 100);\r\n          }, 500);\r\n        }, 1000);\r\n      }\r\n    });\r\n    return {\r\n      showLoading,\r\n      showContent,\r\n      displayLoading,\r\n      displayContent,\r\n      htmlContent,\r\n    };\r\n  },\r\n};\r\n</script>\r\n<style lang=\"scss\">\r\n@import \"../style/md.scss\";\r\n.content--hide {\r\n  opacity: 0;\r\n}\r\n\r\n.content--show {\r\n  opacity: 1;\r\n}\r\n</style>\r\n","export default \"## 其他常用知識筆記\\r\\n<a id=\\\"user-content-top\\\"></a>\\r\\n\\r\\n### 目錄\\r\\n<details open>\\r\\n<summary style=\\\"cursor: pointer;\\\">&nbsp;目錄清單 </summary>\\r\\n\\r\\n- [HTTP](#user-content-http)\\r\\n- [RESTful API](#user-content-restful)\\r\\n- [Cookie](#user-content-cookie)\\r\\n- [LocalStorage](#user-content-localstorage)\\r\\n- [跨域](#user-content-cross-domain)\\r\\n- [CORS](#user-content-cors)\\r\\n- [JSONP](#user-content-jsonp)\\r\\n- [好文參考](#user-content-link)\\r\\n\\r\\n</details>\\r\\n\\r\\n<hr id=\\\"user-content-http\\\" style=\\\"height: 4px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >HTTP</a>\\r\\n- ```HTTP``` 全名為：```HyperText Transfer Protocol (超文本傳輸協議)```\\r\\n  - 超文本定義：將一個個單一的文本通過超連結聯繫起來，變成可無限延伸擴展的超級文本\\r\\n- ```HTTP``` 為請求-響應的協議，過程大致如下：\\r\\n  - 1.檢查是否有緩存與是否過期\\r\\n  - 2.若沒有或過期則詢問服務器\\r\\n  - 3.先詢問瀏覽器是否有存服務器的ip，若無則去DNS或更深一層去找ip\\r\\n    - 請求完一次會先緩存在瀏覽器\\r\\n- ```HTTP``` 請求方法：一組能給定資源，執行特定操作的方法\\r\\n  - [mozilla 說明](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods)\\r\\n- ```HTTP``` 狀態碼為服務器對請求的處理結果代碼，大致分以下幾種\\r\\n  - [mozilla 說明](https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Status)\\r\\n  - ```100 ~ 199``` 代表消息：請求已被接受，需要繼續處理\\r\\n  - ```200 ~ 299``` 代表成功\\r\\n  - ```300 ~ 399``` 代表重定向：當一個網頁有更高級的位址時會重定向\\r\\n    - ```301 Moved Permanently```：永久性的重定向(只詢問一次服務器，需警慎)\\r\\n    - ```302 Move Temporarily```：暫時性的重定向(每次都會詢問服務器是否需要重定向)\\r\\n    - ```304 Not Modified```：代表沒有修改資料不用再向服務器請求\\r\\n  - ```400 ~ 499```：代表請求錯誤\\r\\n    - ```404```：```Not Found```\\r\\n  - ```500 ~ 599```：代表服務器錯誤\\r\\n    - ```500```：```Internal Server Error```\\r\\n\\r\\n<hr id=\\\"user-content-restful\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >RESTful API</a>\\r\\n- ```RESTful API``` 可拆分為以下兩個單詞解釋\\r\\n  - RESTful 全名為：```Representational State Transfer (表現層狀態轉移)```\\r\\n  - API 全名為：```Application Programming Interface (應用程式介面)```\\r\\n- ```RESTful API``` 由以下三種元素組成\\r\\n  - ```Nouns 名詞```：取得資料的 URL，如：```https://www.google.com```\\r\\n  - ```Verbs 動詞```：對資料的動作，如：```GET、POST```\\r\\n  - ```Content Types```：資料呈現方式，如：```JSON、YAML、XML```\\r\\n- ```RESTful API``` 風格：\\r\\n  - 將對資料的行為藏在 ```HTTP method``` 內\\r\\n  - ```Method``` 代表行為，```URI``` 代表資源/對象，以下為範例：\\r\\n    ```txt\\r\\n    取得商品列表：GET /products\\r\\n    取得某一商品詳情：GET /products/12\\r\\n    增加商品：POST /products\\r\\n    替换某一商品：PUT /products/12\\r\\n    修改某一商品：PATCH /products/12\\r\\n    删除某一商品：DELETE /products/12\\r\\n    ```\\r\\n  - 常見的使用方式：\\r\\n    ```txt\\r\\n    使用者登入後取得 token，\\r\\n    藉由 token 讓後端驗證是否給予資料\\r\\n    若無 token 或 token過期 則跳至登入頁面(禁止查看特定頁面)\\r\\n    ```\\r\\n- ```RESTful API``` 常用 ```HTTP``` 狀態碼：\\r\\n  - ```200``` 代表成功：請求已經成功，並且有返回內容。\\r\\n  - ```201``` 代表已建立：請求成功，而且在伺服器上新建了一個資源（如：新增文章）。\\r\\n  - ```202``` 代表已接受：伺服器接受了一個請求，但伺服器可能沒辦法馬上完成，例如需要排程的工作。\\r\\n  - ```204``` 代表成功但無回傳：請求成功，但是沒有任何回傳內容。\\r\\n  - ```400``` 代表錯誤請求：請求中有些資料的內容不正確而無法被解讀，請注意：不是表單驗證錯誤。\\r\\n  - ```401``` 代表需要登入：使用者必須登入才能執行這個動作。\\r\\n  - ```403``` 代表沒有權限：沒有權限可以存取這個資源，請注意：如果是因為沒有登入，請參考 401 狀態碼。\\r\\n  - ```404``` 代表找不到資源：資源、檔案已經不存在了。\\r\\n  - ```409``` 代表衝突：要建立的資源在伺服器上已經有相同的存在了，例如：名稱衝突、格式相同。\\r\\n  - ```412``` 代表驗證規則錯誤：請求內容無法通過伺服器預先設置好的規則驗證，例如：表單驗證失敗。\\r\\n  - ```500``` 代表內部錯誤：伺服器出現了錯誤。\\r\\n\\r\\n<hr id=\\\"user-content-cookie\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >Cookie</a>\\r\\n- ```Cookie``` 全稱為：```HTTP Cookie```\\r\\n- 瀏覽器存儲資料的一種方式，存儲在本地瀏覽器\\r\\n  - 一般會自動隨著瀏覽器每次請求發送到服務器端\\r\\n- 用途\\r\\n  - 可跟蹤統計用戶訪問該網站習慣，如：何時訪問、常訪問那些頁面、頁面停留時間\\r\\n- 寫入與讀取方式\\r\\n  ```js\\r\\n  // 寫入 Cookie：document.cookie = '鍵=值'\\r\\n  // 一般鍵會使用英文，值可以使用中文(要編碼)\\r\\n  // 無法多個一起設置\\r\\n  document.cookie = 'username=zs';// O\\r\\n  document.cookie = 'age=18';// O\\r\\n  document.cookie = 'username=zs; age=18';// X\\r\\n  // 鍵與值若包含非英文字母，則寫入需使用 encodeURIComponent() 編碼\\r\\n  document.cookie = `username=${encodeURIComponent('測試人')}`;\\r\\n\\r\\n  // 2.讀取 Cookie\\r\\n  // 讀取的是一串由鍵值構成的字符串，中間都由分號隔開\\r\\n  console.log(document.cookie);// username=zs; age=18\\r\\n  // 鍵與值若包含非英文字母，則讀取需使用 decodeURIComponent() 解碼\\r\\n  console.log(decodeURIComponent(document.cookie));\\r\\n  ```\\r\\n- 失效到期時間設置\\r\\n  - 失效的 ```Cookie``` 會被瀏覽器清除\\r\\n  - 若無設置失效到期時間，則該 ```Cookie``` 會變為 ```會話 Cookie```\\r\\n    - 會話結束或瀏覽器關閉時，會話 ```Cookie``` 會被刪除\\r\\n  - 設置 ```expires```\\r\\n    - 值為 ```Date``` 類型\\r\\n    ```js\\r\\n    const now = new Date();\\r\\n    const time = now.getTime();\\r\\n    const expireTime = time + 60000;// 存活60秒\\r\\n    now.setTime(expireTime);\\r\\n    document.cookie = 'cookie=ok;expires='+now.toGMTString()+';';\\r\\n    ```\\r\\n  - 設置 ```max-age```\\r\\n    - 值為數字，表示當前時間加多少秒後失效，單位為秒\\r\\n    - 如果 ```max-age``` 值為 0 或負數，則 ```Cookie``` 會被刪除\\r\\n    - 範例\\r\\n      ```js\\r\\n      document.cookie = 'username=alex; max-age=5';\\r\\n      document.cookie = `username=alex; max-age=${24 * 3600 * 30}`;\\r\\n      ```\\r\\n- 設置 ```Domain```\\r\\n  - 可限定訪問 ```Cookie``` 的範圍（不同域名）\\r\\n  - 使用 ```JS``` 只能讀寫當前域或父域的 ```Cookie```，無法讀寫其他域的 ```Cookie```\\r\\n  - 範例\\r\\n    ```js\\r\\n    // 若設置 www.imooc.com 則 .imooc.com 可讀取，但 m.imooc.com 不能讀取該Cookie\\r\\n    document.cookie = 'username=test; domain=www.imooc.com';\\r\\n    // 若設置 .imooc.com 則 www.imooc.com 、 m.imooc.com 皆可讀取該 Cookie\\r\\n    document.cookie = 'username=test; domain=.imooc.com';\\r\\n    // www.imooc.com、m.imooc.com 與 .imooc.com 成子父域關係\\r\\n    ```\\r\\n- 設置 ```Path```\\r\\n  - 可限定了訪問 ```Cookie``` 的範圍（同一個域名下）\\r\\n  - 使用 JS 只能讀寫當前路徑與上級路徑的 ```Cookie```，無法讀寫下級路徑的 ```Cookie```\\r\\n    - 如：```/course/list``` 可以讀取 ```/course``` 但不能讀取 ```/course/list/a``` 的 ```Cookie```\\r\\n  - 範例\\r\\n    ```js\\r\\n    document.cookie = 'username=test; path=/course/list';\\r\\n    ```\\r\\n- 當 ```Name、Domain、Path``` 三個字段都相同，才會是同一個 ```Cookie```，否則不會覆蓋\\r\\n- ```HttpOnly```：設置該屬性的 ```Cookie``` 無法透過 ```JS``` 去訪問\\r\\n- ```Secure``` 安全標誌：限定只有使用了 ```https``` 非 ```http``` 的情況下才可發送給服務端\\r\\n  - 範例：```document.cookie = \\\"tagname = test;secure\\\";```\\r\\n- ```Domain、Path、Secure、未失效Cookie``` 以上都要滿足條件，才能隨著請求發送到服務端\\r\\n- 操作 ```Cookie``` 注意事項\\r\\n  - 請勿在 ```Cookie``` 內保存密碼等敏感資料\\r\\n  - 創建 ```Cookie``` 時，鍵與值必須要填寫，其他可使用默認 \\r\\n  - ```Cookie``` 的鍵與值若包含非英文字母，則寫入需要使用 ```encodeURIComponent()``` 編碼，讀取需使用 ```decodeURIComponent()``` 解碼\\r\\n  - 在 ```Chrome``` 瀏覽器開發者視窗 ```Application > Storage > Cookies``` 可以設置 ```Cookie``` 並刷新就可發送\\r\\n  - 可使用 ```document.cookie``` 來取得(可讀可寫) ```Cookie```，多個 ```Cookie``` 會由分號分隔\\r\\n  - 前後端都可以創建 ```Cookie```\\r\\n  - 每個域名下的 ```Cookie``` 限約 20 個，當超過單個域名限制再設置 ```Cookie```，瀏覽器就會清除以前設置的 ```Cookie```\\r\\n  - ```Cookie``` 存儲容量很小，最多大約只有 4KB\\r\\n\\r\\n<hr id=\\\"user-content-localstorage\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >LocalStorage</a>\\r\\n- ```LocalStorage``` 是一種瀏覽器存儲數據的方式，只存儲再本地，不會發送至服務器端\\r\\n- 使用方式\\r\\n  ```js\\r\\n  // 輸出 Storage 物件\\r\\n  console.log(localStorage);\\r\\n  // 存儲資料\\r\\n  localStorage.setItem('username', 'alex');\\r\\n  localStorage.setItem('username', 'zs');// 相同的key，後者會覆蓋前者\\r\\n  localStorage.setItem('age', 18);\\r\\n  localStorage.setItem('sex', 'male');\\r\\n  // 輸出目前存儲資料數量\\r\\n  console.log(localStorage.length);\\r\\n  // 取得存儲資料\\r\\n  console.log(localStorage.getItem('username'));// zs\\r\\n  console.log(localStorage.getItem('age'));// 18\\r\\n  // 若不存在該key，則回傳null\\r\\n  console.log(localStorage.getItem('name'));// null\\r\\n  // 移除存儲資料\\r\\n  localStorage.removeItem('username');\\r\\n  localStorage.removeItem('age');\\r\\n  // 删除不存在的 key，不會報錯\\r\\n  localStorage.removeItem('name');\\r\\n  // 刪除全部存儲資料\\r\\n  localStorage.clear();\\r\\n  ```\\r\\n- ```SessionStorage``` 與 ```LocalStorage``` 差異\\r\\n  - 會在關閉窗口與瀏覽器時刪除，其他與 ```LocalStorage``` 功能相同\\r\\n  - 在不同窗口存儲的數據不能共享，```LocalStorage``` 與 ```Cookie```在不同窗口可以共享\\r\\n- 使用 ```LocalStorage``` 注意事項\\r\\n  - 單個域名下 ```LocalStorage``` 可使用大小約為5MB\\r\\n  - ```LocalStorage``` 為持久化本地存儲，除非手動清除，否則不會過期\\r\\n  - ```LocalStorage``` 鍵與值只能為字符串類型，非字符串類型也會轉成字符串再存儲進去\\r\\n  - 不同域名不能共用 ```LocalStorage``` \\r\\n  - IE8 開始支持 ```LocalStorage```\\r\\n\\r\\n<hr id=\\\"user-content-cross-domain\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >跨域</a>\\r\\n- 跨域的定義：若請求的域與當前域為不同域，就是跨域\\r\\n- 如何判斷為不同域\\r\\n  - 只要 ```協議(http、https)、域名(www.google.com.tw)、端口(80、443、...)```，其中一個不相同，就是不同域\\r\\n  - 路徑不一樣無所謂\\r\\n  - 範例解釋\\r\\n    ```txt\\r\\n    不同域\\r\\n    https://www.test.com:443/course/list\\r\\n    http://www.test.com:80/course/list\\r\\n    http://m.test.com:80/course/list\\r\\n    http://test.com:80/course/list\\r\\n\\r\\n    同域\\r\\n    http://test.com:80\\r\\n    http://test.com:80/course/list\\r\\n    ```\\r\\n- 為何跨域會被阻止\\r\\n  - 阻止跨域请求，是瀏覽器本身的一種安全策略(同源策略)\\r\\n  - 通常客户端或服務器端皆不存在跨域被阻止的問題\\r\\n- 解決方案如下(優先使用 ```CORS```，若瀏覽器不支持，再使用 ```JSONP```)\\r\\n  - ```CORS```\\r\\n  - ```JSONP```\\r\\n\\r\\n<hr id=\\\"user-content-cors\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >CORS</a>\\r\\n- ```CORS``` 全稱為 ```Cross-Origin Resource Sharing(跨域資源共享)```\\r\\n- 說明：存取非同源資源時，後端須告知瀏覽器允許何種請求，只有允許的請求能被瀏覽器實際發送，否則失敗。\\r\\n- 跨來源請求分兩種：```簡單``` 與 ```非簡單``` 的跨來源請求\\r\\n- ```簡單跨來源請求```\\r\\n  - ```簡單跨來源請求``` 須符合兩個條件：\\r\\n    - 請求方法只能是：```GET、POST、HEAD```\\r\\n    - 自訂 ```request header``` 只能是：\\r\\n      ```txt\\r\\n      Accept、Accept-Language、Content-Language、\\r\\n      Content-Type 只能是 application/x-www-form-urlencoded、multipart/form-data、text/plain\\r\\n      ```\\r\\n    - 不符合以上條件就是 ```「非」簡單跨來源請求```\\r\\n  - 不符合簡單跨來源請求例子：\\r\\n    ```js\\r\\n    /*\\r\\n      違反簡單跨來源請求的地方有三個，分別是：\\r\\n      (1) PUT 方法\\r\\n      (2) Content-Type 是 application/json\\r\\n      (3) 帶了不合規範的 X-CUSTOM-HEADER。\\r\\n    */\\r\\n    const response = await fetch('https://www.test.com/products', {\\r\\n      method: 'PUT',\\r\\n      headers: {\\r\\n        'Content-Type': 'application/json',\\r\\n        'X-CUSTOM-HEADER': '777'\\r\\n      }\\r\\n    });\\r\\n    ```\\r\\n  - 請求過程大致如下\\r\\n    - 1.當瀏覽器發送跨來源請求時，會帶一個 ```Origin header```，比如：\\r\\n      ```txt\\r\\n      GET /products/\\r\\n      Host: www.test.com\\r\\n      Origin: https://mywebsite.io\\r\\n      ```\\r\\n    - 2.後端收到跨來源請求時，會依據 ```Origin``` 來授權 ```JS``` 允許存取這個資源\\r\\n    - 3.若後端允許則會在 ```response header``` 添加設置\\r\\n      - 只允許特定來源請求：```Access-Control-Allow-Origin: https://mywebsite.io```\\r\\n      - 允許任何跨來源請求：```Access-Control-Allow-Origin: *```\\r\\n    - 4.瀏覽器接收回應時，會檢查請求的 ```Origin``` 與回應的 ```Access-Control-Allow-Origin``` 是否相符\\r\\n    - 5.若相符則 ```JS``` 會收到回應反之則無\\r\\n  - ```JS``` 預設可存取的 ```簡單 response header``` 如下：\\r\\n    - Cache-Control\\r\\n    - Content-Language\\r\\n    - Content-Type\\r\\n    - Expires\\r\\n    - Last-Modified\\r\\n    - Pragma\\r\\n    - 若要存取其他 ```header```，後端可用 ```Access-Control-Expose-Headers header``` 設定，比如：\\r\\n      ```txt\\r\\n      X-MY-CUSTOM-HEADER: 777\\r\\n      X-MY-OTHER-CUSTOM-HEADER: 777\\r\\n      Access-Control-Expose-Headers: X-MY-CUSTOM-HEADER, X-MY-OTHER-CUSTOM-HEADER\\r\\n      ```\\r\\n- ```「非」簡單跨來源請求```\\r\\n  - 與 ```簡單跨來源請求``` 不同的是，會先發送 ```preflight request（預檢請求）```\\r\\n  - ```預檢請求```：\\r\\n    - 說明：瀏覽器會先詢問後端是否允許該請求，若允許才將請求完整送出\\r\\n    - 是一個 ```http OPTIONS``` 方法，會攜帶兩個 ```request header```：\\r\\n      - 「非」簡單跨來源請求的方法：```Access-Control-Request-Method```\\r\\n      - 「非」簡單跨來源請求帶有「非」簡單 ```header```：```Access-Control-Request-Headers```\\r\\n    - 請求過程：\\r\\n      - 假設請求如下：\\r\\n        ```js\\r\\n        fetch('https://www.test.com/products/', {\\r\\n          method: 'POST',\\r\\n          headers: {\\r\\n            'Content-Type': 'application/json',\\r\\n            'X-CUSTOM-HEADER': '777'\\r\\n          }\\r\\n        })\\r\\n        ```\\r\\n      - ```request header``` 預計如下\\r\\n        ```\\r\\n        POST /products/\\r\\n        Host: www.test.com\\r\\n        Origin: https://mywebsite.io\\r\\n        Content-Type: application/json\\r\\n        X-MY-CUSTOM-HEADER: 777\\r\\n        ```\\r\\n      - 則發送的 ```preflight request```：\\r\\n        ```\\r\\n        OPTIONS /products/\\r\\n        Host: www.test.com\\r\\n        Origin: https://mywebsite.io\\r\\n        Access-Control-Request-Method: POST\\r\\n        Access-Control-Request-Headers: X-MY-CUSTOM-HEADER, Content-Type\\r\\n        Preflight Response\\r\\n        ```\\r\\n      - 後端收到後將回應瀏覽器兩個 ```header```\\r\\n        - 允許的方法：```Access-Control-Allow-Methods```\\r\\n        - 允許的「非」簡單 ```header```：```Access-Control-Allow-Headers```\\r\\n        - 範例：\\r\\n          ```\\r\\n          Access-Control-Allow-Methods: POST\\r\\n          Access-Control-Allow-Headers: X-MY-CUSTOM-HEADER, Content-Type\\r\\n          ```\\r\\n      - 若被列在允許名單則瀏覽器會送出跨來源請求\\r\\n      - 最後瀏覽器接收回應時，會檢查請求的 ```Origin``` 與回應的 ```Access-Control-Allow-Origin``` 是否相符\\r\\n      - 若相符才會讓 ```JS``` 正常輸出反之報錯\\r\\n- 跨來源請求的 ```Cookie```\\r\\n  - 一般的請求會帶有該網域下的 ```Cookie```，而跨來源請求預設不能帶 ```Cookie``` (有安全隱私顧慮)\\r\\n  - 因此瀏覽器針對此點做了規範，需設定「要存取跨域 cookie」，如以下設定：\\r\\n    ```js\\r\\n    // fetch 需設定 credentials: 'include'：\\r\\n    fetch('https://www.test.com/products', {\\r\\n      credentials: 'include'\\r\\n    })\\r\\n    ```\\r\\n  - 後端若是信任來源也需設定 ```Access-Control-Allow-Credentials: true```，瀏覽器才會寫進該域\\r\\n  - 若允許 ```Cookie``` 則 ```Access-Control-Allow-Origin: *``` 不能使用，因安全性考量須明確標示來源\\r\\n- 當使用 ```CORS``` 可依循此 SOP：\\r\\n  - 1.是否為 ```簡單跨來源請求```，若是則後端方法加上 ```Access-Control-Allow-Origin header```\\r\\n  - 2.若為 ```「非」簡單跨來源請求```，則後端加上以下：\\r\\n    - ```Access-Control-Allow-Methods```\\r\\n    - ```Access-Control-Allow-Headers```\\r\\n    - ```Access-Control-Allow-Origin```\\r\\n  - 3.若需使用 ```Cookie``` 則\\r\\n    - 前端要加上如 ```fetch credentials: 'include'```\\r\\n    - 後端要加上 ```Access-Control-Allow-Credentials```，且不能用 ```Access-Control-Allow-Origin:  *```。\\r\\n\\r\\n\\r\\n<hr id=\\\"user-content-jsonp\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >JSONP</a>\\r\\n- ```JSONP``` 全稱為 ```JSON with Padding```\\r\\n- 原理：利用 ```script``` 標籤不會被瀏覽器阻擋的特性，加載跨域文件\\r\\n- 實現方式：\\r\\n  - 1.服務器端準備 ```JSONP``` 接口，透過客戶端自訂的函數名傳送資料\\r\\n    ```txt\\r\\n    handleResponse 可以更換其他名稱\\r\\n    範例：https://www.test.com/api/jsonp?callback=handleResponse\\r\\n    回傳：\\r\\n    handleResponse({\\r\\n      code: 200,\\r\\n      data: [\\r\\n        {\\r\\n          word: 'jsp'\\r\\n        },\\r\\n        {\\r\\n          word: 'js'\\r\\n        },\\r\\n        {\\r\\n          word: 'json'\\r\\n        }\\r\\n      ]\\r\\n    });\\r\\n    ```\\r\\n  - 2.前端 ```JSONP``` 函數\\r\\n    ```js\\r\\n    const handleResponse = data => {\\r\\n      console.log(data);\\r\\n    };\\r\\n    ```\\r\\n  - 3.手動或動態加載 ```JSONP``` 接口(讓服務器資料傳進來)\\r\\n    ```js\\r\\n    const script = document.createElement('script');\\r\\n    script.src = 'https://www.test.com/api/jsonp?callback=handleResponse';\\r\\n    document.body.appendChild(script);\\r\\n    ```\\r\\n  \\r\\n<hr id=\\\"user-content-link\\\" style=\\\"height: 2px;\\\">\\r\\n\\r\\n#### <a href=\\\"#user-content-top\\\" >好文參考</a>\\r\\n- [MDN](https://developer.mozilla.org/zh-TW/)\\r\\n- [瀏覽器工作原理與實踐](https://blog.poetries.top/browser-working-principle/guide/part1/lesson01.html)\\r\\n- [Shubo 的程式教學筆記](https://shubo.io/tags/)\\r\\n\";","import { render } from \"./OtherNote.vue?vue&type=template&id=fa8e0928\"\nimport script from \"./OtherNote.vue?vue&type=script&lang=js\"\nexport * from \"./OtherNote.vue?vue&type=script&lang=js\"\n\nimport \"./OtherNote.vue?vue&type=style&index=0&id=fa8e0928&lang=scss\"\nscript.render = render\n\nexport default script","export * from \"-!../../node_modules/mini-css-extract-plugin/dist/loader.js??ref--8-oneOf-1-0!../../node_modules/css-loader/dist/cjs.js??ref--8-oneOf-1-1!../../node_modules/vue-loader-v16/dist/stylePostLoader.js!../../node_modules/postcss-loader/src/index.js??ref--8-oneOf-1-2!../../node_modules/sass-loader/dist/cjs.js??ref--8-oneOf-1-3!../../node_modules/cache-loader/dist/cjs.js??ref--0-0!../../node_modules/vue-loader-v16/dist/index.js??ref--0-1!./OtherNote.vue?vue&type=style&index=0&id=fa8e0928&lang=scss\""],"sourceRoot":""}